# rubocop:disable Metrics/ModuleLength
module Discorb
  Colour: untyped
  API_BASE_URL: untyped
  VERSION: untyped
  USER_AGENT: untyped

  # @!visibility private
  # @!macro [new] async
  #   @note This is an asynchronous method, it will return a `Async::Task` object. Use `Async::Task#wait` to get the result.
  # 
  # @!macro [new] client_cache
  #   @note This method returns an object from client cache. it will return `nil` if the object is not in cache.
  #   @return [nil] The object wasn't cached.
  # 
  # @!macro members_intent
  #   @note You must enable `GUILD_MEMBERS` intent to use this method.
  # 
  # @!macro edit
  #   @note The arguments of this method are defaultly set to `:unset`. Specify value to set the value, if not don't specify or specify `:unset`.
  # 
  # @!macro http
  #   @note This method calls HTTP request.
  #   @raise [Discorb::HTTPError] HTTP request failed.
  def macro: () -> void

  # @!visibility private
  class Logger
    def initialize: (untyped _out, untyped colorize_log, untyped level) -> void

    def level: () -> untyped

    def level=: (untyped level) -> untyped

    def debug: (untyped message) -> untyped

    def info: (untyped message) -> untyped

    def warn: (untyped message) -> untyped

    def error: (untyped message) -> untyped

    def fatal: (untyped message) -> untyped

    def write_output: (untyped name, untyped color, untyped message) -> untyped

    # Returns the value of attribute out.
    attr_reader out: untyped

    # Returns the value of attribute colorize_log.
    attr_reader colorize_log: untyped
  end

  # 
  # Represents a attachment file.
  class Attachment < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped data) -> void

    # @return [#read] The file content.
    attr_reader io: untyped

    # @return [Discorb::Snowflake] The attachment id.
    attr_reader id: Discorb::Snowflake

    # @return [String] The attachment filename.
    attr_reader filename: String

    # @return [String] The attachment content type.
    attr_reader content_type: String

    # @return [Integer] The attachment size in bytes.
    attr_reader size: Integer

    # @return [String] The attachment url.
    attr_reader url: String

    # @return [String] The attachment proxy url.
    attr_reader proxy_url: String

    # @return [Integer] The image height.
    # @return [nil] If the attachment is not an image.
    attr_reader height: Integer?

    # @return [Integer] The image width.
    # @return [nil] If the attachment is not an image.
    attr_reader width: Integer?

    # @return [Boolean] whether the file is an image.
    attr_reader image?: bool
  end

  # 
  # Represents a file to send as an attachment.
  class File
    def initialize: (untyped io, ?untyped filename, ?content_type: untyped) -> void

    # @return [#read] The IO of the file.
    attr_accessor io: untyped

    # @return [String] The filename of the file. If not set, path or object_id of the IO is used.
    attr_accessor filename: String

    # @return [String] The content type of the file. If not set, it is guessed from the filename.
    attr_accessor content_type: String
  end

  # 
  # Represents a flag.
  # @abstract
  class Flag
    # Initialize the flag.
    # @note This is usually called by the subclass.
    # 
    # @param [Integer] value The value of the flag.
    def initialize: (Integer value) -> void

    def method_missing: (untyped name, ?untyped args) -> untyped

    def respond_to_missing?: (untyped sym, untyped include_private) -> bool

    # 
    # Union of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The union of the two flags.
    def |: (Discorb::Flag other) -> Discorb::Flag

    # 
    # Subtraction of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The subtraction of the two flags.
    def -: (Discorb::Flag other) -> Discorb::Flag

    # 
    # Intersection of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The intersection of the two flags.
    def &: (Discorb::Flag other) -> Discorb::Flag

    # 
    # XOR of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The XOR of the two flags.
    def ^: (Discorb::Flag other) -> Discorb::Flag

    # 
    # Negation of the flag.
    # 
    # @return [Discorb::Flag] The negation of the flag.
    def ~@: () -> Discorb::Flag

    # 
    # Max value of the flag.
    # 
    # @return [Integer] the max value of the flag.
    def self.max_value: () -> Integer

    # @return [Hash{Symbol => Boolean}] the values of the flag.
    attr_reader values: ::Hash[Symbol, bool]

    # @return [Integer] the value of the flag.
    attr_reader value: Integer
  end

  # 
  # Represents a role in the guild.
  class Role < Discorb::DiscordModel
    include Comparable

    # @!visibility private
    def initialize: (untyped client, untyped guild, untyped data) -> void

    # 
    # Compares two roles by their position.
    # 
    # @param [Discorb::Role] other The role to compare to.
    # 
    # @return [Integer] -1 if the other role is higher, 0 if they are equal, 1 if the other role is lower.
    def <=>: (Discorb::Role other) -> Integer

    # 
    # Formats the role as a string.
    # 
    # @return [String] The formatted string.
    def to_s: () -> String

    def mention: () -> untyped

    def color?: () -> bool

    def inspect: () -> untyped

    # 
    # Moves the role to a new position.
    # @macro async
    # @macro http
    # 
    # @param [Integer] position The new position.
    # @param [String] reason The reason for moving the role.
    def move: (Integer position, ?reason: String?) -> untyped

    # 
    # Edits the role.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new name of the role.
    # @param [Integer] position The new position of the role.
    # @param [Discorb::Color] color The new color of the role.
    # @param [Boolean] hoist Whether the role should be hoisted.
    # @param [Boolean] mentionable Whether the role should be mentionable.
    # @param [String] reason The reason for editing the role.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?color: Discorb::Color,
                ?hoist: bool,
                ?mentionable: bool,
                ?reason: String?
              ) -> untyped

    # 
    # Deletes the role.
    # 
    # @param [String] reason The reason for deleting the role.
    def delete!: (?reason: String?) -> untyped

    def tag: () -> untyped
    # @return [Discorb::Snowflake] The ID of the role.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the role.
    attr_reader name: String

    # @return [Discorb::Color] The color of the role.
    attr_reader color: Discorb::Color

    # @return [Discorb::Permission] The permissions of the role.
    attr_reader permissions: Discorb::Permission

    # @return [Integer] The position of the role.
    attr_reader position: Integer

    # @return [Discorb::Guild] The guild this role belongs to.
    attr_reader guild: Discorb::Guild

    # @return [Boolean] Whether the role is hoisted.
    attr_reader hoist: bool

    # @return [Boolean] Whether the role is managed.
    attr_reader managed: bool

    # @return [Boolean] Whether the role is a default role.
    attr_reader mentionable: bool

    # 
    # Represents a tag of a role.
    class Tag < Discorb::DiscordModel
      # @!visibility private
      def initialize: (untyped data) -> void

      # @return [Discorb::Snowflake] The ID of the bot that owns the role.
      attr_reader bot_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the integration.
      attr_reader integration_id: Discorb::Snowflake

      # @return [Boolean] Whether the tag is a premium subscriber role.
      attr_reader premium_subscriber: bool

      # @return [Boolean] Whether the role is a bot role.
      attr_reader bot?: bool

      # @return [Boolean] Whether the role is an integration role.
      attr_reader integration?: bool
    end
  end

  # 
  # Represents a user of discord.
  class User < Discorb::DiscordModel
    include Discorb::Messageable

    # @!visibility private
    def initialize: (untyped client, untyped data) -> void

    # 
    # Format the user as `Username#Discriminator` style.
    # 
    # @return [String] The formatted username.
    def to_s: () -> String

    def inspect: () -> untyped

    # 
    # Whether the user is a owner of the client.
    # @macro async
    # @macro http
    # 
    # @param [Boolean] strict Whether don't allow if the user is a member of the team.
    # 
    # @return [Boolean] Whether the user is a owner of the client.
    def bot_owner?: (?strict: bool) -> bool

    # @!visibility private
    def base_url: () -> untyped
    # 
    # Post a message to the channel.
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Components>, Array<Array<Discorb::Components>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Discorb::Message] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Components] | ::Array[::Array[Discorb::Components]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Discorb::Message

    # 
    # Fetch a message from ID.
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Discorb::Message] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Discorb::Message

    # 
    # Fetch a message history.
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Array<Discorb::Message>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> ::Array[Discorb::Message]

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [Boolean] Whether the user is verified.
    attr_reader verified: bool

    # @return [String] The user's username.
    attr_reader username: String

    # @return [Discorb::Snowflake] The user's ID.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::User::Flag] The user's flags.
    attr_reader flag: Discorb::User::Flag

    # @return [String] The user's discriminator.
    attr_reader discriminator: String

    # @return [Discorb::Asset] The user's avatar.
    attr_reader avatar: Discorb::Asset

    # @return [Boolean] Whether the user is a bot.
    attr_reader bot: bool

    # 
    # Represents the user's flags.
    # ## Flag fields
    # |`1 << 0`|`:discord_employee`|
    # |`1 << 1`|`:partnered_server_owner`|
    # |`1 << 2`|`:hypesquad_events`|
    # |`1 << 3`|`:bug_hunter_level_1`|
    # |`1 << 6`|`:house_bravery`|
    # |`1 << 7`|`:house_brilliance`|
    # |`1 << 8`|`:house_balance`|
    # |`1 << 9`|`:early_supporter`|
    # |`1 << 10`|`:team_user`|
    # |`1 << 14`|`:bug_hunter_level_2`|
    # |`1 << 16`|`:verified_bot`|
    # |`1 << 17`|`:early_verified_bot_developer`|
    # |`1 << 18`|`:discord_certified_moderator`|
    class Flag < Discorb::Flag
    end
  end

  # 
  # Represents a client user.
  class ClientUser < Discorb::User
    # 
    # Edit the client user.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new username.
    # @param [Discorb::Image] avatar The new avatar.
    def edit: (?name: String, ?avatar: Discorb::Image) -> untyped
  end

  # 
  # Represents a single asset.
  class Asset < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped target, untyped hash, ?path: untyped) -> void

    # 
    # URL of the asset.
    # 
    # @param [String] image_format The image format.
    # @param [Integer] size The size of the image.
    # 
    # @return [String] URL of the asset.
    def url: (?image_format: String?, ?size: Integer) -> String

    def inspect: () -> untyped

    def endpoint: () -> untyped

    # @return [String] The hash of asset.
    attr_reader hash: String

    # @return [Boolean] Whether the asset is animated.
    attr_reader animated?: bool
  end

  # 
  # Represents RGB color.
  class Color
    # 
    # Create a color from a Integer.
    # 
    # @param [Integer] value A color value.
    def initialize: (Integer value) -> void

    # 
    # Integerize a color.
    # 
    # @return [Integer] A color value.
    def to_i: () -> Integer

    # 
    # Convert a color to a hexadecimal value.
    # 
    # @return [String] A hexadecimal value.
    def to_hex: () -> String

    # 
    # Convert a color to RGB array.
    # 
    # @return [Array(Integer, Integer, Integer)] A RGB array.
    def to_rgb: () -> [Integer, Integer, Integer]

    # 
    # Convert a color to RGB hash.
    # 
    # @return [Hash{:r, :g, :b => Integer}] A RGB hash.
    def to_rgb_hash: () -> { r: Integer, g: Integer, b: Integer}

    # 
    # Converts a color to a `#000000` string.
    # 
    # @return [String] Converted string.
    def to_s: () -> String

    def inspect: () -> untyped

    # 
    # Create a color from a hexadecimal string.
    # 
    # @param [String] hex A hexadecimal string.
    # 
    # @return [Discorb::Color] A color object.
    def self.from_hex: (String hex) -> Discorb::Color

    # 
    # Create a color from a RGB array.
    # 
    # @param [Integer] red A red value.
    # @param [Integer] green A green value.
    # @param [Integer] blue A blue value.
    # 
    # @return [Discorb::Color] A color object.
    def self.from_rgb: (Integer red, Integer green, Integer blue) -> Discorb::Color

    # 
    # Create a color from a Discord's color.
    # Currently these colors are supported:
    #   - teal (0x1abc9c)
    #   - dark_teal (0x11806a)
    #   - green (0x2ecc71)
    #   - dark_green (0x1f8b4c)
    #   - blue (0x3498db)
    #   - dark_blue (0x206694)
    #   - purple (0x9b59b6)
    #   - dark_purple (0x71368a)
    #   - magenta (0xe91e63)
    #   - dark_magenta (0xad1457)
    #   - gold (0xf1c40f)
    #   - dark_gold (0xc27c0e)
    #   - orange (0xe67e22)
    #   - dark_orange (0xa84300)
    #   - red (0xe74c3c)
    #   - dark_red (0x992d22)
    #   - lighter_grey (0x95a5a6)
    #   - lighter_gray (0x95a5a6)
    #   - dark_grey (0x607d8b)
    #   - dark_gray (0x607d8b)
    #   - light_grey (0x979c9f)
    #   - light_gray (0x979c9f)
    #   - darker_grey (0x546e7a)
    #   - darker_gray (0x546e7a)
    #   - og_blurple (0x7289da)
    #   - blurple (0x5865f2)
    #   - greyple (0x99aab5)
    #   - dark_theme (0x36393f)
    #   - fuchsia (0xeb459e)
    # 
    # @param [Symbol] color A Discord color name.
    # 
    # @return [Discorb::Color] A color object.
    def self.[]: (Symbol color) -> Discorb::Color

    # Returns the value of attribute value.
    attr_accessor value: untyped
  end

  # 
  # Represents an embed of discord.
  class Embed
    # 
    # Initialize a new Embed object.
    # 
    # @param [String] title The title of embed.
    # @param [String] description The description of embed.
    # @param [Discorb::Color] color The color of embed.
    # @param [String] url The url of embed.
    # @param [Time] timestamp The timestamp of embed.
    # @param [Discorb::Embed::Author] author The author field of embed.
    # @param [Array<Discorb::Embed::Field>] fields The fields of embed.
    # @param [Discorb::Embed::Footer] footer The footer of embed.
    # @param [Discorb::Embed::Image] image The image of embed.
    # @param [Discorb::Embed::Thumbnail] thumbnail The thumbnail of embed.
    def initialize: (
                      ?String? title,
                      ?String? description,
                      ?color: Discorb::Color?,
                      ?url: String?,
                      ?timestamp: Time?,
                      ?author: Discorb::Embed::Author?,
                      ?fields: ::Array[Discorb::Embed::Field]?,
                      ?footer: Discorb::Embed::Footer?,
                      ?image: Discorb::Embed::Image?,
                      ?thumbnail: Discorb::Embed::Thumbnail?,
                      ?data: untyped
                    ) -> void

    # 
    # Convert embed to hash.
    # 
    # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-structure Offical Discord API Docs
    # @return [Hash] Converted embed.
    def to_hash: () -> ::Hash[untyped, untyped]

    # @return [String, nil] The title of embed.
    attr_accessor title: String?

    # @return [String, nil] The description of embed.
    attr_accessor description: String?

    # @return [String, nil] The url of embed.
    attr_accessor url: String?

    # @return [Time, nil] The timestamp of embed.
    attr_accessor timestamp: Time?

    # @return [Discorb::Color, nil] The color of embed.
    attr_accessor color: Discorb::Color?

    # @return [Discorb::Embed::Author, nil] The author of embed.
    attr_accessor author: Discorb::Embed::Author?

    # @return [Array<Discorb::Embed::Field>] The fields of embed.
    attr_accessor fields: ::Array[Discorb::Embed::Field]

    # @return [Discorb::Embed::Footer, nil] The footer of embed.
    attr_accessor footer: Discorb::Embed::Footer?

    # @return [Symbol] The type of embed.
    attr_reader type: Symbol

    # @return [Discorb::Embed::Image] The image of embed.
    attr_accessor image: Discorb::Embed::Image

    # @return [Discorb::Embed::Thumbnail] The thumbnail of embed.
    attr_accessor thumbnail: Discorb::Embed::Thumbnail

    # 
    # Represents an author of embed.
    class Author
      # 
      # Initialize a new Author object.
      # 
      # @param [String] name The name of author.
      # @param [String] url The url of author.
      # @param [String] icon The icon url of author.
      def initialize: (String name, ?url: String?, ?icon: String?) -> void

      # 
      # Convert author to hash.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-author-structure Offical Discord API Docs
      # @return [Hash] Converted author.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The name of author.
      attr_accessor name: String

      # @return [String, nil] The url of author.
      attr_accessor url: String?

      # @return [String, nil] The icon url of author.
      attr_accessor icon: String?
    end

    # 
    # Represemts a footer of embed.
    class Footer
      # 
      # Initialize a new Footer object.
      # 
      # @param [String] text The text of footer.
      # @param [String] icon The icon url of footer.
      def initialize: (String text, ?icon: String?) -> void

      # 
      # Convert footer to hash.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-footer-structure Offical Discord API Docs
      # @return [Hash] Converted footer.
      def to_hash: () -> ::Hash[untyped, untyped]

      # Returns the value of attribute text.
      attr_accessor text: untyped

      # Returns the value of attribute icon.
      attr_accessor icon: untyped
    end

    # 
    # Represents a field of embed.
    class Field
      # 
      # Initialize a new Field object.
      # 
      # @param [String] name The name of field.
      # @param [String] value The value of field.
      # @param [Boolean] inline Whether the field is inline.
      def initialize: (String name, String value, ?inline: bool) -> void

      # 
      # Convert field to hash.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure Offical Discord API Docs
      # @return [Hash] Converted field.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The name of field.
      attr_accessor name: String

      # @return [String] The value of field.
      attr_accessor value: String

      # @return [Boolean] Whether the field is inline.
      attr_accessor inline: bool
    end

    # 
    # Represents an image of embed.
    class Image
      # 
      # Initialize a new Image object.
      # 
      # @param [String] url URL of image.
      def initialize: (String url) -> void

      # 
      # Convert image to hash for sending.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-image-structure Offical Discord API Docs
      # @return [Hash] Converted image.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The url of image.
      attr_accessor url: String

      # @return [String] The proxy url of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader proxy_url: String?

      # @return [Integer] The height of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader height: Integer?

      # @return [Integer] The width of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader width: Integer?
    end

    # 
    # Represents a thumbnail of embed.
    class Thumbnail
      # 
      # Initialize a new Thumbnail object.
      # 
      # @param [String] url URL of thumbnail.
      def initialize: (String url) -> void

      # 
      # Convert thumbnail to hash for sending.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-thumbnail-structure Offical Discord API Docs
      # @return [Hash] Converted thumbnail.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The url of thumbnail.
      attr_accessor url: String

      # @return [String] The proxy url of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader proxy_url: String?

      # @return [Integer] The height of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader height: Integer?

      # @return [Integer] The width of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader width: Integer?
    end

    # 
    # Represents a video of embed.
    class Video
      # @!visibility private
      def initialize: (untyped data) -> void

      # @return [String] The url of video.
      attr_reader url: String

      # @return [String] The proxy url of video.
      attr_reader proxy_url: String

      # @return [Integer] The height of video.
      attr_reader height: Integer

      # @return [Integer] The width of video.
      attr_reader width: Integer
    end

    # 
    # Represents a provider of embed.
    class Provider
      # @!visibility private
      def initialize: (untyped name, untyped url) -> void

      # @return [String] The name of provider.
      attr_reader name: String

      # @return [String] The url of provider.
      attr_reader url: String
    end
  end

  # Represents a Discord emoji.
  # @abstract
  class Emoji
  end

  # Represents a custom emoji in discord.
  class CustomEmoji < Discorb::Emoji
    # @!visibility private
    def initialize: (untyped client, untyped guild, untyped data) -> void

    # 
    # Format the emoji for sending.
    # 
    # @return [String] the formatted emoji.
    def to_s: () -> String

    # 
    # Format the emoji for URI.
    # 
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    # 
    # Edit the emoji.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new name of the emoji.
    # @param [Array<Discorb::Role>] roles The new roles that can use this emoji.
    # @param [String] reason The reason for editing the emoji.
    # 
    # @return [self] The edited emoji.
    def edit: (?name: String, ?roles: ::Array[Discorb::Role], ?reason: String?) -> self

    # 
    # Delete the emoji.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason for deleting the emoji.
    # 
    # @return [self] The deleted emoji.
    def delete!: (?reason: String?) -> self
    # @return [Discorb::Snowflake] The ID of the emoji.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the emoji.
    attr_reader name: String

    # @return [Array<Discorb::Role>] The roles that can use this emoji.
    attr_reader roles: ::Array[Discorb::Role]

    # @return [Discorb::User] The user that created this emoji.
    attr_reader user: Discorb::User

    # @return [Boolean] Whether the emoji requires colons.
    attr_reader guild: bool

    # @return [Boolean] whether the emoji is managed by integration (ex: Twitch).
    attr_reader managed: bool

    # @return [Boolean] whether the emoji requires colons.
    attr_reader require_colons: bool

    # @return [Boolean] whether the emoji is available.
    attr_reader available: bool

    # @return [Boolean] whether or not this emoji is restricted to certain roles.
    attr_reader roles?: bool
  end

  # 
  # Represents a partial custom emoji in discord.
  class PartialEmoji < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped data) -> void

    # 
    # Format the emoji for URI.
    # 
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    # 
    # Format the emoji for sending.
    # 
    # @return [String] the formatted emoji.
    def to_s: () -> String

    # @return [Discorb::Snowflake] The ID of the emoji.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the emoji.
    attr_reader name: String

    # @return [Boolean] Whether the emoji is deleted.
    attr_reader deleted: bool
  end

  # 
  # Represents a unicode emoji (default emoji) in discord.
  class UnicodeEmoji < Discorb::Emoji
    # @!visibility private
    def initialize: (untyped name) -> void

    # @return [String] The unicode string of the emoji.
    def to_s: () -> String

    # 
    # Format the emoji for URI.
    # 
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    # @return [String] The name of the emoji. (e.g. :grinning:)
    attr_reader name: String

    # @return [String] The unicode value of the emoji. (e.g. U+1F600)
    attr_reader value: String
  end

  # 
  # Error class for Discorb.
  # @abstract
  class DiscorbError < StandardError
    def enumerate_errors: (untyped hash) -> untyped

    def _recr_items: (untyped key, untyped item, untyped res) -> untyped
  end

  # 
  # Represents a HTTP error.
  class HTTPError < Discorb::DiscorbError
    # @!visibility private
    def initialize: (untyped resp, untyped data) -> void

    # @return [String] the HTTP response code.
    attr_reader code: String

    # @return [Net::HTTPResponse] the HTTP response.
    attr_reader response: Net::HTTPResponse
  end

  # 
  # Represents a 400 error.
  class BadRequestError < Discorb::HTTPError
    # @!visibility private
    def initialize: (untyped resp, untyped data) -> void
  end

  # 
  # Represents a 403 error.
  class ForbiddenError < Discorb::HTTPError
  end

  # 
  # Represents a 404 error.
  class NotFoundError < Discorb::HTTPError
  end

  # 
  # Represents a error in client-side.
  class ClientError < Discorb::DiscorbError
  end

  # 
  # Represents a timeout error.
  class TimeoutError < Discorb::DiscorbError
  end

  # 
  # Represents a warning.
  class NotSupportedWarning < Discorb::DiscorbError
    def initialize: (untyped message) -> void
  end

  # 
  # Represents a event.
  # This class shouldn't be instantiated directly.
  # Use {Client#on} instead.
  class Event
    def initialize: (untyped block, _ToS id, untyped discriminator) -> void

    # 
    # Calls the block associated with the event.
    def call: () -> untyped

    # @return [Proc] the block to be called.
    attr_reader block: Proc

    # @return [Symbol] the event id.
    attr_reader id: Symbol

    # @return [Hash] the event discriminator.
    attr_reader discriminator: ::Hash[untyped, untyped]

    # @return [Boolean] whether the event is once or not.
    attr_reader once: bool
  end

  # 
  # Represents a guild in the Discord.
  class Guild < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped client, untyped data, untyped is_create_event) -> void

    # @!visibility private
    def update!: () -> untyped

    def afk_channel: () -> untyped

    def system_channel: () -> untyped

    def rules_channel: () -> untyped

    def public_updates_channel: () -> untyped

    def inspect: () -> untyped

    def me: () -> untyped

    # 
    # Leave the guild.
    # @macro async
    # @macro http
    def leave!: () -> untyped

    # 
    # Fetch emoji list of the guild.
    # @macro async
    # @macro http
    # @note This querys the API every time. We recommend using {#emojis} instead.
    # 
    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::CustomEmoji}] A dictionary of emoji in the guild.
    def fetch_emoji_list: () -> Discorb::Dictionary[Discorb::Snowflake, Discorb::CustomEmoji]

    # 
    # Fetch emoji id of the guild.
    # @macro async
    # @macro http
    # @note This querys the API every time. We recommend using {#emojis} instead.
    # 
    # @param [#to_s] id The emoji id.
    # 
    # @return [Discorb::CustomEmoji] The emoji with the given id.
    def fetch_emoji: (_ToS id) -> Discorb::CustomEmoji

    # 
    # Create a custom emoji.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] name The name of the emoji.
    # @param [Discorb::Image] image The image of the emoji.
    # @param [Array<Discorb::Role>] roles A list of roles to give the emoji.
    # 
    # @return [Discorb::CustomEmoji] The created emoji.
    def create_emoji: (untyped name, Discorb::Image image, ?roles: ::Array[Discorb::Role]) -> Discorb::CustomEmoji

    # 
    # Fetch webhooks of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Webhook>] A list of webhooks in the guild.
    def fetch_webhooks: () -> ::Array[Discorb::Webhook]

    # 
    # Fetch audit log of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Discorb::AuditLog] The audit log of the guild.
    def fetch_audit_log: () -> Discorb::AuditLog

    # 
    # Fetch channels of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Channel>] A list of channels in the guild.
    def fetch_channels: () -> ::Array[Discorb::Channel]

    # 
    # Create a new text channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [String] topic The topic of the channel.
    # @param [Integer] rate_limit_per_user The rate limit per user in the channel.
    # @param [Integer] slowmode Alias for `rate_limit_per_user`.
    # @param [Integer] position The position of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Discorb::TextChannel] The created text channel.
    def create_text_channel: (
                               String name,
                               ?topic: String?,
                               ?rate_limit_per_user: Integer?,
                               ?slowmode: Integer?,
                               ?position: Integer?,
                               ?nsfw: bool?,
                               ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                               ?parent: Discorb::CategoryChannel?,
                               ?reason: String?
                             ) -> Discorb::TextChannel

    # 
    # Create a new voice channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] bitrate The bitrate of the channel.
    # @param [Integer] user_limit The user limit of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Discorb::VoiceChannel] The created voice channel.
    def create_voice_channel: (
                                String name,
                                ?bitrate: Integer,
                                ?user_limit: Integer?,
                                ?position: Integer?,
                                ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                ?parent: Discorb::CategoryChannel?,
                                ?reason: String?
                              ) -> Discorb::VoiceChannel

    # Create a new category channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Discorb::CategoryChannel] The created category channel.
    def create_category_channel: (
                                   String name,
                                   ?position: Integer?,
                                   ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                   ?parent: Discorb::CategoryChannel?,
                                   ?reason: String?
                                 ) -> Discorb::CategoryChannel

    # 
    # Create a new stage channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] bitrate The bitrate of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Discorb::StageChannel] The created stage channel.
    def create_stage_channel: (
                                String name,
                                ?bitrate: Integer,
                                ?position: Integer?,
                                ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                ?parent: Discorb::CategoryChannel?,
                                ?reason: String?
                              ) -> Discorb::StageChannel

    # 
    # Create a new news channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [String] topic The topic of the channel.
    # @param [Integer] rate_limit_per_user The rate limit per user in the channel.
    # @param [Integer] slowmode Alias for `rate_limit_per_user`.
    # @param [Integer] position The position of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Discorb::NewsChannel] The created news channel.
    def create_news_channel: (
                               String name,
                               ?topic: String?,
                               ?rate_limit_per_user: Integer?,
                               ?slowmode: Integer?,
                               ?position: Integer?,
                               ?nsfw: bool?,
                               ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                               ?parent: Discorb::CategoryChannel?,
                               ?reason: String?
                             ) -> Discorb::NewsChannel

    # 
    # Fetch a list of active threads in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::ThreadChannel>] The list of threads.
    def fetch_active_threads: () -> ::Array[Discorb::ThreadChannel]

    # 
    # Fetch a member in the guild.
    # @macro async
    # @macro http
    # @macro members_intent
    # 
    # @param [#to_s] id The ID of the member to fetch.
    # 
    # @return [Discorb::Member] The member.
    # @return [nil] If the member is not found.
    def fetch_member: (_ToS id) -> Discorb::Member

    # 
    # Search for members by name in the guild.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the member to search for.
    # @param [Integer] limit The maximum number of members to return.
    # 
    # @return [Array<Discorb::Member>] The list of members.
    def fetch_members_named: (String name, ?limit: Integer) -> ::Array[Discorb::Member]

    # 
    # Almost the same as {#fetch_members_named}, but returns a single member.
    # @macro async
    # @macro http
    # 
    # @return [Discorb::Member] The member.
    # @return [nil] If the member is not found.
    def fetch_member_named: () -> Discorb::Member

    # 
    # Change nickname of client member.
    # 
    # @param [String] nickname The nickname to set.
    # @param [String] reason The reason for changing the nickname.
    def edit_nickname: (String nickname, ?reason: String?) -> untyped

    # 
    # Kick a member from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Member] member The member to kick.
    # @param [String] reason The reason for kicking the member.
    def kick_member: (Discorb::Member member, ?reason: String?) -> untyped

    # 
    # Fetch a list of bans in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Guild::Ban>] The list of bans.
    def fetch_bans: () -> ::Array[Discorb::Guild::Ban]

    # 
    # Fetch a ban in the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::User] user The user to fetch.
    # 
    # @return [Discorb::Guild::Ban] The ban.
    # @return [nil] If the ban is not found.
    def fetch_ban: (Discorb::User user) -> Discorb::Guild::Ban

    # 
    # Checks the user was banned from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::User] user The user to check.
    # 
    # @return [Boolean] Whether the user was banned.
    def banned?: (Discorb::User user) -> bool

    # 
    # Ban a member from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Member] member The member to ban.
    # @param [Integer] delete_message_days The number of days to delete messages.
    # @param [String] reason The reason for banning the member.
    # 
    # @return [Discorb::Guild::Ban] The ban.
    def ban_member: (Discorb::Member member, ?delete_message_days: Integer, ?reason: String?) -> Discorb::Guild::Ban

    # 
    # Unban a user from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::User] user The user to unban.
    # @param [String] reason The reason for unbanning the user.
    def unban_user: (Discorb::User user, ?reason: String?) -> untyped

    # 
    # Fetch a list of roles in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Role>] The list of roles.
    def fetch_roles: () -> ::Array[Discorb::Role]

    # 
    # Create a role in the guild.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the role.
    # @param [Discorb::Color] color The color of the role.
    # @param [Boolean] hoist Whether the role should be hoisted.
    # @param [Boolean] mentionable Whether the role should be mentionable.
    # @param [String] reason The reason for creating the role.
    # 
    # @return [Discorb::Role] The role.
    def create_role: (
                       ?String? name,
                       ?color: Discorb::Color?,
                       ?hoist: bool?,
                       ?mentionable: bool?,
                       ?reason: String?
                     ) -> Discorb::Role

    # 
    # Fetch how many members will be pruned.
    # @macro async
    # @macro http
    # 
    # @param [Integer] days The number of days to prune.
    # @param [Array<Discorb::Role>] roles The roles that include for pruning.
    # 
    # @return [Integer] The number of members that will be pruned.
    def fetch_prune: (?Integer days, ?roles: ::Array[Discorb::Role]) -> Integer

    # 
    # Prune members from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Integer] days The number of days to prune.
    # @param [Array<Discorb::Role>] roles The roles that include for pruning.
    # @param [String] reason The reason for pruning.
    # 
    # @return [Integer] The number of members that were pruned.
    def prune: (?Integer days, ?roles: ::Array[Discorb::Role], ?reason: String?) -> Integer

    # 
    # Fetch voice regions that are available in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::VoiceRegion>] The available voice regions.
    def fetch_voice_regions: () -> ::Array[Discorb::VoiceRegion]

    # 
    # Fetch invites in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Invite>] The invites.
    def fetch_invites: () -> ::Array[Invite]

    # 
    # Fetch integrations in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Integration>] The integrations.
    def fetch_integrations: () -> ::Array[Discorb::Integration]

    # 
    # Fetch the widget of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Discorb::Guild::Widget] The widget.
    def fetch_widget: () -> Discorb::Guild::Widget

    # 
    # Fetch the vanity URL of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Discorb::Guild::VanityInvite] The vanity URL.
    def fetch_vanity_invite: () -> Discorb::Guild::VanityInvite

    # 
    # Fetch the welcome screen of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Discorb::Guild::WelcomeScreen] The welcome screen.
    def fetch_welcome_screen: () -> Discorb::Guild::WelcomeScreen

    # 
    # Fetch stickers in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Sticker::GuildSticker>] The stickers.
    def fetch_stickers: () -> ::Array[Discorb::Sticker::GuildSticker]

    # 
    # Fetch the sticker by ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id The ID of the sticker.
    # 
    # @return [Discorb::Sticker::GuildSticker] The sticker.
    # @return [nil] If the sticker does not exist.
    def fetch_sticker: (_ToS id) -> Discorb::Sticker::GuildSticker

    # 
    # Fetch templates in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Discorb::GuildTemplate] The templates.
    def fetch_templates: () -> Discorb::GuildTemplate

    # 
    # Almost the same as {#fetch_templates}, but returns a single template.
    # 
    # @return [Discorb::GuildTemplate] The template.
    # @return [nil] If the template does not exist.
    def fetch_template: () -> Discorb::GuildTemplate

    # 
    # Create a new template in the guild.
    # 
    # @param [String] name The name of the template.
    # @param [String] description The description of the template.
    # @param [String] reason The reason for creating the template.
    # 
    # @return [Discorb::GuildTemplate] The template.
    def create_template: (String name, ?String? description, ?reason: String?) -> Discorb::GuildTemplate

    # 
    # Returns a banner url from the guild's ID.
    # 
    # @param [#to_s] guild_id The ID of the guild.
    # @param [:shield, :banner1, :banner2, :banner3, :banner4] style The style of the banner.
    # 
    # @return [String] The url of the banner.
    def self.banner: (_ToS guild_id, ?style: Symbol) -> String
    # @return [Discorb::Snowflake] ID of the guild.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the guild.
    attr_reader name: String

    # @return [Discorb::Asset] The splash of the guild.
    attr_reader splash: Discorb::Asset

    # @return [Discorb::Asset] The discovery splash of the guild.
    attr_reader discovery_splash: Discorb::Asset

    # @return [Discorb::Snowflake] ID of the guild owner.
    attr_reader owner_id: Discorb::Snowflake

    # @return [Discorb::Permission] The bot's permission in the guild.
    attr_reader permissions: Discorb::Permission

    # @return [Integer] The AFK timeout of the guild.
    attr_reader afk_timeout: Integer

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Role}] A dictionary of roles in the guild.
    attr_reader roles: Discorb::Dictionary[Discorb::Snowflake, Discorb::Role]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::CustomEmoji}] A dictionary of custom emojis in the guild.
    attr_reader emojis: Discorb::Dictionary[Discorb::Snowflake, Discorb::CustomEmoji]

    # @return [Array<Symbol>] features that are enabled in the guild.
    # @see https://discord.com/developers/docs/resources/guild#guild-object-guild-features Official Discord API docs
    attr_reader features: ::Array[Symbol]

    # @return [:none, :elevated] The MFA level of the guild.
    attr_reader mfa_level: Symbol

    # @return [Discorb::Guild::SystemChannelFlag] The flag for the system channel.
    attr_reader system_channel_flags: Discorb::Guild::SystemChannelFlag

    # @return [Time] Time that representing when bot has joined the guild.
    attr_reader joined_at: Time

    # @return [Boolean] Whether the guild is unavailable.
    attr_reader unavailable: bool

    # @return [Integer] The amount of members in the guild.
    attr_reader member_count: Integer

    # @return [Discorb::Asset] The icon of the guild.
    attr_reader icon: Discorb::Asset

    # @return [Discorb::Dictionary{Discorb::User => Discorb::VoiceState}] A dictionary of voice states in the guild.
    attr_reader voice_states: Discorb::Dictionary[Discorb::User, Discorb::VoiceState]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Member}] A dictionary of members in the guild.
    # @macro members_intent
    attr_reader members: Discorb::Dictionary[Discorb::Snowflake, Discorb::Member]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::GuildChannel}] A dictionary of channels in the guild.
    attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::GuildChannel]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::ThreadChannel}] A dictionary of threads in the guild.
    attr_reader threads: Discorb::Dictionary[Discorb::Snowflake, Discorb::ThreadChannel]

    # @return [Discorb::Dictionary{Discorb::User => Discorb::Presence}] A dictionary of presence in the guild.
    attr_reader presences: Discorb::Dictionary[Discorb::User, Discorb::Presence]

    # @return [Integer] Number of online members in the guild.
    attr_reader max_presences: Integer

    # @return [String] The vanity invite URL for the guild.
    # @return [nil] If the guild does not have a vanity invite URL.
    attr_reader vanity_url_code: String?

    # @return [String] The description of the guild.
    attr_reader description: String

    # @return [Discorb::Asset] The banner of the guild.
    # @return [nil] If the guild does not have a banner.
    attr_reader banner: Discorb::Asset?

    # @return [Integer] The premium tier (Boost Level) of the guild.
    attr_reader premium_tier: Integer

    # @return [Integer] The amount of premium subscriptions (Server Boosts) the guild has.
    attr_reader premium_subscription_count: Integer

    # @return [Symbol] The preffered language of the guild.
    # @note This modifies the language code, `-` will be replaced with `_`.
    attr_reader preferred_locale: Symbol

    # @return [Integer] The maximum amount of users in a video channel.
    attr_reader max_video_channel_users: Integer

    # @return [Integer] The approxmate amount of members in the guild.
    attr_reader approximate_member_count: Integer

    # @return [Integer] The approxmate amount of non-offline members in the guild.
    attr_reader approximate_presence_count: Integer

    # @return [Discorb::WelcomeScreen] The welcome screen of the guild.
    attr_reader welcome_screen: Discorb::WelcomeScreen

    # @return [:default, :explicit, :safe, :age_restricted] The nsfw level of the guild.
    attr_reader nsfw_level: Symbol

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::StageInstance}] A dictionary of stage instances in the guild.
    attr_reader stage_instances: Discorb::Dictionary[Discorb::Snowflake, Discorb::StageInstance]

    # @return [:none, :low, :medium, :high, :very_high] The verification level of the guild.
    attr_reader verification_level: Symbol

    # @return [:all_messages, :only_mentions] The default message notification level of the guild.
    attr_reader default_message_notifications: Symbol

    # @return [:disabled_in_text, :members_without_roles, :all_members] The explict content filter level of the guild.
    attr_reader explicit_content_filter: Symbol

    # @return [Boolean] Whether the client is the owner of the guild.
    attr_reader owner: bool

    # @return [Boolean] Whether the guild is large.
    attr_reader large: bool

    # @return [Boolean] Whether the guild enabled the widget.
    attr_reader widget_enabled: bool

    # @return [Boolean] Whether the guild is available.
    attr_reader available: bool

    # 
    # Represents a vanity invite.
    class VanityInvite < Discorb::DiscordModel
      # @!visibility private
      def initialize: (untyped client, untyped guild, untyped data) -> void

      # @return [String] The vanity invite code.
      attr_reader code: String

      # @return [Integer] The number of uses.
      attr_reader uses: Integer

      # @return [String] The vanity URL.
      attr_reader url: String
    end

    # 
    # Represents a guild widget.
    class Widget < Discorb::DiscordModel
      # @!visibility private
      def initialize: (untyped client, _ToS guild_id, untyped data) -> void

      # 
      # Edit the widget.
      # @macro async
      # @macro http
      # @macro edit
      # 
      # @param [Boolean] enabled Whether the widget is enabled.
      # @param [Discorb::GuildChannel] channel The channel.
      # @param [String] reason The reason for editing the widget.
      def edit: (?enabled: bool?, ?channel: Discorb::GuildChannel?, ?reason: String?) -> untyped

      # 
      # Return iframe HTML of the widget.
      # 
      # @param ["dark", "light"] theme The theme of the widget.
      # @param [Integer] width The width of the widget.
      # @param [Integer] height The height of the widget.
      # 
      # @return [String] The iframe HTML.
      def iframe: (?theme: ("dark" | "light"), ?width: Integer, ?height: Integer) -> String

      # @return [Discorb::Snowflake] The guild ID.
      attr_reader guild_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The channel ID.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Boolean] Whether the widget is enabled.
      attr_reader enabled: bool

      # @macro client_cache
      # @return [Discorb::Channel] The channel.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild.
      attr_reader guild: Discorb::Guild?

      # @return [String] The JSON URL.
      attr_reader json_url: String
    end

    # 
    # Represents a ban.
    class Ban < Discorb::DiscordModel
      # @!visibility private
      def initialize: (untyped client, untyped guild, untyped data) -> void

      # @return [Discorb::User] The user.
      attr_reader user: Discorb::User

      # @return [String] The reason for the ban.
      attr_reader reason: String
    end
  end

  # 
  # Represents a system channel flag.
  # ## Flag fields
  # |Field|Value|
  # |-|-|
  # |`1 << 0`|`:member_join`|
  # |`1 << 1`|`:server_boost`|
  # |`1 << 2`|`:setup_tips`|
  class SystemChannelFlag < Discorb::Flag
  end

  # 
  # Represents a welcome screen.
  class WelcomeScreen < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped client, untyped guild, untyped data) -> void

    # @return [String] The description of the welcome screen.
    attr_reader description: String

    # @return [Array<Discorb::WelcomeScreen::Channel>] The channels to display the welcome screen.
    attr_reader channels: ::Array[Discorb::WelcomeScreen::Channel]

    # @return [Discorb::Guild] The guild the welcome screen belongs to.
    attr_reader guild: Discorb::Guild

    # 
    # Represents a channel to display the welcome screen.
    class Channel < Discorb::DiscordModel
      # 
      # Initialize a new welcome screen channel.
      # 
      # @param [Discorb::TextChannel] channel The channel to display the welcome screen.
      # @param [String] description The channel's name.
      # @param [Discorb::Emoji] emoji The emoji to display.
      def initialize: (Discorb::TextChannel channel, String description, Discorb::Emoji emoji) -> void

      # 
      # Converts the channel to a hash.
      # 
      # @return [Hash] The hash.
      # @see https://discord.com/developers/docs/resources/guild#welcome-screen-object
      def to_hash: () -> ::Hash[untyped, untyped]

      # 
      # Edits the welcome screen.
      # @macro async
      # @macro http
      # @macro edit
      # 
      # @param [Boolean] enabled Whether the welcome screen is enabled.
      # @param [Array<Discorb::WelcomeScreen::Channel>] channels The channels to display the welcome screen.
      # @param [String] description The description of the welcome screen.
      # @param [String] reason The reason for editing the welcome screen.
      def edit: (
                  ?enabled: bool,
                  ?channels: ::Array[Discorb::WelcomeScreen::Channel],
                  ?description: String,
                  ?reason: String?
                ) -> untyped

      # @return [String] The channel's name.
      attr_reader description: String

      # @return [Discorb::Emoji] The emoji to display.
      attr_reader emoji: Discorb::Emoji

      # @macro client_cache
      # @return [Discorb::Channel] The channel to display the welcome screen.
      attr_reader channel: Discorb::Channel?
    end
  end

  # 
  # Represents an image.
  class Image
    # 
    # Initializes a new Image.
    # 
    # @param [#read] source The source of the image.
    # @param [String] type The MIME type of the image.
    # @overload
    #   @param [String] source The file path of the source.
    #   @param [String] type The MIME type of the image.
    def initialize: (untyped source, ?String? _type) -> void

    # 
    # Formats the image as a Discord style.
    # 
    # @return [String] The image as a Discord style.
    def to_s: () -> String
  end

  # @!visibility private
  module Utils
    def try: (untyped object, untyped message) -> untyped

    def self.try: (untyped object, untyped message) -> untyped
  end

  # 
  # Class for connecting to the Discord server.
  class Client
    include Discorb::GatewayHandler

    # 
    # Initializes a new client.
    # 
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions that the client is using.
    # @param [Discorb::Intents] intents The intents that the client is currently using.
    # @param [Integer] message_caches The number of messages to cache.
    # @param [#puts] log The IO object to use for logging.
    # @param [Boolean] colorize_log Whether to colorize the log.
    # @param [:debug, :info, :warn, :error, :critical] log_level The log level.
    # @param [Boolean] wait_until_ready Whether to delay event dispatch until ready.
    def initialize: (
                      ?allowed_mentions: Discorb::AllowedMentions?,
                      ?intents: Discorb::Intents?,
                      ?message_caches: Integer,
                      ?log: untyped,
                      ?colorize_log: bool,
                      ?log_level: Symbol,
                      ?wait_until_ready: bool
                    ) -> void

    # 
    # Registers an event handler.
    # @see file:docs/Events.md
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Symbol] id Custom ID of the event.
    # @param [Hash] discriminator The discriminator of the event.
    # @param [Proc] block The block to execute when the event is triggered.
    # 
    # @return [Discorb::Event] The event.
    def on: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] discriminator) -> Discorb::Event

    # 
    # Almost same as {#on}, but only triggers the event once.
    # 
    # @param (see #on)
    # 
    # @return [Discorb::Event] The event.
    def once: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] discriminator) -> Discorb::Event

    # 
    # Remove event by ID.
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Symbol] id The ID of the event.
    def remove_event: (Symbol event_name, Symbol id) -> untyped

    # 
    # Dispatch an event.
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Object] args The arguments to pass to the event.
    def dispatch: (Symbol event_name, *Object args) -> untyped

    # 
    # Starts the client.
    # 
    # @param [String] token The token to use.
    def run: (String token) -> untyped

    # 
    # Fetch user from ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id <description>
    # 
    # @return [Discorb::User] The user.
    # 
    # @raise [Discorb::NotFoundError] If the user doesn't exist.
    def fetch_user: (_ToS id) -> Discorb::User

    # 
    # Fetch channel from ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id The ID of the channel.
    # 
    # @return [Discorb::Channel] The channel.
    # 
    # @raise [Discorb::NotFoundError] If the channel doesn't exist.
    def fetch_channel: (_ToS id) -> Discorb::Channel

    # 
    # Fetch guild from ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id <description>
    # 
    # @return [Discorb::Guild] The guild.
    # 
    # @raise [Discorb::NotFoundError] If the guild doesn't exist.
    def fetch_guild: (_ToS id) -> Discorb::Guild

    # 
    # Fetch invite from code.
    # @macro async
    # @macro http
    # 
    # @param [String] code The code of the invite.
    # @param [Boolean] with_count Whether to include the count of the invite.
    # @param [Boolean] with_expiration Whether to include the expiration of the invite.
    # 
    # @return [Discorb::Invite] The invite.
    def fetch_invite: (String code, ?with_count: bool, ?with_expiration: bool) -> Discorb::Invite

    # 
    # Fetch webhook from ID.
    # If application was cached, it will be used.
    # @macro async
    # @macro http
    # 
    # @param [Boolean] force Whether to force the fetch.
    # 
    # @return [Discorb::Application] The application.
    def fetch_application: (?force: bool) -> Discorb::Application

    # 
    # Fetch nitro sticker pack from ID.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Sticker::Pack>] The packs.
    def fetch_nitro_sticker_packs: () -> ::Array[Discorb::Sticker::Pack]

    # 
    # Update presence of the client.
    # 
    # @param [Discorb::Activity] activity The activity to update.
    # @param [:online, :idle, :dnd, :invisible] status The status to update.
    def update_presence: (?Discorb::Activity? activity, ?status: Symbol?) -> untyped

    # 
    # Method to wait for a event.
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Integer] timeout The timeout in seconds.
    # @param [Proc] check The check to use.
    # 
    # @return [Object] The result of the event.
    # 
    # @raise [Discorb::TimeoutError] If the event didn't occur in time.
    def event_lock: (untyped event, ?Integer? timeout) -> Object

    def inspect: () -> untyped

    # 
    # Load the extension.
    # 
    # @param [Module] mod The extension to load.
    def extend: (Module mod) -> untyped

    def connect_gateway: (untyped first) -> untyped

    def send_gateway: (untyped opcode, **untyped value) -> untyped

    def handle_gateway: (untyped payload) -> untyped

    def handle_heartbeat: (untyped interval) -> untyped

    def handle_event: (untyped event_name, untyped data) -> untyped

    # @return [Discorb::Intents] The intents that the client is currently using.
    attr_accessor intents: Discorb::Intents

    # @return [Discorb::Application] The application that the client is using.
    # @return [nil] If never fetched application by {#fetch_application}.
    attr_reader application: Discorb::Application?

    # @return [Discorb::Internet] The internet client.
    attr_reader internet: Discorb::Internet

    # @return [Integer] The heartbeat interval.
    attr_reader heartbeat_interval: Integer

    # @return [Integer] The API version of the Discord gateway.
    # @return [nil] If not connected to the gateway.
    attr_reader api_version: Integer?

    # @return [String] The token of the client.
    attr_reader token: String

    # @return [Discorb::AllowedMentions] The allowed mentions that the client is using.
    attr_reader allowed_mentions: Discorb::AllowedMentions

    # @return [Discorb::ClientUser] The client user.
    attr_reader user: Discorb::ClientUser

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Guild}] A dictionary of guilds.
    attr_reader guilds: Discorb::Dictionary[Discorb::Snowflake, Discorb::Guild]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::User}] A dictionary of users.
    attr_reader users: Discorb::Dictionary[Discorb::Snowflake, Discorb::User]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Channel}] A dictionary of channels.
    attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::Channel]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Emoji}] A dictionary of emojis.
    attr_reader emojis: Discorb::Dictionary[Discorb::Snowflake, Discorb::Emoji]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Message}] A dictionary of messages.
    attr_reader messages: Discorb::Dictionary[Discorb::Snowflake, Discorb::Message]

    # @return [Discorb::Logger] The logger.
    attr_reader log: Discorb::Logger
  end

  # 
  # @abstract
  # Represents Discord model.
  class DiscordModel
    def eql?: (untyped other) -> bool

    def ==: (untyped other) -> untyped

    # @!visibility private
    def inspect: () -> untyped

    def hash: () -> untyped
  end

  # 
  # Represents Snowflake of Discord.
  # 
  # @see https://discord.com/developers/docs/reference#snowflakes Official Discord API docs
  class Snowflake < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped value) -> void

    # 
    # Stringify snowflake.
    # 
    # @return [String] Stringified snowflake.
    def to_s: () -> String

    # 
    # Integerize snowflake.
    # 
    # @return [Integer] Integerized snowflake.
    def to_i: () -> Integer

    # 
    # Compares snowflake with other object.
    # 
    # @param [#to_s] other Object to compare with.
    # 
    # @return [Boolean] True if snowflake is equal to other object.
    def ==: (untyped other) -> bool

    # 
    # Alias of {#==}.
    def eql?: (untyped other) -> bool

    # Return hash of snowflake.
    def hash: () -> untyped

    # Timestamp of snowflake.
    # 
    # @return [Time] Timestamp of snowflake.
    attr_reader timestamp: Time

    # Worker ID of snowflake.
    # 
    # @return [Integer] Worker ID of snowflake.
    attr_reader worker_id: Integer

    # Process ID of snowflake.
    # 
    # @return [Integer] Process ID of snowflake.
    attr_reader process_id: Integer

    # Increment of snowflake.
    # 
    # @return [Integer] Increment of snowflake.
    attr_reader increment: Integer
  end

  # 
  # Represents invite of discord.
  class Invite < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped client, untyped data, untyped gateway) -> void

    def channel: () -> untyped

    def guild: () -> untyped

    def url: () -> untyped

    def remain_uses: () -> untyped

    def temporary?: () -> bool

    # Delete the invite.
    # @macro async
    # @macro http
    def delete!: (?reason: untyped) -> untyped
    # @return [String] The code of invite.
    attr_reader code: String

    # @return [:voice, :stream, :guild] The type of invite.
    attr_reader target_type: Symbol

    # @return [User] The user of invite.
    attr_reader target_user: User

    # @return [Integer] The approximate number of online users of invite.
    attr_reader approximate_presence_count: Integer

    # @return [Integer] The approximate number of members of invite.
    attr_reader approximate_member_count: Integer

    # @return [Time] The time when invite expires.
    # @return [nil] The invite never expires.
    # @macro [new] nometa
    #   @return [nil] The invite doesn't have metadata.
    attr_reader expires_at: Time?

    # @return [Integer] The number of uses of invite.
    # @macro nometa
    attr_reader uses: Integer?

    # @return [Integer] The maximum number of uses of invite.
    # @macro nometa
    attr_reader max_uses: Integer?

    # @return [Integer] Duration of invite in seconds.
    # @macro nometa
    attr_reader max_age: Integer?

    # @return [Time] The time when invite was created.
    # @macro nometa
    attr_reader created_at: Time?
  end

  # 
  # Represents a member of a guild.
  class Member < Discorb::User
    # @!visibility private
    def initialize: (
                      untyped client,
                      _ToS guild_id,
                      untyped user_data,
                      untyped member_data
                    ) -> void

    # 
    # Format the member to `@name` style.
    # 
    # @return [String] The formatted member.
    def to_s: () -> String

    def inspect: () -> untyped

    # 
    # Add a role to the member.
    # @macro http
    # @macro async
    # 
    # @param [Discorb::Role] role The role to add.
    # @param [String] reason The reason for the action.
    def add_role: (Discorb::Role role, ?reason: String?) -> untyped

    # 
    # Remove a role to the member.
    # @macro http
    # @macro async
    # 
    # @param [Discorb::Role] role The role to add.
    # @param [String] reason The reason for the action.
    def remove_role: (Discorb::Role role, ?reason: String?) -> untyped

    # 
    # Edit the member.
    # @macro http
    # @macro async
    # @macro edit
    # 
    # @param [String] nick The nickname of the member.
    # @param [Discorb::Role] role The roles of the member.
    # @param [Boolean] mute Whether the member is muted.
    # @param [Boolean] deaf Whether the member is deafened.
    # @param [Discorb::StageChannel] channel The channel the member is moved to.
    # @param [String] reason The reason for the action.
    def edit: (
                ?nick: String,
                ?role: Discorb::Role,
                ?mute: bool,
                ?deaf: bool,
                ?channel: Discorb::StageChannel,
                ?reason: String?
              ) -> untyped

    # 
    # Kick the member.
    # 
    # @param [String] reason The reason for the action.
    def kick: (?reason: String?) -> untyped

    # 
    # Ban the member.
    # 
    # @param [Integer] delete_message_days The number of days to delete messages.
    # @param [String] reason The reason for the action.
    # 
    # @return [Discorb::Guild::Ban] The ban.
    def ban: (?delete_message_days: Integer, ?reason: String?) -> Discorb::Guild::Ban
    # @return [Time] The time the member boosted the guild.
    attr_reader premium_since: Time

    # @return [String] The nickname of the member.
    # @return [nil] If the member has no nickname.
    attr_reader nick: String?

    # @return [Time] The time the member joined the guild.
    attr_reader joined_at: Time

    # @return [Discorb::Asset] The custom avatar of the member.
    # @return [nil] If the member has no custom avatar.
    attr_reader custom_avatar: Discorb::Asset?

    # @return [Discorb::Asset] The display avatar of the member.
    attr_reader display_avatar: Discorb::Asset

    # @return [Boolean] Whether the member is muted.
    attr_reader mute: bool

    # @return [Boolean] Whether the member is deafened.
    attr_reader deaf: bool

    # @return [Boolean] Whether the member is pending (Not passed member screening).
    attr_reader pending: bool

    # @return [String] The display name of the member.
    attr_reader name: String

    # @return [String] The mention of the member.
    attr_reader mention: String

    # @return [Discorb::VoiceState] The voice state of the member.
    attr_reader voice_state: Discorb::VoiceState

    # @macro client_cache
    # @return [Array<Discorb::Role>] The roles of the member.
    attr_reader roles: ::Array[Discorb::Role]?

    # @macro client_cache
    # @return [Discorb::Guild] The guild the member is in.
    attr_reader guild: Discorb::Guild?

    # @macro client_cache
    # @return [Discorb::Role] The hoisted role of the member.
    # @return [nil] If the member has no hoisted role.
    attr_reader hoisted_role: Discorb::Role?

    # @return [Boolean] Whether the member has a hoisted role.
    attr_reader hoisted?: bool

    # @return [Discorb::Permission] The permissions of the member.
    attr_reader permissions: Discorb::Permission

    # @macro client_cache
    # @return [Discorb::Presence] The presence of the member.
    attr_reader presence: Discorb::Presence?

    # @macro client_cache
    # @return [Discorb::Activity] The activity of the member. It's from the {#presence}.
    attr_reader activity: Discorb::Activity?

    # @macro client_cache
    # @return [Array<Discorb::Activity>] The activities of the member. It's from the {#presence}.
    attr_reader activities: ::Array[Discorb::Activity]?

    # @macro client_cache
    # @return [Symbol] The status of the member. It's from the {#presence}.
    attr_reader status: Symbol?
  end

  # 
  # Represents a channel of Discord.
  # @abstract
  class Channel < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped client, untyped data, ?no_cache: untyped) -> void

    # 
    # Checks if the channel is other channel.
    # 
    # @param [Discorb::Channel] other The channel to check.
    # 
    # @return [Boolean] True if the channel is other channel.
    def ==: (Discorb::Channel other) -> bool

    def inspect: () -> untyped

    # @!visibility private
    def self.descendants: () -> untyped

    # @!visibility private
    def self.make_channel: (untyped client, untyped data, ?no_cache: untyped) -> untyped

    def type: () -> untyped

    # @!visibility private
    def base_url: () -> untyped
    # @return [Discorb::Snowflake] The ID of the channel.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the channel.
    attr_reader name: String
  end

  # 
  # Represents a channel in guild.
  # @abstract
  class GuildChannel < Discorb::Channel
    include Comparable

    # 
    # Compares position of two channels.
    # 
    # @param [Discorb::GuildChannel] other The channel to compare.
    # 
    # @return [-1, 1] -1 if the channel is at lower than the other, 1 if the channel is at highter than the other.
    def <=>: (Discorb::GuildChannel other) -> Integer

    # 
    # Checks if the channel is same as another.
    # 
    # @param [Discorb::GuildChannel] other The channel to check.
    # 
    # @return [Boolean] `true` if the channel is same as another.
    def ==: (Discorb::GuildChannel other) -> bool

    # 
    # Stringifies the channel.
    # 
    # @return [String] The name of the channel with `#`.
    def to_s: () -> String

    def mention: () -> untyped

    def parent: () -> untyped

    def guild: () -> untyped

    def inspect: () -> untyped

    # 
    # Deletes the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason of deleting the channel.
    # 
    # @return [self] The deleted channel.
    def delete!: (?reason: String?) -> self

    # 
    # Moves the channel to another position.
    # @macro async
    # @macro http
    # 
    # @param [Integer] position The position to move the channel.
    # @param [Boolean] lock_permissions Whether to lock the permissions of the channel.
    # @param [Discorb::CategoryChannel] parent The parent of channel.
    # @param [String] reason The reason of moving the channel.
    # 
    # @return [self] The moved channel.
    def move: (
                Integer position,
                ?lock_permissions: bool,
                ?parent: Discorb::CategoryChannel,
                ?reason: String?
              ) -> self
    # @return [Integer] The position of the channel as integer.
    attr_reader position: Integer

    # @return [Hash{Discorb::Role, Discorb::Member => PermissionOverwrite}] The permission overwrites of the channel.
    attr_reader permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]
  end

  # 
  # Represents a text channel.
  class TextChannel < Discorb::GuildChannel
    include Discorb::Messageable

    # @!visibility private
    def initialize: (untyped client, untyped data, ?no_cache: untyped) -> void

    # 
    # Edits the channel.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Discorb::CategoryChannel, nil] category The parent of channel. Specify `nil` to remove the parent.
    # @param [Discorb::CategoryChannel, nil] parent Alias of `category`.
    # @param [String] topic The topic of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Boolean] announce Whether the channel is announce channel.
    # @param [Integer] rate_limit_per_user The rate limit per user (Slowmode) in the channel.
    # @param [Integer] slowmode Alias of `rate_limit_per_user`.
    # @param [Integer] default_auto_archive_duration The default auto archive duration of the channel.
    # @param [Integer] archive_in Alias of `default_auto_archive_duration`.
    # @param [String] reason The reason of editing the channel.
    # 
    # @return [self] The edited channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?category: Discorb::CategoryChannel?,
                ?parent: Discorb::CategoryChannel?,
                ?topic: String,
                ?nsfw: bool,
                ?announce: bool,
                ?rate_limit_per_user: Integer,
                ?slowmode: Integer,
                ?default_auto_archive_duration: Integer,
                ?archive_in: Integer,
                ?reason: String?
              ) -> self

    # 
    # Create webhook in the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the webhook.
    # @param [Discorb::Image] avatar The avatar of the webhook.
    # 
    # @return [Discorb::Webhook::IncomingWebhook] The created webhook.
    def create_webhook: (String name, ?avatar: Discorb::Image?) -> Discorb::Webhook::IncomingWebhook

    # 
    # Fetch webhooks in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Webhook>] The webhooks in the channel.
    def fetch_webhooks: () -> ::Array[Discorb::Webhook]

    # 
    # Bulk delete messages in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] messages The messages to delete.
    # @param [Boolean] force Whether to ignore the validation for message (14 days limit).
    def delete_messages!: (*Discorb::Message messages, ?force: bool) -> untyped

    # 
    # Set the channel's permission overwrite.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Role, Discorb::Member] target The target of the overwrite.
    # @param [String] reason The reason of setting the overwrite.
    # @param [Symbol => Boolean] perms The permission overwrites to replace.
    def set_permissions: ((Discorb::Role | Discorb::Member) target, ?reason: String?, **SORD_ERROR_SymbolBoolean perms) -> untyped

    # 
    # Delete the channel's permission overwrite.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Role, Discorb::Member] target The target of the overwrite.
    # @param [String] reason The reason of deleting the overwrite.
    def delete_permissions: ((Discorb::Role | Discorb::Member) target, ?reason: String?) -> untyped

    # 
    # Fetch the channel's invites.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Invite>] The invites in the channel.
    def fetch_invites: () -> ::Array[Discorb::Invite]

    # 
    # Create an invite in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Integer] max_age The max age of the invite.
    # @param [Integer] max_uses The max uses of the invite.
    # @param [Boolean] temporary Whether the invite is temporary.
    # @param [Boolean] unique Whether the invite is unique.
    #   @note if it's `false` it may return existing invite.
    # @param [String] reason The reason of creating the invite.
    # 
    # @return [Invite] The created invite.
    def create_invite: (
                         ?max_age: Integer?,
                         ?max_uses: Integer?,
                         ?temporary: bool,
                         ?unique: bool,
                         ?reason: String?
                       ) -> Invite

    # 
    # Follow the existing announcement channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::NewsChannel] target The channel to follow.
    # @param [String] reason The reason of following the channel.
    def follow_from: (Discorb::NewsChannel target, ?reason: String?) -> untyped

    # 
    # Follow the existing announcement channel from self.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::TextChannel] target The channel to follow to.
    # @param [String] reason The reason of following the channel.
    def follow_to: (Discorb::TextChannel target, ?reason: String?) -> untyped

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::Message>] The pinned messages in the channel.
    def fetch_pins: () -> ::Array[Discorb::Message]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Start thread in the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the thread.
    # @param [Discorb::Message] message The message to start the thread.
    # @param [Integer] auto_archive_duration The duration of auto-archiving.
    # @param [Boolean] public Whether the thread is public.
    # @param [String] reason The reason of starting the thread.
    # 
    # @return [Discorb::ThreadChannel] The started thread.
    def start_thread: (
                        String name,
                        ?message: Discorb::Message?,
                        ?auto_archive_duration: Integer,
                        ?public: bool,
                        ?reason: String?
                      ) -> Discorb::ThreadChannel

    # 
    # Fetch archived threads in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::ThreadChannel>] The archived threads in the channel.
    def fetch_archived_public_threads: () -> ::Array[Discorb::ThreadChannel]

    # 
    # Fetch archived private threads in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Array<Discorb::ThreadChannel>] The archived private threads in the channel.
    def fetch_archived_private_threads: () -> ::Array[Discorb::ThreadChannel]

    # 
    # Fetch joined archived private threads in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The limit of threads to fetch.
    # @param [Time] before <description>
    # 
    # @return [Array<Discorb::ThreadChannel>] The joined archived private threads in the channel.
    def fetch_joined_archived_private_threads: (?limit: Integer?, ?before: Time?) -> ::Array[Discorb::ThreadChannel]
    # 
    # Post a message to the channel.
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Components>, Array<Array<Discorb::Components>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Discorb::Message] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Components] | ::Array[::Array[Discorb::Components]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Discorb::Message

    # 
    # Fetch a message from ID.
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Discorb::Message] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Discorb::Message

    # 
    # Fetch a message history.
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Array<Discorb::Message>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> ::Array[Discorb::Message]

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [String] The topic of the channel.
    attr_reader topic: String

    # @return [Boolean] Whether the channel is nsfw.
    attr_reader nsfw: bool

    # @return [Discorb::Snowflake] The id of the last message.
    attr_reader last_message_id: Discorb::Snowflake

    # @return [Integer] The rate limit per user (Slowmode) in the channel.
    attr_reader rate_limit_per_user: Integer

    # @return [Time] The time when the last pinned message was pinned.
    attr_reader last_pin_timestamp: Time

    # @return [Array<Discorb::ThreadChannel>] The threads in the channel.
    attr_reader threads: ::Array[Discorb::ThreadChannel]
  end

  # 
  # Represents a news channel (announcement channel).
  class NewsChannel < Discorb::TextChannel
    include Discorb::Messageable

    # 
    # Post a message to the channel.
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Components>, Array<Array<Discorb::Components>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Discorb::Message] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Components] | ::Array[::Array[Discorb::Components]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Discorb::Message

    # 
    # Fetch a message from ID.
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Discorb::Message] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Discorb::Message

    # 
    # Fetch a message history.
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Array<Discorb::Message>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> ::Array[Discorb::Message]

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  # 
  # Represents a voice channel.
  # @todo Implement connecting to voice channel.
  class VoiceChannel < Discorb::GuildChannel
    # 
    # Edit the voice channel.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the voice channel.
    # @param [Integer] position The position of the voice channel.
    # @param [Integer] bitrate The bitrate of the voice channel.
    # @param [Integer] user_limit The user limit of the voice channel.
    # @param [Symbol] rtc_region The region of the voice channel.
    # @param [String] reason The reason of editing the voice channel.
    # 
    # @return [self] The edited voice channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?bitrate: Integer,
                ?user_limit: Integer,
                ?rtc_region: Symbol,
                ?reason: String?
              ) -> self
    # @return [Integer] The bitrate of the voice channel.
    attr_reader bitrate: Integer

    # @return [Integer] The user limit of the voice channel.
    # @return [nil] If the user limit is not set.
    attr_reader user_limit: Integer?
  end

  # 
  # Represents a stage channel.
  class StageChannel < Discorb::GuildChannel
    # @!visibility private
    def initialize: () -> void

    def stage_instance: () -> untyped

    # 
    # Edit the stage channel.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the stage channel.
    # @param [Integer] position The position of the stage channel.
    # @param [Integer] bitrate The bitrate of the stage channel.
    # @param [Symbol] rtc_region The region of the stage channel.
    # @param [String] reason The reason of editing the stage channel.
    # 
    # @return [self] The edited stage channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?bitrate: Integer,
                ?rtc_region: Symbol,
                ?reason: String?
              ) -> self

    # 
    # Start a stage instance.
    # @macro async
    # @macro http
    # 
    # @param [String] topic The topic of the stage instance.
    # @param [Boolean] public Whether the stage instance is public or not.
    # @param [String] reason The reason of starting the stage instance.
    # 
    # @return [Discorb::StageInstance] The started stage instance.
    def start: (String topic, ?public: bool, ?reason: String?) -> Discorb::StageInstance

    # 
    # Fetch a current stage instance.
    # @macro async
    # @macro http
    # 
    # @return [StageInstance] The current stage instance.
    # @return [nil] If there is no current stage instance.
    def fetch_stage_instance: () -> StageInstance
    # @return [Integer] The bitrate of the voice channel.
    attr_reader bitrate: Integer

    # @return [Integer] The user limit of the voice channel.
    attr_reader user_limit: Integer

    # Returns the value of attribute stage_instances.
    attr_reader stage_instances: untyped
  end

  # 
  # Represents a thread.
  # @abstract
  class ThreadChannel < Discorb::Channel
    include Discorb::Messageable

    # @!visibility private
    def initialize: (untyped client, untyped data, ?no_cache: untyped) -> void

    # 
    # Edit the thread.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the thread.
    # @param [Boolean] archived Whether the thread is archived or not.
    # @param [Integer] auto_archive_duration The auto archive duration in seconds.
    # @param [Integer] archive_in Alias of `auto_archive_duration`.
    # @param [Boolean] locked Whether the thread is locked or not.
    # @param [String] reason The reason of editing the thread.
    # 
    # @return [self] The edited thread.
    # 
    # @see #archive
    # @see #lock
    # @see #unarchive
    # @see #unlock
    def edit: (
                ?name: String,
                ?archived: bool,
                ?auto_archive_duration: Integer,
                ?archive_in: Integer,
                ?locked: bool,
                ?reason: String?
              ) -> self

    # 
    # Helper method to archive the thread.
    # 
    # @param [String] reason The reason of archiving the thread.
    # 
    # @return [self] The archived thread.
    def archive: (?reason: String?) -> self

    # 
    # Helper method to lock the thread.
    # 
    # @param [String] reason The reason of locking the thread.
    # 
    # @return [self] The locked thread.
    def lock: (?reason: String?) -> self

    # 
    # Helper method to unarchive the thread.
    # 
    # @param [String] reason The reason of unarchiving the thread.
    # 
    # @return [self] The unarchived thread.
    def unarchive: (?reason: String?) -> self

    # 
    # Helper method to unlock the thread.
    # 
    # @param [String] reason The reason of unlocking the thread.
    # 
    # @return [self] The unlocked thread.
    # 
    # @note This method won't unarchive the thread. Use {#unarchive} instead.
    def unlock: (?reason: String?) -> self

    def parent: () -> untyped

    def me: () -> untyped

    def joined?: () -> bool

    def guild: () -> untyped

    def owner: () -> untyped

    def inspect: () -> untyped

    def add_member: (?untyped member) -> untyped

    def remove_member: (?untyped member) -> untyped

    def fetch_members: () -> untyped
    # 
    # Post a message to the channel.
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Components>, Array<Array<Discorb::Components>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Discorb::Message] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Components] | ::Array[::Array[Discorb::Components]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Discorb::Message

    # 
    # Fetch a message from ID.
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Discorb::Message] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Discorb::Message

    # 
    # Fetch a message history.
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Array<Discorb::Message>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> ::Array[Discorb::Message]

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [Discorb::Snowflake] The ID of the channel.
    # @note This ID is same as the starter message's ID
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the thread.
    attr_reader name: String

    # @return [Integer] The number of messages in the thread.
    # @note This will stop counting at 50.
    attr_reader message_count: Integer

    # @return [Integer] The number of recipients in the thread.
    # @note This will stop counting at 50.
    attr_reader member_count: Integer

    # @return [Integer] The rate limit per user (slowmode) in the thread.
    attr_reader rate_limit_per_user: Integer

    # @return [Array<Discorb::ThreadChannel::Member>] The members of the thread.
    attr_reader members: ::Array[Discorb::ThreadChannel::Member]

    # @return [Time] The time the thread was archived.
    # @return [nil] If the thread is not archived.
    attr_reader archived_timestamp: Time?

    # @return [Integer] Auto archive duration in seconds.
    attr_reader auto_archive_duration: Integer

    # @return [Boolean] Whether the thread is archived or not.
    attr_reader archived: bool

    class Public < Discorb::ThreadChannel
    end

    class Private < Discorb::ThreadChannel
    end

    class Member < Discorb::DiscordModel
      def initialize: (untyped cilent, untyped data) -> void

      def thread: () -> untyped

      def member: () -> untyped

      def id: () -> untyped

      def user: () -> untyped

      def inspect: () -> untyped

      # Returns the value of attribute joined_at.
      attr_reader joined_at: untyped
    end
  end

  class CategoryChannel < Discorb::GuildChannel
    def text_channels: () -> untyped

    def voice_channels: () -> untyped

    def news_channel: () -> untyped

    def stage_channels: () -> untyped

    def create_text_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_voice_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_news_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_stage_channel: (*untyped args, **untyped kwargs) -> untyped
    # Returns the value of attribute channels.
    attr_reader channels: untyped
  end

  class DMChannel < Discorb::Channel
    include Discorb::Messageable

    # @!visibility private
    def base_url: () -> untyped
    # 
    # Post a message to the channel.
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Components>, Array<Array<Discorb::Components>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Discorb::Message] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Components] | ::Array[::Array[Discorb::Components]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Discorb::Message

    # 
    # Fetch a message from ID.
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Discorb::Message] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Discorb::Message

    # 
    # Fetch a message history.
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Array<Discorb::Message>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> ::Array[Discorb::Message]

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  # 
  # A module to handle gateway.
  # This module is internal use only.
  module GatewayHandler
    def connect_gateway: (untyped first) -> untyped

    def send_gateway: (untyped opcode, **untyped value) -> untyped

    def handle_gateway: (untyped payload) -> untyped

    def handle_heartbeat: (untyped interval) -> untyped

    def handle_event: (untyped event_name, untyped data) -> untyped

    # 
    # Represents an event.
    class GatewayEvent
      # @!visibility private
      def initialize: (untyped data) -> void
    end

    # 
    # Represents a reaction event.
    class ReactionEvent < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, untyped data) -> void

      # Fetch the message.
      # If message is cached, it will be returned.
      # @macro async
      # @macro http
      # 
      # @param [Boolean] force Whether to force fetching the message.
      # 
      # @return [Discorb::Message] The message.
      def fetch_message: (?force: bool) -> Discorb::Message

      # @return [Hash] The raw data of the event.
      attr_reader data: ::Hash[untyped, untyped]

      # @return [Discorb::Snowflake] The ID of the user who reacted.
      attr_reader user_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::User] The user who reacted.
      attr_reader user: Discorb::User?

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?

      # @macro client_cache
      # @return [Discorb::Member] The member who reacted.
      attr_reader member: Discorb::Member?

      # @return [Discorb::UnicodeEmoji, Discorb::PartialEmoji] The emoji that was reacted with.
      attr_reader emoji: (Discorb::UnicodeEmoji | Discorb::PartialEmoji)
    end

    # 
    # Represents a `MESSAGE_REACTION_REMOVE_ALL` event.
    class ReactionRemoveAllEvent < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, untyped data) -> void

      # Fetch the message.
      # If message is cached, it will be returned.
      # @macro async
      # @macro http
      # 
      # @param [Boolean] force Whether to force fetching the message.
      # 
      # @return [Discorb::Message] The message.
      def fetch_message: (?force: bool) -> Discorb::Message

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?
    end

    # 
    # Represents a `MESSAGE_REACTION_REMOVE_EMOJI` event.
    class ReactionRemoveEmojiEvent < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, untyped data) -> void

      # Fetch the message.
      # If message is cached, it will be returned.
      # @macro async
      # @macro http
      # 
      # @param [Boolean] force Whether to force fetching the message.
      # 
      # @return [Discorb::Message] The message.
      def fetch_message: (?force: bool) -> Discorb::Message

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?

      # @return [Discorb::UnicodeEmoji, Discorb::PartialEmoji] The emoji that was reacted with.
      attr_reader emoji: (Discorb::UnicodeEmoji | Discorb::PartialEmoji)
    end

    # 
    # Represents a `MESSAGE_UPDATE` event.
    class MessageUpdateEvent < Discorb::GatewayHandler::GatewayEvent
      # @!attribute [r] channel
      #   @macro client_cache
      #   @return [Discorb::Channel] The channel the message was sent in.
      # @!attribute [r] guild
      #   @macro client_cache
      #   @return [Discorb::Guild] The guild the message was sent in.
      def initialize: (
                        untyped client,
                        untyped data,
                        untyped before,
                        untyped after
                      ) -> void

      # Fetch the message.
      # @macro async
      # @macro http
      # 
      # @return [Discorb::Message] The message.
      def fetch_message: () -> Discorb::Message

      # @return [Discorb::Message] The message before update.
      attr_reader before: Discorb::Message

      # @return [Discorb::Message] The message after update.
      attr_reader after: Discorb::Message

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @return [String] The new content of the message.
      attr_reader content: String

      # @return [Time] The time the message was edited.
      attr_reader timestamp: Time

      # @return [Boolean] Whether the message pings @everyone.
      attr_reader mention_everyone: bool

      # @macro client_cache
      # @return [Array<Discorb::Role>] The roles mentioned in the message.
      attr_reader mention_roles: ::Array[Discorb::Role]?

      # @return [Array<Discorb::Attachment>] The attachments in the message.
      attr_reader attachments: ::Array[Discorb::Attachment]

      # @return [Array<Discorb::Embed>] The embeds in the message.
      attr_reader embeds: ::Array[Discorb::Embed]

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    # 
    # Represents a message but it has only ID.
    class UnknownDeleteBulkMessage < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, _ToS id, untyped data) -> void

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    # 
    # Represents a `INVITE_DELETE` event.
    class InviteDeleteEvent < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, untyped data) -> void

      # @return [String] The invite code.
      attr_reader code: String

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    class GuildIntegrationsUpdateEvent < Discorb::GatewayHandler::GatewayEvent
      def initialize: (untyped client, untyped data) -> void

      def guild: () -> untyped
    end

    # 
    # Represents a `TYPING_START` event.
    class TypingStartEvent < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, untyped data) -> void

      # @return [Discorb::Snowflake] The ID of the channel the user is typing in.
      attr_reader user_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the user is typing in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the user is typing in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::User] The user that is typing.
      attr_reader user: Discorb::User?
    end

    # 
    # Represents a message pin event.
    class MessagePinEvent < Discorb::GatewayHandler::GatewayEvent
      # @!attribute [r] pinned?
      #   @return [Boolean] Whether the message was pinned.
      # @!attribute [r] unpinned?
      #   @return [Boolean] Whether the message was unpinned.
      def initialize: (untyped client, untyped data, untyped message) -> void

      # @return [Discorb::Message] The message that was pinned.
      attr_reader message: Discorb::Message

      # @return [:pinned, :unpinned] The type of event.
      attr_reader type: Symbol

      # @return [Boolean] Whether the message was pinned.
      attr_reader pinned?: bool

      # @return [Boolean] Whether the message was unpinned.
      attr_reader unpinned?: bool
    end

    # 
    # Represents a `WEBHOOKS_UPDATE` event.
    class WebhooksUpdateEvent < Discorb::GatewayHandler::GatewayEvent
      # @!visibility private
      def initialize: (untyped client, untyped data) -> void

      # @macro client_cache
      # @return [Discorb::Channel] The channel where the webhook was updated.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild where the webhook was updated.
      attr_reader guild: Discorb::Guild?
    end
  end

  # Represents intents.
  class Intents
    # 
    # Create new intents object with default (no members and presence) intents.
    # 
    # @param guilds [Boolean] Whether guild related events are enabled.
    # @param members [Boolean] Whether guild members related events are enabled.
    #   @note You must enable members intent on developers portal.
    # @param bans [Boolean] Whether guild ban related events are enabled.
    # @param emojis [Boolean] Whether guild emojis related events are enabled.
    # @param integrations [Boolean] Whether guild integration related events are enabled.
    # @param webhooks [Boolean] Whether guild webhooks related events are enabled.
    # @param invites [Boolean] Whether guild invite related events are enabled.
    # @param voice_states [Boolean] Whether guild voice state related events are enabled.
    # @param presences [Boolean] Whether guild presences related events are enabled.
    #   @note You must enable members intent on developers portal.
    # @param messages [Boolean] Whether guild messages related events are enabled.
    # @param reactions [Boolean] Whether guild reaction related events are enabled.
    # @param dm_messages [Boolean] Whether dm messages related events are enabled.
    # @param dm_reactions [Boolean] Whether dm reactions related events are enabled.
    # @param dm_typing [Boolean] Whether dm typing related events are enabled.
    def initialize: (
                      ?guilds: bool,
                      ?members: bool,
                      ?bans: bool,
                      ?emojis: bool,
                      ?integrations: bool,
                      ?webhooks: bool,
                      ?invites: bool,
                      ?voice_states: bool,
                      ?presences: bool,
                      ?messages: bool,
                      ?reactions: bool,
                      ?typing: untyped,
                      ?dm_messages: bool,
                      ?dm_reactions: bool,
                      ?dm_typing: bool
                    ) -> void

    def method_missing: (untyped name, ?untyped args) -> untyped

    def respond_to_missing?: (untyped sym, untyped include_private) -> bool

    # Returns value of the intent.
    # @return [Integer] The value of the intent.
    def value: () -> Integer

    def inspect: () -> untyped

    # Create new intent object from raw value.
    # @param value [Integer] The value of the intent.
    def self.from_value: (Integer value) -> untyped

    # Create new intent object with default values.
    def self.default: () -> untyped

    # Create new intent object with all intents.
    def self.all: () -> untyped

    # Create new intent object with no intents.
    def self.none: () -> untyped
  end

  # 
  # Represents a allowed mentions in a message.
  class AllowedMentions
    # 
    # Initializes a new instance of the AllowedMentions class.
    # 
    # @param [Boolean] everyone Whether to allow @everyone or @here.
    # @param [Boolean, Array<Discorb::Role>] roles The roles to allow, or false to disable.
    # @param [Boolean, Array<Discorb::User>] users The users to allow, or false to disable.
    # @param [Boolean] replied_user Whether to ping the user that sent the message to reply.
    def initialize: (
                      ?everyone: bool?,
                      ?roles: (bool | ::Array[Discorb::Role])?,
                      ?users: (bool | ::Array[Discorb::User])?,
                      ?replied_user: bool?
                    ) -> void

    # @!visibility private
    def to_hash: (?untyped other) -> untyped

    def nil_merge: (*untyped args) -> untyped

    # @return [Boolean] Whether to allow @everyone or @here.
    attr_accessor everyone: bool

    # @return [Boolean, Array<Discorb::Role>] The roles to allow, or false to disable.
    attr_accessor roles: (bool | ::Array[Discorb::Role])

    # @return [Boolean, Array<Discorb::User>] The users to allow, or false to disable.
    attr_accessor users: (bool | ::Array[Discorb::User])

    # @return [Boolean] Whether to ping the user that sent the message to reply.
    attr_accessor replied_user: bool
  end

  # 
  # Represents a message.
  class Message < Discorb::DiscordModel
    # @return [Discorb::Message::Flag] The flag of the message.
    # @see Discorb::Message::Flag
    def flag: () -> Discorb::Message::Flag

    # @!visibility private
    def initialize: (untyped client, untyped data, ?no_cache: untyped) -> void

    # 
    # Convert the message to reference object.
    # 
    # @param [Boolean] fail_if_not_exists Whether to raise an error if the message does not exist.
    # 
    # @return [Hash] The reference object.
    def to_reference: (?fail_if_not_exists: bool) -> ::Hash[untyped, untyped]

    # Reply to the message.
    # @macro async
    # @macro http
    # @param (see #post)
    # @return [Discorb::Message] The message.
    def reply: (*untyped args, **untyped kwargs) -> Discorb::Message

    # 
    # Publish the message.
    # @macro async
    # @macro http
    def publish: () -> untyped

    # 
    # Add a reaction to the message.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to react with.
    def add_reaction: (Discorb::Emoji emoji) -> untyped

    # 
    # Remove a reaction from the message.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to remove.
    def remove_reaction: (Discorb::Emoji emoji) -> untyped

    # 
    # Remove other member's reaction from the message.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to remove.
    # @param [Discorb::Member] member The member to remove the reaction from.
    def remove_reaction_of: (Discorb::Emoji emoji, Discorb::Member member) -> untyped

    # 
    # Fetch reacted users of reaction.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to fetch.
    # @param [Integer, nil] limit The maximum number of users to fetch. `nil` for no limit.
    # @param [Discorb::Snowflake, nil] after The ID of the user to start fetching from.
    # 
    # @return [Array<Discorb::User>] The users.
    def fetch_reacted_users: (Discorb::Emoji emoji, ?limit: Integer?, ?after: Discorb::Snowflake?) -> ::Array[Discorb::User]

    # 
    # Pin the message.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason for pinning the message.
    def pin: (?reason: String?) -> untyped

    # 
    # Unpin the message.
    # @macro async
    # @macro http
    def unpin: () -> untyped

    # 
    # Start thread from the message.
    # 
    # @param (see Discorb::Channel#start_thread)
    # 
    # @return [<Type>] <description>
    def start_thread: (*untyped args, **untyped kwargs) -> ::Array[Type]

    # Meta
    def inspect: () -> untyped
    # @return [Discorb::Snowflake] The ID of the message.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::User, Discorb::Member] The user that sent the message.
    attr_reader author: (Discorb::User | Discorb::Member)

    # @return [String] The content of the message.
    attr_reader content: String

    # @return [Time] The time the message was created.
    attr_reader created_at: Time

    # @return [Time] The time the message was edited.
    # @return [nil] If the message was not edited.
    attr_reader updated_at: Time?

    # @return [Array<Discorb::Attachment>] The attachments of the message.
    attr_reader attachments: ::Array[Discorb::Attachment]

    # @return [Array<Discorb::Embed>] The embeds of the message.
    attr_reader embeds: ::Array[Discorb::Embed]

    # @return [Array<Discorb::Reaction>] The reactions of the message.
    attr_reader reactions: ::Array[Discorb::Reaction]

    # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
    attr_reader webhook_id: Discorb::Snowflake

    # @return [Symbol] The type of the message.
    # Currently, this will be one of:
    # 
    # * `:default`
    # * `:recipient_add`
    # * `:recipient_remove`
    # * `:call`
    # * `:channel_name_change`
    # * `:channel_icon_change`
    # * `:channel_pinned_message`
    # * `:guild_member_join`
    # * `:user_premium_guild_subscription`
    # * `:user_premium_guild_subscription_tier_1`
    # * `:user_premium_guild_subscription_tier_2`
    # * `:user_premium_guild_subscription_tier_3`
    # * `:channel_follow_add`
    # * `:guild_discovery_disqualified`
    # * `:guild_discovery_requalified`
    # * `:guild_discovery_grace_period_initial_warning`
    # * `:guild_discovery_grace_period_final_warning`
    # * `:thread_created`
    # * `:reply`
    # * `:application_command`
    # * `:thread_starter_message`
    # * `:guild_invite_reminder`
    attr_reader type: Symbol

    # @return [Discorb::Message::Activity] The activity of the message.
    attr_reader activity: Discorb::Message::Activity

    # @return [Discorb::Application] The application of the message.
    attr_reader application_id: Discorb::Application

    # @return [Discorb::Message::Reference] The reference of the message.
    attr_reader message_reference: Discorb::Message::Reference
  end
end