# A new wrapper for the Discorb API.
# 
# @author sevenc-nanashi
module Discorb
  Colour: untyped
  API_BASE_URL: untyped
  VERSION: untyped
  USER_AGENT: untyped
  Unset: untyped

  # 
  # Represents a attachment file.
  class Attachment < Discorb::DiscordModel
    # @return [#read] The file content.
    attr_reader io: untyped

    # @return [Discorb::Snowflake] The attachment id.
    attr_reader id: Discorb::Snowflake

    # @return [String] The attachment filename.
    attr_reader filename: String

    # @return [String] The attachment content type.
    attr_reader content_type: String

    # @return [Integer] The attachment size in bytes.
    attr_reader size: Integer

    # @return [String] The attachment url.
    attr_reader url: String

    # @return [String] The attachment proxy url.
    attr_reader proxy_url: String

    # @return [Integer] The image height.
    # @return [nil] If the attachment is not an image.
    attr_reader height: Integer?

    # @return [Integer] The image width.
    # @return [nil] If the attachment is not an image.
    attr_reader width: Integer?

    # @return [Boolean] whether the file is an image.
    attr_reader image?: bool
  end

  # 
  # Represents a file to send as an attachment.
  class File
    # 
    # Creates a new file from IO.
    # 
    # @param [#read] io The IO of the file.
    # @param [String] filename The filename of the file. If not set, path or object_id of the IO is used.
    # @param [String] content_type The content type of the file. If not set, it is guessed from the filename.
    #   If failed to guess, it is set to `application/octet-stream`.
    def initialize: (untyped io, ?String? filename, ?content_type: String?) -> void

    # 
    # Creates a new file from a string.
    # 
    # @param [String] string The string to create the file from.
    # @param [String] filename The filename of the file. object_id of the string is used if not set.
    # @param [String] content_type The content type of the file. If not set, it is guessed from the filename.
    # 
    # @return [File] The new file.
    def self.from_string: (String string, ?filename: String?, ?content_type: String?) -> File

    def inspect: () -> untyped

    # @return [#read] The IO of the file.
    attr_accessor io: untyped

    # @return [String] The filename of the file. If not set, path or object_id of the IO is used.
    attr_accessor filename: String

    # @return [String] The content type of the file. If not set, it is guessed from the filename.
    attr_accessor content_type: String
  end

  # 
  # Represents a flag.
  # @abstract
  class Flag
    # Initialize the flag.
    # @note This is usually called by the subclass.
    # 
    # @param [Integer] value The value of the flag.
    def initialize: (Integer value) -> void

    # 
    # Returns the value of the flag.
    def method_missing: (untyped name, ?untyped args) -> untyped

    def respond_to_missing?: (untyped sym, untyped include_private) -> bool

    # 
    # Union of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The union of the two flags.
    def |: (Discorb::Flag other) -> Discorb::Flag

    # 
    # Subtraction of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The subtraction of the two flags.
    def -: (Discorb::Flag other) -> Discorb::Flag

    # 
    # Intersection of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The intersection of the two flags.
    def &: (Discorb::Flag other) -> Discorb::Flag

    # 
    # XOR of two flags.
    # 
    # @param [Discorb::Flag] other The other flag.
    # 
    # @return [Discorb::Flag] The XOR of the two flags.
    def ^: (Discorb::Flag other) -> Discorb::Flag

    # 
    # Negation of the flag.
    # 
    # @return [Discorb::Flag] The negation of the flag.
    def ~: () -> Discorb::Flag

    def inspect: () -> untyped

    # 
    # Max value of the flag.
    # 
    # @return [Integer] the max value of the flag.
    def self.max_value: () -> Integer

    # @return [Hash{Symbol => Boolean}] the values of the flag.
    attr_reader values: ::Hash[Symbol, bool]

    # @return [Integer] the value of the flag.
    attr_reader value: Integer
  end

  # 
  # A class to handle http requests.
  # 
  # Represents a role in the guild.
  class Role < Discorb::DiscordModel
    include Comparable

    # 
    # Compares two roles by their position.
    # 
    # @param [Discorb::Role] other The role to compare to.
    # 
    # @return [Integer] -1 if the other role is higher, 0 if they are equal, 1 if the other role is lower.
    def <=>: (Discorb::Role other) -> Integer

    # 
    # Formats the role as a string.
    # 
    # @return [String] The formatted string.
    def to_s: () -> String

    def mention: () -> untyped

    def color?: () -> bool

    def inspect: () -> untyped

    # 
    # Moves the role to a new position.
    # @macro async
    # @macro http
    # 
    # @param [Integer] position The new position.
    # @param [String] reason The reason for moving the role.
    def move: (Integer position, ?reason: String?) -> untyped

    # 
    # Edits the role.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new name of the role.
    # @param [Integer] position The new position of the role.
    # @param [Discorb::Color] color The new color of the role.
    # @param [Boolean] hoist Whether the role should be hoisted.
    # @param [Boolean] mentionable Whether the role should be mentionable.
    # @param [Discorb::Image, Discorb::UnicodeEmoji] icon The new icon or emoji of the role.
    # @param [String] reason The reason for editing the role.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?color: Discorb::Color,
                ?hoist: bool,
                ?mentionable: bool,
                ?icon: (Discorb::Image | Discorb::UnicodeEmoji),
                ?reason: String?
              ) -> untyped

    # 
    # Deletes the role.
    # 
    # @param [String] reason The reason for deleting the role.
    def delete!: (?reason: String?) -> untyped

    def tag: () -> untyped
    # @return [Discorb::Snowflake] The ID of the role.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the role.
    attr_reader name: String

    # @return [Discorb::Color] The color of the role.
    attr_reader color: Discorb::Color

    # @return [Discorb::Permission] The permissions of the role.
    attr_reader permissions: Discorb::Permission

    # @return [Integer] The position of the role.
    attr_reader position: Integer

    # @return [Discorb::Guild] The guild this role belongs to.
    attr_reader guild: Discorb::Guild

    # @return [Boolean] Whether the role is hoisted.
    attr_reader hoist: bool

    # @return [Boolean] Whether the role is managed.
    attr_reader managed: bool

    # @return [Boolean] Whether the role is a default role.
    attr_reader mentionable: bool

    # @return [Discorb::Asset, nil] The icon of the role.
    attr_reader custom_icon: Discorb::Asset?

    # @return [Discorb::Emoji, nil] The emoji of the role.
    attr_reader emoji: Discorb::Emoji?

    # 
    # Represents a tag of a role.
    class Tag < Discorb::DiscordModel
      # @return [Discorb::Snowflake] The ID of the bot that owns the role.
      attr_reader bot_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the integration.
      attr_reader integration_id: Discorb::Snowflake

      # @return [Boolean] Whether the tag is a premium subscriber role.
      attr_reader premium_subscriber: bool

      # @return [Boolean] Whether the role is a bot role.
      attr_reader bot?: bool

      # @return [Boolean] Whether the role is an integration role.
      attr_reader integration?: bool
    end
  end

  # 
  # Represents a user of discord.
  class User < Discorb::DiscordModel
    include Discorb::Messageable

    # 
    # Format the user as `Username#Discriminator` style.
    # 
    # @return [String] The formatted username.
    def to_s: () -> String

    def inspect: () -> untyped

    # 
    # Whether the user is a owner of the client.
    # @macro async
    # @macro http
    # 
    # @param [Boolean] strict Whether don't allow if the user is a member of the team.
    # 
    # @return [Async::Task<Boolean>] Whether the user is a owner of the client.
    def bot_owner?: (?strict: bool) -> Async::Task[bool]

    # 
    # Edit a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit_message: (
                        _ToS message_id,
                        ?String? content,
                        ?embed: Discorb::Embed?,
                        ?embeds: ::Array[Discorb::Embed]?,
                        ?allowed_mentions: Discorb::AllowedMentions?,
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                        ?supress: bool?
                      ) -> untyped

    # 
    # Delete a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    def delete_message!: (_ToS message_id, ?reason: String?) -> untyped

    # 
    # Fetch a message from ID.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    # 
    # Fetch a message history.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [Boolean] Whether the user is verified.
    attr_reader verified: bool

    # @return [String] The user's username.
    attr_reader username: String

    # @return [Discorb::Snowflake] The user's ID.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::User::Flag] The user's flags.
    attr_reader flag: Discorb::User::Flag

    # @return [String] The user's discriminator.
    attr_reader discriminator: String

    # @return [Discorb::Asset] The user's avatar.
    attr_reader avatar: Discorb::Asset

    # @return [Boolean] Whether the user is a bot.
    attr_reader bot: bool

    # @return [Time] The time the user was created.
    attr_reader created_at: Time

    # @return [String] The user's mention.
    attr_reader mention: String

    # 
    # Represents the user's flags.
    # ## Flag fields
    # |`1 << 0`|`:discord_employee`|
    # |`1 << 1`|`:partnered_server_owner`|
    # |`1 << 2`|`:hypesquad_events`|
    # |`1 << 3`|`:bug_hunter_level_1`|
    # |`1 << 6`|`:house_bravery`|
    # |`1 << 7`|`:house_brilliance`|
    # |`1 << 8`|`:house_balance`|
    # |`1 << 9`|`:early_supporter`|
    # |`1 << 10`|`:team_user`|
    # |`1 << 14`|`:bug_hunter_level_2`|
    # |`1 << 16`|`:verified_bot`|
    # |`1 << 17`|`:early_verified_bot_developer`|
    # |`1 << 18`|`:discord_certified_moderator`|
    class Flag < Discorb::Flag
    end
  end

  # 
  # Represents a client user.
  class ClientUser < Discorb::User
    # 
    # Edit the client user.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new username.
    # @param [Discorb::Image] avatar The new avatar.
    def edit: (?name: String, ?avatar: Discorb::Image) -> untyped
  end

  # 
  # Represents a single asset.
  class Asset < Discorb::DiscordModel
    # 
    # URL of the asset.
    # 
    # @param [String] image_format The image format.
    # @param [Integer] size The size of the image.
    # 
    # @return [String] URL of the asset.
    def url: (?image_format: String?, ?size: Integer) -> String

    def inspect: () -> untyped

    def endpoint: () -> untyped

    # @return [String] The hash of asset.
    attr_reader hash: String

    # @return [Boolean] Whether the asset is animated.
    attr_reader animated?: bool
  end

  # 
  # Represents a default avatar.
  class DefaultAvatar < Discorb::DiscordModel
    # 
    # Returns the URL of the avatar.
    # 
    # @param [String] image_format The image format. This is compatible with {Asset#url}, will be ignored.
    # @param [Integer] size The size of the image. This is compatible with {Asset#url}, will be ignored.
    # 
    # @return [String] URL of the avatar.
    def url: (?image_format: String?, ?size: Integer) -> String

    def inspect: () -> untyped

    # @return [false] For compatibility with {Asset}, always `false`.
    attr_reader animated?: bool
  end

  # 
  # Represents RGB color.
  class Color
    # 
    # Create a color from a Integer.
    # 
    # @param [Integer] value A color value.
    def initialize: (Integer value) -> void

    # 
    # Integerize a color.
    # 
    # @return [Integer] A color value.
    def to_i: () -> Integer

    # 
    # Convert a color to a hexadecimal value.
    # 
    # @return [String] A hexadecimal value.
    def to_hex: () -> String

    # 
    # Convert a color to RGB array.
    # 
    # @return [Array(Integer, Integer, Integer)] A RGB array.
    def to_rgb: () -> [Integer, Integer, Integer]

    # 
    # Convert a color to RGB hash.
    # 
    # @return [Hash{:r, :g, :b => Integer}] A RGB hash.
    def to_rgb_hash: () -> { r: Integer, g: Integer, b: Integer}

    # 
    # Converts a color to a `#000000` string.
    # 
    # @return [String] Converted string.
    def to_s: () -> String

    def inspect: () -> untyped

    # 
    # Create a color from a hexadecimal string.
    # 
    # @param [String] hex A hexadecimal string.
    # 
    # @return [Discorb::Color] A color object.
    def self.from_hex: (String hex) -> Discorb::Color

    # 
    # Create a color from a RGB array.
    # 
    # @param [Integer] red A red value.
    # @param [Integer] green A green value.
    # @param [Integer] blue A blue value.
    # 
    # @return [Discorb::Color] A color object.
    def self.from_rgb: (Integer red, Integer green, Integer blue) -> Discorb::Color

    # 
    # Create a color from a Discord's color.
    # Currently these colors are supported:
    # 
    # | Color Name | Hexadecimal |
    # |------------|------------|
    # | `:teal` | `#1abc9c` |
    # | `:dark_teal` | `#11806a` |
    # | `:green` | `#2ecc71` |
    # | `:dark_green` | `#1f8b4c` |
    # | `:blue` | `#3498db` |
    # | `:dark_blue` | `#206694` |
    # | `:purple` | `#9b59b6` |
    # | `:dark_purple` | `#71368a` |
    # | `:magenta` | `#e91e63` |
    # | `:dark_magenta` | `#ad1457` |
    # | `:gold` | `#f1c40f` |
    # | `:dark_gold` | `#c27c0e` |
    # | `:orange` | `#e67e22` |
    # | `:dark_orange` | `#a84300` |
    # | `:red` | `#e74c3c` |
    # | `:dark_red` | `#992d22` |
    # | `:lighter_grey` | `#95a5a6` |
    # | `:lighter_gray` | `#95a5a6` |
    # | `:dark_grey` | `#607d8b` |
    # | `:dark_gray` | `#607d8b` |
    # | `:light_grey` | `#979c9f` |
    # | `:light_gray` | `#979c9f` |
    # | `:darker_grey` | `#546e7a` |
    # | `:darker_gray` | `#546e7a` |
    # | `:og_blurple` | `#7289da` |
    # | `:blurple` | `#5865f2` |
    # | `:greyple` | `#99aab5` |
    # | `:dark_theme` | `#36393f` |
    # | `:fuchsia` | `#eb459e` |
    # | `:dark_teal` | `#11806a` |
    # | `:green` | `#2ecc71` |
    # | `:dark_green` | `#1f8b4c` |
    # | `:blue` | `#3498db` |
    # | `:dark_blue` | `#206694` |
    # | `:purple` | `#9b59b6` |
    # | `:dark_purple` | `#71368a` |
    # | `:magenta` | `#e91e63` |
    # | `:dark_magenta` | `#ad1457` |
    # | `:gold` | `#f1c40f` |
    # | `:dark_gold` | `#c27c0e` |
    # | `:orange` | `#e67e22` |
    # | `:dark_orange` | `#a84300` |
    # | `:red` | `#e74c3c` |
    # | `:dark_red` | `#992d22` |
    # | `:lighter_grey` | `#95a5a6` |
    # | `:lighter_gray` | `#95a5a6` |
    # | `:dark_grey` | `#607d8b` |
    # | `:dark_gray` | `#607d8b` |
    # | `:light_grey` | `#979c9f` |
    # | `:light_gray` | `#979c9f` |
    # | `:darker_grey` | `#546e7a` |
    # | `:darker_gray` | `#546e7a` |
    # | `:og_blurple` | `#7289da` |
    # | `:blurple` | `#5865f2` |
    # | `:greyple` | `#99aab5` |
    # | `:dark_theme` | `#36393f` |
    # | `:fuchsia` | `#eb459e` |
    # 
    # @param [Symbol] color A Discord color name.
    # 
    # @return [Discorb::Color] A color object.
    def self.[]: (Symbol color) -> Discorb::Color

    # Returns the value of attribute value.
    attr_accessor value: untyped
  end

  # 
  # Represents an embed of discord.
  class Embed
    # 
    # Initialize a new Embed object.
    # 
    # @param [String] title The title of embed.
    # @param [String] description The description of embed.
    # @param [Discorb::Color] color The color of embed.
    # @param [String] url The url of embed.
    # @param [Time] timestamp The timestamp of embed.
    # @param [Discorb::Embed::Author] author The author field of embed.
    # @param [Array<Discorb::Embed::Field>] fields The fields of embed.
    # @param [Discorb::Embed::Footer] footer The footer of embed.
    # @param [Discorb::Embed::Image, String] image The image of embed.
    # @param [Discorb::Embed::Thumbnail, String] thumbnail The thumbnail of embed.
    def initialize: (
                      ?String? title,
                      ?String? description,
                      ?color: Discorb::Color?,
                      ?url: String?,
                      ?timestamp: Time?,
                      ?author: Discorb::Embed::Author?,
                      ?fields: ::Array[Discorb::Embed::Field]?,
                      ?footer: Discorb::Embed::Footer?,
                      ?image: (Discorb::Embed::Image | String)?,
                      ?thumbnail: (Discorb::Embed::Thumbnail | String)?,
                      ?data: untyped
                    ) -> void

    def inspect: () -> untyped

    # 
    # Convert embed to hash.
    # 
    # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-structure Offical Discord API Docs
    # @return [Hash] Converted embed.
    def to_hash: () -> ::Hash[untyped, untyped]

    # @return [String, nil] The title of embed.
    attr_accessor title: String?

    # @return [String, nil] The description of embed.
    attr_accessor description: String?

    # @return [String, nil] The url of embed.
    attr_accessor url: String?

    # @return [Time, nil] The timestamp of embed.
    attr_accessor timestamp: Time?

    # @return [Discorb::Color, nil] The color of embed.
    attr_accessor color: Discorb::Color?

    # @return [Discorb::Embed::Author, nil] The author of embed.
    attr_accessor author: Discorb::Embed::Author?

    # @return [Array<Discorb::Embed::Field>] The fields of embed.
    attr_accessor fields: ::Array[Discorb::Embed::Field]

    # @return [Discorb::Embed::Footer, nil] The footer of embed.
    attr_accessor footer: Discorb::Embed::Footer?

    # @return [Symbol] The type of embed.
    attr_reader type: Symbol

    # @return [Discorb::Embed::Image] The image of embed.
    attr_accessor image: Discorb::Embed::Image

    # @return [Discorb::Embed::Thumbnail] The thumbnail of embed.
    attr_accessor thumbnail: Discorb::Embed::Thumbnail

    # 
    # Represents an author of embed.
    class Author
      # 
      # Initialize a new Author object.
      # 
      # @param [String] name The name of author.
      # @param [String] url The url of author.
      # @param [String] icon The icon url of author.
      def initialize: (String name, ?url: String?, ?icon: String?) -> void

      # 
      # Convert author to hash.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-author-structure Offical Discord API Docs
      # @return [Hash] Converted author.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The name of author.
      attr_accessor name: String

      # @return [String, nil] The url of author.
      attr_accessor url: String?

      # @return [String, nil] The icon url of author.
      attr_accessor icon: String?
    end

    # 
    # Represemts a footer of embed.
    class Footer
      # 
      # Initialize a new Footer object.
      # 
      # @param [String] text The text of footer.
      # @param [String] icon The icon url of footer.
      def initialize: (String text, ?icon: String?) -> void

      # 
      # Convert footer to hash.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-footer-structure Offical Discord API Docs
      # @return [Hash] Converted footer.
      def to_hash: () -> ::Hash[untyped, untyped]

      # Returns the value of attribute text.
      attr_accessor text: untyped

      # Returns the value of attribute icon.
      attr_accessor icon: untyped
    end

    # 
    # Represents a field of embed.
    class Field
      # 
      # Initialize a new Field object.
      # 
      # @param [String] name The name of field.
      # @param [String] value The value of field.
      # @param [Boolean] inline Whether the field is inline.
      def initialize: (String name, String value, ?inline: bool) -> void

      # 
      # Convert field to hash.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure Offical Discord API Docs
      # @return [Hash] Converted field.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The name of field.
      attr_accessor name: String

      # @return [String] The value of field.
      attr_accessor value: String

      # @return [Boolean] Whether the field is inline.
      attr_accessor inline: bool
    end

    # 
    # Represents an image of embed.
    class Image
      # 
      # Initialize a new Image object.
      # 
      # @param [String] url URL of image.
      def initialize: (String url) -> void

      # 
      # Convert image to hash for sending.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-image-structure Offical Discord API Docs
      # @return [Hash] Converted image.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The url of image.
      attr_accessor url: String

      # @return [String] The proxy url of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader proxy_url: String?

      # @return [Integer] The height of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader height: Integer?

      # @return [Integer] The width of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader width: Integer?
    end

    # 
    # Represents a thumbnail of embed.
    class Thumbnail
      # 
      # Initialize a new Thumbnail object.
      # 
      # @param [String] url URL of thumbnail.
      def initialize: (String url) -> void

      # 
      # Convert thumbnail to hash for sending.
      # 
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-thumbnail-structure Offical Discord API Docs
      # @return [Hash] Converted thumbnail.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The url of thumbnail.
      attr_accessor url: String

      # @return [String] The proxy url of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader proxy_url: String?

      # @return [Integer] The height of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader height: Integer?

      # @return [Integer] The width of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader width: Integer?
    end

    # 
    # Represents a video of embed.
    class Video
      # @return [String] The url of video.
      attr_reader url: String

      # @return [String] The proxy url of video.
      attr_reader proxy_url: String

      # @return [Integer] The height of video.
      attr_reader height: Integer

      # @return [Integer] The width of video.
      attr_reader width: Integer
    end

    # 
    # Represents a provider of embed.
    class Provider
      # @return [String] The name of provider.
      attr_reader name: String

      # @return [String] The url of provider.
      attr_reader url: String
    end
  end

  # Represents a Discord emoji.
  # @abstract
  class Emoji
    def eql?: (untyped other) -> bool

    def ==: (untyped other) -> untyped

    def inspect: () -> untyped
  end

  # Represents a custom emoji in discord.
  class CustomEmoji < Discorb::Emoji
    # 
    # Format the emoji for sending.
    # 
    # @return [String] the formatted emoji.
    def to_s: () -> String

    # 
    # Format the emoji for URI.
    # 
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    # 
    # Edit the emoji.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new name of the emoji.
    # @param [Array<Discorb::Role>] roles The new roles that can use this emoji.
    # @param [String] reason The reason for editing the emoji.
    # 
    # @return [Async::Task<self>] The edited emoji.
    def edit: (?name: String, ?roles: ::Array[Discorb::Role], ?reason: String?) -> Async::Task[self]

    # 
    # Delete the emoji.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason for deleting the emoji.
    # 
    # @return [Async::Task<self>] The deleted emoji.
    def delete!: (?reason: String?) -> Async::Task[self]
    # @return [Discorb::Snowflake] The ID of the emoji.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the emoji.
    attr_reader name: String

    # @return [Array<Discorb::Role>] The roles that can use this emoji.
    attr_reader roles: ::Array[Discorb::Role]

    # @return [Discorb::User] The user that created this emoji.
    attr_reader user: Discorb::User

    # @return [Boolean] Whether the emoji requires colons.
    attr_reader guild: bool

    # @return [Boolean] whether the emoji is managed by integration (ex: Twitch).
    attr_reader managed: bool

    # @return [Boolean] whether the emoji requires colons.
    attr_reader require_colons: bool

    # @return [Boolean] whether the emoji is available.
    attr_reader available: bool

    # @return [Boolean] whether or not this emoji is restricted to certain roles.
    attr_reader roles?: bool
  end

  # 
  # Represents a partial custom emoji in discord.
  class PartialEmoji < Discorb::DiscordModel
    # 
    # Format the emoji for URI.
    # 
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    # 
    # Format the emoji for sending.
    # 
    # @return [String] the formatted emoji.
    def to_s: () -> String

    # @return [Discorb::Snowflake] The ID of the emoji.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the emoji.
    attr_reader name: String

    # @return [Boolean] Whether the emoji is deleted.
    attr_reader deleted: bool
  end

  # 
  # Represents a unicode emoji (default emoji) in discord.
  class UnicodeEmoji < Discorb::Emoji
    # @return [String] The unicode string of the emoji.
    def to_s: () -> String

    # 
    # Format the emoji for URI.
    # 
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    # @return [String] The name of the emoji. (e.g. :grinning:)
    attr_reader name: String

    # @return [String] The unicode value of the emoji. (e.g. U+1F600)
    attr_reader value: String

    # @return [Integer] The skin tone of the emoji.
    attr_reader skin_tone: Integer
  end

  # 
  # Error class for Discorb.
  # @abstract
  class DiscorbError < StandardError
    def enumerate_errors: (untyped hash) -> untyped

    def _recr_items: (untyped key, untyped item, untyped res) -> untyped
  end

  # 
  # Represents a HTTP error.
  # @abstract
  class HTTPError < Discorb::DiscorbError
    # @return [String] the JSON response code.
    # @see https://discord.com/developers/docs/topics/opcodes-and-status-codes#json-json-error-codes
    attr_reader code: String

    # @return [Net::HTTPResponse] the HTTP response.
    attr_reader response: Net::HTTPResponse
  end

  # 
  # Represents a 400 error.
  class BadRequestError < Discorb::HTTPError

  end

  # 
  # Represents a 401 error.
  class UnauthorizedError < Discorb::HTTPError
  end

  # 
  # Represents a 403 error.
  class ForbiddenError < Discorb::HTTPError
  end

  # 
  # Represents a 404 error.
  class NotFoundError < Discorb::HTTPError
  end

  # 
  # Represents a error because of a cloudflare ban.
  class CloudFlareBanError < Discorb::HTTPError
    def initialize: (untyped resp, untyped client) -> void
  end

  # 
  # Represents a error in client-side.
  class ClientError < Discorb::DiscorbError
  end

  # 
  # Represents a timeout error.
  class TimeoutError < Discorb::DiscorbError
  end

  # 
  # Represents a warning.
  class NotSupportedWarning < Discorb::DiscorbError
    def initialize: (untyped message) -> void
  end

  class ScheduledEvent < Discorb::DiscordModel
    # @!visibility private
    def initialize: (untyped client, untyped data) -> void

    # 
    # Create a scheduled event for the guild.
    # @macro async
    # @macro http
    # 
    # @param [:stage_instance, :voice, :external] type The type of event to create.
    # @param [String] name The name of the event.
    # @param [String] description The description of the event.
    # @param [Time] start_time The start time of the event.
    # @param [Time, nil] end_time The end time of the event. Defaults to `nil`.
    # @param [Discorb::Channel, Discorb::Snowflake, nil] channel The channel to run the event in.
    # @param [String, nil] location The location of the event. Defaults to `nil`.
    # @param [:guild_only] privacy_level The privacy level of the event. This must be `:guild_only`.
    # @param [:active, :completed, :canceled] status The status of the event.
    # 
    # @see Event#start
    # @see Event#cancel
    # @see Event#complete
    def edit: (
                ?_type: Symbol,
                ?name: String,
                ?description: String,
                ?start_time: Time,
                ?end_time: Time?,
                ?privacy_level: Symbol,
                ?location: String?,
                ?channel: (Discorb::Channel | Discorb::Snowflake)?,
                ?status: Symbol
              ) -> untyped

    # 
    # Starts the event. Shortcut for `edit(status: :active)`.
    def start: () -> untyped

    # 
    # Completes the event. Shortcut for `edit(status: :completed)`.
    def complete: () -> untyped

    # 
    # Cancels the event. Shortcut for `edit(status: :canceled)`.
    def cancel: () -> untyped

    # 
    # Deletes the event.
    # @macro async
    # @macro http
    def delete!: () -> untyped

    # 
    # Fetches the event users.
    # @macro async
    # @macro http
    # 
    # @note You can fetch all of members by not specifying a parameter.
    # 
    # @param [Integer] limit The maximum number of users to fetch. Defaults to `100`.
    # @param [#to_s] after The ID of the user to start fetching from. Defaults to `nil`.
    # @param [#to_s] before The ID of the user to stop fetching at. Defaults to `nil`.
    # @param [Boolean] with_member Whether to include the member object of the event. Defaults to `false`.
    #   This should be used for manual fetching of members.
    # 
    # @return [Array<Discorb::Member>] The event users.
    def fetch_users: (
                       ?Integer? limit,
                       ?before: untyped,
                       ?after: untyped,
                       ?with_member: bool
                     ) -> ::Array[Discorb::Member]
    # @return [Discorb::Snowflake] The ID of the event.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the event.
    attr_reader name: String

    # @return [String] The description of the event.
    attr_reader description: String

    # @return [Time] The time the event starts.
    attr_reader scheduled_start_time: Time

    # @return [Time] The time the event ends.
    attr_reader scheduled_end_time: Time

    # @return [:guild_only] The privacy level of the event.
    attr_reader privacy_level: Symbol

    # @return [:scheduled, :active, :completed, :canceled] The status of the event.
    attr_reader status: Symbol

    # @return [:stage_instance, :voice, :external] The type of the event.
    attr_reader entity_type: Symbol

    # @return [Discorb::Snowflake] The ID of the entity the event is for.
    attr_reader entity_id: Discorb::Snowflake

    # @return [Discorb::ScheduledEvent::Metadata] The metadata of the event.
    attr_reader metadata: Discorb::ScheduledEvent::Metadata

    # @return [Integer] The user count of the event.
    attr_reader user_count: Integer

    # @!attribute [r] guild
    #   @return [Discorb::Guild, nil] The guild of the event.
    # @!attribute [r] channel
    #   @return [Discorb::Channel, nil] The channel of the event.
    #     Only present if the event will do in stage instance or voice channel.
    # @!attribute [r] creator
    #   @return [Discorb::User] The user who created the event.#
    # @!attribute [r] time
    #   @return [Range<Time>] The time range of the event.
    attr_reader guild: untyped

    # @return [Discorb::Channel, nil] The channel of the event.
    #   Only present if the event will do in stage instance or voice channel.
    attr_reader channel: Discorb::Channel?

    # @return [Discorb::User] The user who created the event.#
    attr_reader creator: Discorb::User

    # @return [Range<Time>] The time range of the event.
    attr_reader time: ::Range[Time]

    # 
    # Represents the metadata of the event.
    class Metadata
      # @!visibility private
      def initialize: (untyped data) -> void

      # @return [String, nil] The location of the event. Only present if the event is a external event.
      attr_reader location: String?
    end
  end

  # 
  # Represents a guild in the Discord.
  class Guild < Discorb::DiscordModel
    # 
    # Leave the guild.
    # @macro async
    # @macro http
    def leave!: () -> untyped

    # 
    # Fetch scheduled events for the guild.
    # @macro async
    # @macro http
    # 
    # @param [Boolean] with_user_count Whether to include the user count in the events.
    #   Defaults to `true`.
    # 
    # @return [Array<Discorb::ScheduledEvent>] The events for the guild.
    def fetch_scheduled_events: (?with_user_count: bool) -> ::Array[Discorb::ScheduledEvent]

    # 
    # Fetch the scheduled event by ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id The ID of the scheduled event.
    # 
    # @return [Discorb::ScheduledEvent] The event with the given ID.
    # @return [nil] If no event with the given ID exists.
    def fetch_scheduled_event: (_ToS id) -> Discorb::ScheduledEvent

    # 
    # Create a scheduled event for the guild.
    # 
    # @param [:stage_instance, :voice, :external] type The type of event to create.
    # @param [String] name The name of the event.
    # @param [String] description The description of the event.
    # @param [Time] start_time The start time of the event.
    # @param [Time, nil] end_time The end time of the event. Defaults to `nil`.
    # @param [Discorb::Channel, Discorb::Snowflake, nil] channel The channel to run the event in.
    # @param [String, nil] location The location of the event. Defaults to `nil`.
    # @param [:guild_only] privacy_level The privacy level of the event. This must be `:guild_only`.
    # 
    # @return [Discorb::ScheduledEvent] The created event.
    def create_scheduled_event: (
                                  Symbol _type,
                                  String name,
                                  String description,
                                  Time start_time,
                                  ?Time? end_time,
                                  ?privacy_level: Symbol,
                                  ?location: String?,
                                  ?channel: (Discorb::Channel | Discorb::Snowflake)?
                                ) -> Discorb::ScheduledEvent

    # 
    # Fetch emoji list of the guild.
    # @macro async
    # @macro http
    # @note This querys the API every time. We recommend using {#emojis} instead.
    # 
    # @return [Async::Task<Discorb::Dictionary{Discorb::Snowflake => Discorb::CustomEmoji}>] A dictionary of emoji in the guild.
    def fetch_emoji_list: () -> Async::Task[Discorb::Dictionary[Discorb::Snowflake, Discorb::CustomEmoji]]

    # 
    # Fetch emoji id of the guild.
    # @macro async
    # @macro http
    # @note This querys the API every time. We recommend using {#emojis} instead.
    # 
    # @param [#to_s] id The emoji id.
    # 
    # @return [Async::Task<Discorb::CustomEmoji>] The emoji with the given id.
    def fetch_emoji: (_ToS id) -> Async::Task[Discorb::CustomEmoji]

    # 
    # Create a custom emoji.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] name The name of the emoji.
    # @param [Discorb::Image] image The image of the emoji.
    # @param [Array<Discorb::Role>] roles A list of roles to give the emoji.
    # 
    # @return [Async::Task<Discorb::CustomEmoji>] The created emoji.
    def create_emoji: (untyped name, Discorb::Image image, ?roles: ::Array[Discorb::Role]) -> Async::Task[Discorb::CustomEmoji]

    # 
    # Fetch webhooks of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Webhook>>] A list of webhooks in the guild.
    def fetch_webhooks: () -> Async::Task[::Array[Discorb::Webhook]]

    # 
    # Fetch audit log of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Discorb::AuditLog>] The audit log of the guild.
    def fetch_audit_log: () -> Async::Task[Discorb::AuditLog]

    # 
    # Fetch channels of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Channel>>] A list of channels in the guild.
    def fetch_channels: () -> Async::Task[::Array[Discorb::Channel]]

    # 
    # Create a new text channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [String] topic The topic of the channel.
    # @param [Integer] rate_limit_per_user The rate limit per user in the channel.
    # @param [Integer] slowmode Alias for `rate_limit_per_user`.
    # @param [Integer] position The position of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Async::Task<Discorb::TextChannel>] The created text channel.
    def create_text_channel: (
                               String name,
                               ?topic: String?,
                               ?rate_limit_per_user: Integer?,
                               ?slowmode: Integer?,
                               ?position: Integer?,
                               ?nsfw: bool?,
                               ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                               ?parent: Discorb::CategoryChannel?,
                               ?reason: String?
                             ) -> Async::Task[Discorb::TextChannel]

    # 
    # Create a new voice channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] bitrate The bitrate of the channel.
    # @param [Integer] user_limit The user limit of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Async::Task<Discorb::VoiceChannel>] The created voice channel.
    def create_voice_channel: (
                                String name,
                                ?bitrate: Integer,
                                ?user_limit: Integer?,
                                ?position: Integer?,
                                ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                ?parent: Discorb::CategoryChannel?,
                                ?reason: String?
                              ) -> Async::Task[Discorb::VoiceChannel]

    # Create a new category channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Async::Task<Discorb::CategoryChannel>] The created category channel.
    def create_category_channel: (
                                   String name,
                                   ?position: Integer?,
                                   ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                   ?parent: Discorb::CategoryChannel?,
                                   ?reason: String?
                                 ) -> Async::Task[Discorb::CategoryChannel]

    # 
    # Create a new stage channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] bitrate The bitrate of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Async::Task<Discorb::StageChannel>] The created stage channel.
    def create_stage_channel: (
                                String name,
                                ?bitrate: Integer,
                                ?position: Integer?,
                                ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                ?parent: Discorb::CategoryChannel?,
                                ?reason: String?
                              ) -> Async::Task[Discorb::StageChannel]

    # 
    # Create a new news channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the channel.
    # @param [String] topic The topic of the channel.
    # @param [Integer] rate_limit_per_user The rate limit per user in the channel.
    # @param [Integer] slowmode Alias for `rate_limit_per_user`.
    # @param [Integer] position The position of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    # 
    # @return [Async::Task<Discorb::NewsChannel>] The created news channel.
    def create_news_channel: (
                               String name,
                               ?topic: String?,
                               ?rate_limit_per_user: Integer?,
                               ?slowmode: Integer?,
                               ?position: Integer?,
                               ?nsfw: bool?,
                               ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                               ?parent: Discorb::CategoryChannel?,
                               ?reason: String?
                             ) -> Async::Task[Discorb::NewsChannel]

    # 
    # Fetch a list of active threads in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The list of threads.
    def fetch_active_threads: () -> Async::Task[::Array[Discorb::ThreadChannel]]

    # 
    # Fetch a member in the guild.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id The ID of the member to fetch.
    # 
    # @return [Async::Task<Discorb::Member>] The member.
    # @return [Async::Task<nil>] If the member is not found.
    def fetch_member: (_ToS id) -> Async::Task[Discorb::Member]

    # Fetch members in the guild.
    # @macro async
    # @macro http
    # @macro members_intent
    # 
    # @param [Integer] limit The maximum number of members to fetch, 0 for all.
    # @param [Integer] after The ID of the member to start fetching after.
    # 
    # @return [Async::Task<Array<Discorb::Member>>] The list of members.
    def fetch_members: (?limit: Integer, ?after: Integer?) -> Async::Task[::Array[Discorb::Member]]

    # 
    # Search for members by name in the guild.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the member to search for.
    # @param [Integer] limit The maximum number of members to return.
    # 
    # @return [Async::Task<Array<Discorb::Member>>] The list of members.
    def fetch_members_named: (String name, ?limit: Integer) -> Async::Task[::Array[Discorb::Member]]

    # 
    # Almost the same as {#fetch_members_named}, but returns a single member.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Discorb::Member>] The member.
    # @return [Async::Task<nil>] If the member is not found.
    def fetch_member_named: () -> Async::Task[Discorb::Member]

    # 
    # Change nickname of client member.
    # 
    # @param [String] nickname The nickname to set.
    # @param [String] reason The reason for changing the nickname.
    def edit_nickname: (String nickname, ?reason: String?) -> untyped

    # 
    # Kick a member from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Member] member The member to kick.
    # @param [String] reason The reason for kicking the member.
    def kick_member: (Discorb::Member member, ?reason: String?) -> untyped

    # 
    # Fetch a list of bans in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Guild::Ban>>] The list of bans.
    def fetch_bans: () -> Async::Task[::Array[Discorb::Guild::Ban]]

    # 
    # Fetch a ban in the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::User] user The user to fetch.
    # 
    # @return [Async::Task<Discorb::Guild::Ban>] The ban.
    # @return [Async::Task<nil>] If the ban is not found.
    def fetch_ban: (Discorb::User user) -> Async::Task[Discorb::Guild::Ban]

    # 
    # Checks the user was banned from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::User] user The user to check.
    # 
    # @return [Async::Task<Boolean>] Whether the user was banned.
    def banned?: (Discorb::User user) -> Async::Task[bool]

    # 
    # Ban a member from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Member] member The member to ban.
    # @param [Integer] delete_message_days The number of days to delete messages.
    # @param [String] reason The reason for banning the member.
    # 
    # @return [Async::Task<Discorb::Guild::Ban>] The ban.
    def ban_member: (Discorb::Member member, ?delete_message_days: Integer, ?reason: String?) -> Async::Task[Discorb::Guild::Ban]

    # 
    # Unban a user from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::User] user The user to unban.
    # @param [String] reason The reason for unbanning the user.
    def unban_user: (Discorb::User user, ?reason: String?) -> untyped

    # 
    # Fetch a list of roles in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Role>>] The list of roles.
    def fetch_roles: () -> Async::Task[::Array[Discorb::Role]]

    # 
    # Create a role in the guild.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the role.
    # @param [Discorb::Color] color The color of the role.
    # @param [Boolean] hoist Whether the role should be hoisted.
    # @param [Boolean] mentionable Whether the role should be mentionable.
    # @param [String] reason The reason for creating the role.
    # 
    # @return [Async::Task<Discorb::Role>] The role.
    def create_role: (
                       ?String? name,
                       ?color: Discorb::Color?,
                       ?hoist: bool?,
                       ?mentionable: bool?,
                       ?reason: String?
                     ) -> Async::Task[Discorb::Role]

    # 
    # Fetch how many members will be pruned.
    # @macro async
    # @macro http
    # 
    # @param [Integer] days The number of days to prune.
    # @param [Array<Discorb::Role>] roles The roles that include for pruning.
    # 
    # @return [Async::Task<Integer>] The number of members that will be pruned.
    def fetch_prune: (?Integer days, ?roles: ::Array[Discorb::Role]) -> Async::Task[Integer]

    # 
    # Prune members from the guild.
    # @macro async
    # @macro http
    # 
    # @param [Integer] days The number of days to prune.
    # @param [Array<Discorb::Role>] roles The roles that include for pruning.
    # @param [String] reason The reason for pruning.
    # 
    # @return [Async::Task<Integer>] The number of members that were pruned.
    def prune: (?Integer days, ?roles: ::Array[Discorb::Role], ?reason: String?) -> Async::Task[Integer]

    # 
    # Fetch voice regions that are available in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::VoiceRegion>>] The available voice regions.
    def fetch_voice_regions: () -> Async::Task[::Array[Discorb::VoiceRegion]]

    # 
    # Fetch invites in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Invite>>] The invites.
    def fetch_invites: () -> Async::Task[::Array[Invite]]

    # 
    # Fetch integrations in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Integration>>] The integrations.
    def fetch_integrations: () -> Async::Task[::Array[Discorb::Integration]]

    # 
    # Fetch the widget of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Discorb::Guild::Widget>] The widget.
    def fetch_widget: () -> Async::Task[Discorb::Guild::Widget]

    # 
    # Fetch the vanity URL of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Discorb::Guild::VanityInvite>] The vanity URL.
    def fetch_vanity_invite: () -> Async::Task[Discorb::Guild::VanityInvite]

    # 
    # Fetch the welcome screen of the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Discorb::WelcomeScreen>] The welcome screen.
    def fetch_welcome_screen: () -> Async::Task[Discorb::WelcomeScreen]

    # 
    # Fetch stickers in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Sticker::GuildSticker>>] The stickers.
    def fetch_stickers: () -> Async::Task[::Array[Discorb::Sticker::GuildSticker]]

    # 
    # Fetch the sticker by ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id The ID of the sticker.
    # 
    # @return [Async::Task<Discorb::Sticker::GuildSticker>] The sticker.
    # @return [Async::Task<nil>] If the sticker does not exist.
    def fetch_sticker: (_ToS id) -> Async::Task[Discorb::Sticker::GuildSticker]

    # 
    # Fetch templates in the guild.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Discorb::GuildTemplate>] The templates.
    def fetch_templates: () -> Async::Task[Discorb::GuildTemplate]

    # 
    # Almost the same as {#fetch_templates}, but returns a single template.
    # 
    # @return [Discorb::GuildTemplate] The template.
    # @return [Async::Task<nil>] If the template does not exist.
    def fetch_template: () -> Discorb::GuildTemplate

    # 
    # Create a new template in the guild.
    # 
    # @param [String] name The name of the template.
    # @param [String] description The description of the template.
    # @param [String] reason The reason for creating the template.
    # 
    # @return [Async::Task<Discorb::GuildTemplate>] The template.
    def create_template: (String name, ?String? description, ?reason: String?) -> Async::Task[Discorb::GuildTemplate]

    # 
    # Returns a banner url from the guild's ID.
    # 
    # @param [#to_s] guild_id The ID of the guild.
    # @param [:shield, :banner1, :banner2, :banner3, :banner4] style The style of the banner.
    # 
    # @return [String] The url of the banner.
    def self.banner: (_ToS guild_id, ?style: Symbol) -> String
    # @return [Discorb::Snowflake] ID of the guild.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the guild.
    attr_reader name: String

    # @return [Discorb::Asset] The splash of the guild.
    attr_reader splash: Discorb::Asset

    # @return [Discorb::Asset] The discovery splash of the guild.
    attr_reader discovery_splash: Discorb::Asset

    # @return [Discorb::Snowflake] ID of the guild owner.
    attr_reader owner_id: Discorb::Snowflake

    # @return [Discorb::Permission] The bot's permission in the guild.
    attr_reader permissions: Discorb::Permission

    # @return [Integer] The AFK timeout of the guild.
    attr_reader afk_timeout: Integer

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Role}] A dictionary of roles in the guild.
    attr_reader roles: Discorb::Dictionary[Discorb::Snowflake, Discorb::Role]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::CustomEmoji}] A dictionary of custom emojis in the guild.
    attr_reader emojis: Discorb::Dictionary[Discorb::Snowflake, Discorb::CustomEmoji]

    # @return [Array<Symbol>] features that are enabled in the guild.
    # @see https://discord.com/developers/docs/resources/guild#guild-object-guild-features Official Discord API docs
    attr_reader features: ::Array[Symbol]

    # @return [:none, :elevated] The MFA level of the guild.
    attr_reader mfa_level: Symbol

    # @return [Discorb::SystemChannelFlag] The flag for the system channel.
    attr_reader system_channel_flags: Discorb::SystemChannelFlag

    # @return [Time] Time that representing when bot has joined the guild.
    attr_reader joined_at: Time

    # @return [Boolean] Whether the guild is unavailable.
    attr_reader unavailable: bool

    # @return [Integer] The amount of members in the guild.
    attr_reader member_count: Integer

    # @return [Discorb::Asset] The icon of the guild.
    attr_reader icon: Discorb::Asset

    # @return [Discorb::Dictionary{Discorb::User => Discorb::VoiceState}] A dictionary of voice states in the guild.
    attr_reader voice_states: Discorb::Dictionary[Discorb::User, Discorb::VoiceState]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Member}] A dictionary of members in the guild.
    # @macro members_intent
    attr_reader members: Discorb::Dictionary[Discorb::Snowflake, Discorb::Member]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::GuildChannel}] A dictionary of channels in the guild.
    attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::GuildChannel]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::ThreadChannel}] A dictionary of threads in the guild.
    attr_reader threads: Discorb::Dictionary[Discorb::Snowflake, Discorb::ThreadChannel]

    # @return [Discorb::Dictionary{Discorb::User => Discorb::Presence}] A dictionary of presence in the guild.
    attr_reader presences: Discorb::Dictionary[Discorb::User, Discorb::Presence]

    # @return [Integer] Number of online members in the guild.
    attr_reader max_presences: Integer

    # @return [String] The vanity invite URL for the guild.
    # @return [nil] If the guild does not have a vanity invite URL.
    attr_reader vanity_url_code: String?

    # @return [String] The description of the guild.
    attr_reader description: String

    # @return [Discorb::Asset] The banner of the guild.
    # @return [nil] If the guild does not have a banner.
    attr_reader banner: Discorb::Asset?

    # @return [Integer] The premium tier (Boost Level) of the guild.
    attr_reader premium_tier: Integer

    # @return [Integer] The amount of premium subscriptions (Server Boosts) the guild has.
    attr_reader premium_subscription_count: Integer

    # @return [Symbol] The preffered language of the guild.
    # @note This modifies the language code, `-` will be replaced with `_`.
    attr_reader preferred_locale: Symbol

    # @return [Integer] The maximum amount of users in a video channel.
    attr_reader max_video_channel_users: Integer

    # @return [Integer] The approxmate amount of members in the guild.
    attr_reader approximate_member_count: Integer

    # @return [Integer] The approxmate amount of non-offline members in the guild.
    attr_reader approximate_presence_count: Integer

    # @return [Discorb::WelcomeScreen] The welcome screen of the guild.
    attr_reader welcome_screen: Discorb::WelcomeScreen

    # @return [:default, :explicit, :safe, :age_restricted] The nsfw level of the guild.
    attr_reader nsfw_level: Symbol

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::StageInstance}] A dictionary of stage instances in the guild.
    attr_reader stage_instances: Discorb::Dictionary[Discorb::Snowflake, Discorb::StageInstance]

    # @return [:none, :low, :medium, :high, :very_high] The verification level of the guild.
    attr_reader verification_level: Symbol

    # @return [:all_messages, :only_mentions] The default message notification level of the guild.
    attr_reader default_message_notifications: Symbol

    # @return [:disabled_in_text, :members_without_roles, :all_members] The explict content filter level of the guild.
    attr_reader explicit_content_filter: Symbol

    # @return [Boolean] Whether the client is the owner of the guild.
    attr_reader owner: bool

    # @return [Boolean] Whether the guild is large.
    attr_reader large: bool

    # @return [Boolean] Whether the guild enabled the widget.
    attr_reader widget_enabled: bool

    # @return [Boolean] Whether the guild is available.
    attr_reader available: bool

    # @return [Dictionary{Discorb::Snowflake => Discorb::ScheduledEvent}] A dictionary of scheduled events in the guild.
    attr_reader scheduled_events: Dictionary[Discorb::Snowflake, Discorb::ScheduledEvent]

    # 
    # Represents a vanity invite.
    class VanityInvite < Discorb::DiscordModel
      # @return [String] The vanity invite code.
      attr_reader code: String

      # @return [Integer] The number of uses.
      attr_reader uses: Integer

      # @return [String] The vanity URL.
      attr_reader url: String
    end

    # 
    # Represents a guild widget.
    class Widget < Discorb::DiscordModel
      # 
      # Edit the widget.
      # @macro async
      # @macro http
      # @macro edit
      # 
      # @param [Boolean] enabled Whether the widget is enabled.
      # @param [Discorb::GuildChannel] channel The channel.
      # @param [String] reason The reason for editing the widget.
      def edit: (?enabled: bool?, ?channel: Discorb::GuildChannel?, ?reason: String?) -> untyped

      # 
      # Return iframe HTML of the widget.
      # 
      # @param ["dark", "light"] theme The theme of the widget.
      # @param [Integer] width The width of the widget.
      # @param [Integer] height The height of the widget.
      # 
      # @return [String] The iframe HTML.
      def iframe: (?theme: ("dark" | "light"), ?width: Integer, ?height: Integer) -> String

      # @return [Discorb::Snowflake] The guild ID.
      attr_reader guild_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The channel ID.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Boolean] Whether the widget is enabled.
      attr_reader enabled: bool

      # @macro client_cache
      # @return [Discorb::Channel] The channel.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild.
      attr_reader guild: Discorb::Guild?

      # @return [String] The JSON URL.
      attr_reader json_url: String
    end

    # 
    # Represents a ban.
    class Ban < Discorb::DiscordModel
      # @return [Discorb::User] The user.
      attr_reader user: Discorb::User

      # @return [String] The reason for the ban.
      attr_reader reason: String
    end
  end

  # 
  # Represents a system channel flag.
  # ## Flag fields
  # |Field|Value|
  # |-|-|
  # |`1 << 0`|`:member_join`|
  # |`1 << 1`|`:server_boost`|
  # |`1 << 2`|`:setup_tips`|
  # |`1 << 3`|`:join_stickers`|
  class SystemChannelFlag < Discorb::Flag
  end

  # 
  # Represents a welcome screen.
  class WelcomeScreen < Discorb::DiscordModel
    # @return [String] The description of the welcome screen.
    attr_reader description: String

    # @return [Array<Discorb::WelcomeScreen::Channel>] The channels to display the welcome screen.
    attr_reader channels: ::Array[Discorb::WelcomeScreen::Channel]

    # @return [Discorb::Guild] The guild the welcome screen belongs to.
    attr_reader guild: Discorb::Guild

    # 
    # Represents a channel to display the welcome screen.
    class Channel < Discorb::DiscordModel
      # 
      # Initialize a new welcome screen channel.
      # 
      # @param [Discorb::TextChannel] channel The channel to display the welcome screen.
      # @param [String] description The channel's name.
      # @param [Discorb::Emoji] emoji The emoji to display.
      def initialize: (Discorb::TextChannel channel, String description, Discorb::Emoji emoji) -> void

      # 
      # Converts the channel to a hash.
      # 
      # @return [Hash] The hash.
      # @see https://discord.com/developers/docs/resources/guild#welcome-screen-object
      def to_hash: () -> ::Hash[untyped, untyped]

      # 
      # Edits the welcome screen.
      # @macro async
      # @macro http
      # @macro edit
      # 
      # @param [Boolean] enabled Whether the welcome screen is enabled.
      # @param [Array<Discorb::WelcomeScreen::Channel>] channels The channels to display the welcome screen.
      # @param [String] description The description of the welcome screen.
      # @param [String] reason The reason for editing the welcome screen.
      def edit: (
                  ?enabled: bool,
                  ?channels: ::Array[Discorb::WelcomeScreen::Channel],
                  ?description: String,
                  ?reason: String?
                ) -> untyped

      # @return [String] The channel's name.
      attr_reader description: String

      # @return [Discorb::Emoji] The emoji to display.
      attr_reader emoji: Discorb::Emoji

      # @macro client_cache
      # @return [Discorb::Channel] The channel to display the welcome screen.
      attr_reader channel: Discorb::Channel?
    end
  end

  # 
  # Represents an image.
  class Image
    # 
    # Initializes a new Image.
    # 
    # @param [#read, String] source The IO source or path of the image.
    # @param [String] type The MIME type of the image.
    def initialize: ((untyped | String) source, ?String? _type) -> void

    # 
    # Formats the image as a Discord style.
    # 
    # @return [String] The image as a Discord style.
    def to_s: () -> String

    def inspect: () -> untyped
  end

  # 
  # Class for connecting to the Discord server.
  class Client
    include Discorb::Gateway::Handler
    include Discorb::ApplicationCommand::Handler

    # 
    # Initializes a new client.
    # 
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions that the client is using.
    # @param [Discorb::Intents] intents The intents that the client is currently using.
    # @param [Integer] message_caches The number of messages to cache.
    # @param [#puts] log The IO object to use for logging.
    # @param [Boolean] colorize_log Whether to colorize the log.
    # @param [:debug, :info, :warn, :error, :critical] log_level The log level.
    # @param [Boolean] wait_until_ready Whether to delay event dispatch until ready.
    # @param [Boolean] fetch_member Whether to fetch member on ready. This may slow down the client. Default to `false`.
    # @param [String] title The title of the process. `false` to default, `nil` to `discorb: User#0000`. Default to `nil`.
    def initialize: (
                      ?allowed_mentions: Discorb::AllowedMentions?,
                      ?intents: Discorb::Intents?,
                      ?message_caches: Integer,
                      ?log: untyped,
                      ?colorize_log: bool,
                      ?log_level: Symbol,
                      ?wait_until_ready: bool,
                      ?fetch_member: bool,
                      ?title: String?
                    ) -> void

    # 
    # Registers an event handler.
    # @see file:docs/Events.md
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Symbol] id Custom ID of the event.
    # @param [Hash] metadata The metadata of the event.
    # @param [Proc] block The block to execute when the event is triggered.
    # 
    # @return [Discorb::EventHandler] The event.
    def on: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] metadata) -> Discorb::EventHandler

    # 
    # Almost same as {#on}, but only triggers the event once.
    # 
    # @param (see #on)
    # 
    # @return [Discorb::EventHandler] The event.
    def once: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] metadata) -> Discorb::EventHandler

    # 
    # Remove event by ID.
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Symbol] id The ID of the event.
    def remove_event: (Symbol event_name, Symbol id) -> untyped

    # 
    # Dispatch an event.
    # 
    # @param [Symbol] event_name The name of the event.
    # @param [Object] args The arguments to pass to the event.
    def dispatch: (Symbol event_name, *Object args) -> untyped

    # 
    # Fetch user from ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id <description>
    # 
    # @return [Async::Task<Discorb::User>] The user.
    # 
    # @raise [Discorb::NotFoundError] If the user doesn't exist.
    def fetch_user: (_ToS id) -> Async::Task[Discorb::User]

    # 
    # Fetch channel from ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id The ID of the channel.
    # 
    # @return [Async::Task<Discorb::Channel>] The channel.
    # 
    # @raise [Discorb::NotFoundError] If the channel doesn't exist.
    def fetch_channel: (_ToS id) -> Async::Task[Discorb::Channel]

    # 
    # Fetch guild from ID.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] id <description>
    # 
    # @return [Async::Task<Discorb::Guild>] The guild.
    # 
    # @raise [Discorb::NotFoundError] If the guild doesn't exist.
    def fetch_guild: (_ToS id) -> Async::Task[Discorb::Guild]

    # 
    # Fetch invite from code.
    # @macro async
    # @macro http
    # 
    # @param [String] code The code of the invite.
    # @param [Boolean] with_count Whether to include the count of the invite.
    # @param [Boolean] with_expiration Whether to include the expiration of the invite.
    # 
    # @return [Async::Task<Discorb::Invite>] The invite.
    def fetch_invite: (String code, ?with_count: bool, ?with_expiration: bool) -> Async::Task[Discorb::Invite]

    # 
    # Fetch webhook from ID.
    # If application was cached, it will be used.
    # @macro async
    # @macro http
    # 
    # @param [Boolean] force Whether to force the fetch.
    # 
    # @return [Async::Task<Discorb::Application>] The application.
    def fetch_application: (?force: bool) -> Async::Task[Discorb::Application]

    # 
    # Fetch nitro sticker pack from ID.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Sticker::Pack>>] The packs.
    def fetch_nitro_sticker_packs: () -> Async::Task[::Array[Discorb::Sticker::Pack]]

    # 
    # Update presence of the client.
    # 
    # @param [Discorb::Activity] activity The activity to update.
    # @param [:online, :idle, :dnd, :invisible] status The status to update.
    # @param [String] afk Whether to set the client as AFK.
    def update_presence: (?Discorb::Activity? activity, ?status: Symbol?, ?afk: String) -> untyped

    # 
    # Method to wait for a event.
    # 
    # @param [Symbol] event The name of the event.
    # @param [Integer] timeout The timeout in seconds.
    # @param [Proc] check The check to use.
    # 
    # @return [Object] The result of the event.
    # 
    # @raise [Discorb::TimeoutError] If the event didn't occur in time.
    def event_lock: (Symbol event, ?Integer? timeout) -> Object

    def inspect: () -> untyped

    # 
    # Load the extension.
    # 
    # @param [Class, Discorb::Extension] ext The extension to load.
    # @param [Object] ... The arguments to pass to the `ext#initialize`.
    def load_extension: ((Class | Discorb::Extension) ext) -> untyped

    # 
    # Starts the client.
    # @note This method behavior will change by CLI.
    # @see file:docs/cli.md
    # 
    # @param [String, nil] token The token to use.
    # 
    # @note If the token is nil, you should use `discorb run` with the `-e` or `--env` option.
    def run: (?String? token) -> untyped

    # 
    # Stops the client.
    def close!: () -> untyped

    def before_run: (untyped token) -> untyped

    def run_setup: (untyped token) -> untyped

    def start_client: (untyped token) -> untyped

    def set_default_events: () -> untyped

    # 
    # Add new top-level command.
    # 
    # @param [String] command_name Command name.
    # @param [String] description Command description.
    # @param [Hash{String => Hash{:description => String, :optional => Boolean, :type => Object}}] options Command options.
    #   The key is the option name, the value is a hash with the following keys:
    # 
    #   | Key | Type | Description |
    #   | --- | --- | --- |
    #   | `:description` | `String` | Description of the option. |
    #   | `:required` | Whether the argument is required. `optional` will be used if not specified. |
    #   | `:optional` | Whether the argument is optional. `required` will be used if not specified. |
    #   | `:type` | `Object` | Type of the option. |
    #   | `:choice` | `Hash{String => String, Integer, Float}` | Type of the option. |
    #   | `:default` | `Object` | Default value of the option. |
    #   | `:channel_types` | `Array<Class<Discorb::Channel>>` | Type of the channel option. |
    #   | `:autocomplete` | `Proc` | Autocomplete function. |
    #   | `:range` | `Range` | Range of the option. Only valid for numeric options. (`:int`, `:float`) |
    # 
    # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
    # @param [Proc] block Command block.
    # 
    # @return [Discorb::ApplicationCommand::Command::SlashCommand] Command object.
    # 
    # @see file:docs/application_command.md#register-slash-command
    # @see file:docs/cli/setup.md
    def slash: (
                 String command_name,
                 String description,
                 ?::Hash[String, String | Integer | Float] options,
                 ?guild_ids: (::Array[untyped] | bool)?
               ) -> Discorb::ApplicationCommand::Command::SlashCommand

    # 
    # Add new command with group.
    # 
    # @param [String] command_name Command name.
    # @param [String] description Command description.
    # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
    # 
    # @yield Block to yield with the command.
    # @yieldparam [Discorb::ApplicationCommand::Command::GroupCommand] group Group command.
    # 
    # @return [Discorb::ApplicationCommand::Command::GroupCommand] Command object.
    # 
    # @see file:docs/slash_command.md
    # @see file:docs/cli/setup.md
    def slash_group: (String command_name, String description, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::ApplicationCommand::Command::GroupCommand group) -> void } -> Discorb::ApplicationCommand::Command::GroupCommand

    # 
    # Add message context menu command.
    # 
    # @param [String] command_name Command name.
    # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
    # @param [Proc] block Command block.
    # @yield [interaction, message] Block to execute.
    # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
    # @yieldparam [Discorb::Message] message Message object.
    # 
    # @return [Discorb::ApplicationCommand::Command] Command object.
    def message_command: (String command_name, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::Message message) -> void } -> Discorb::ApplicationCommand::Command

    # 
    # Add user context menu command.
    # 
    # @param [String] command_name Command name.
    # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
    # @param [Proc] block Command block.
    # @yield [interaction, user] Block to execute.
    # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
    # @yieldparam [Discorb::User] user User object.
    # 
    # @return [Discorb::ApplicationCommand::Command] Command object.
    def user_command: (String command_name, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::User user) -> void } -> Discorb::ApplicationCommand::Command

    # 
    # Setup commands.
    # @see Client#initialize
    # 
    # @param [String] token Bot token.
    # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to use as default. If `false` is given, it will be global command.
    # 
    # @note `token` parameter only required if you don't run client.
    def setup_commands: (?String? token, ?guild_ids: (::Array[untyped] | bool)?) -> untyped

    def connect_gateway: (untyped reconnect) -> untyped

    def send_gateway: (untyped opcode, **untyped value) -> untyped

    def handle_gateway: (untyped payload, untyped reconnect) -> untyped

    def handle_heartbeat: () -> untyped

    def handle_event: (untyped event_name, untyped data) -> untyped

    def ready: () -> untyped

    # @return [Discorb::Intents] The intents that the client is currently using.
    attr_accessor intents: Discorb::Intents

    # @return [Discorb::Application] The application that the client is using.
    # @return [nil] If never fetched application by {#fetch_application}.
    attr_reader application: Discorb::Application?

    # @return [Discorb::HTTP] The http client.
    attr_reader http: Discorb::HTTP

    # @return [Integer] The heartbeat interval.
    attr_reader heartbeat_interval: Integer

    # @return [Integer] The API version of the Discord gateway.
    # @return [nil] If not connected to the gateway.
    attr_reader api_version: Integer?

    # @return [String] The token of the client.
    attr_reader token: String

    # @return [Discorb::AllowedMentions] The allowed mentions that the client is using.
    attr_reader allowed_mentions: Discorb::AllowedMentions

    # @return [Discorb::ClientUser] The client user.
    attr_reader user: Discorb::ClientUser

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Guild}] A dictionary of guilds.
    attr_reader guilds: Discorb::Dictionary[Discorb::Snowflake, Discorb::Guild]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::User}] A dictionary of users.
    attr_reader users: Discorb::Dictionary[Discorb::Snowflake, Discorb::User]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Channel}] A dictionary of channels.
    attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::Channel]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Emoji}] A dictionary of emojis.
    attr_reader emojis: Discorb::Dictionary[Discorb::Snowflake, Discorb::Emoji]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Message}] A dictionary of messages.
    attr_reader messages: Discorb::Dictionary[Discorb::Snowflake, Discorb::Message]

    # @return [Discorb::Logger] The logger.
    attr_reader log: Discorb::Logger

    # @return [Array<Discorb::ApplicationCommand::Command>] The commands that the client is using.
    attr_reader commands: ::Array[Discorb::ApplicationCommand::Command]

    # @return [Float] The ping of the client.
    #   @note This will be calculated from heartbeat and heartbeat_ack.
    # @return [nil] If not connected to the gateway.
    attr_reader ping: Float?

    # @return [:initialized, :running, :closed] The status of the client.
    attr_reader status: Symbol

    # @return [Integer] The session ID of connection.
    attr_reader session_id: Integer

    # @return [Hash{String => Discorb::Extension}] The loaded extensions.
    attr_reader extensions: ::Hash[String, Discorb::Extension]


  end

  # 
  # @abstract
  # Represents Discord model.
  class DiscordModel
    def eql?: (untyped other) -> bool

    def ==: (untyped other) -> untyped


  end

  # 
  # Represents Snowflake of Discord.
  # 
  # @see https://discord.com/developers/docs/reference#snowflakes Official Discord API docs
  class Snowflake < String
    # 
    # Compares snowflake with other object.
    # 
    # @param [#to_s] other Object to compare with.
    # 
    # @return [Boolean] True if snowflake is equal to other object.
    def ==: (untyped other) -> bool

    # 
    # Alias of {#==}.
    def eql?: (untyped other) -> bool

    # Return hash of snowflake.
    def hash: () -> untyped

    def inspect: () -> untyped

    # Timestamp of snowflake.
    # 
    # @return [Time] Timestamp of snowflake.
    attr_reader timestamp: Time

    # Worker ID of snowflake.
    # 
    # @return [Integer] Worker ID of snowflake.
    attr_reader worker_id: Integer

    # Process ID of snowflake.
    # 
    # @return [Integer] Process ID of snowflake.
    attr_reader process_id: Integer

    # Increment of snowflake.
    # 
    # @return [Integer] Increment of snowflake.
    attr_reader increment: Integer

    # Alias of to_s.
    # 
    # @return [String] The snowflake.
    attr_reader id: String
  end

  module DefineOr
  end

  # 
  # Represents invite of discord.
  class Invite < Discorb::DiscordModel
    # Delete the invite.
    # @macro async
    # @macro http
    def delete!: (?reason: untyped) -> untyped
    # @return [String] The code of invite.
    attr_reader code: String

    # @return [:voice, :stream, :guild] The type of invite.
    attr_reader target_type: Symbol

    # @return [User] The user of invite.
    attr_reader target_user: User

    # @return [Integer] The approximate number of online users of invite.
    attr_reader approximate_presence_count: Integer

    # @return [Integer] The approximate number of members of invite.
    attr_reader approximate_member_count: Integer

    # @return [Time] The time when invite expires.
    # @return [nil] The invite never expires.
    # @macro [new] nometa
    #   @return [nil] The invite doesn't have metadata.
    attr_reader expires_at: Time?

    # @return [Integer] The number of uses of invite.
    # @macro nometa
    attr_reader uses: Integer?

    # @return [Integer] The maximum number of uses of invite.
    # @macro nometa
    attr_reader max_uses: Integer?

    # @return [Integer] Duration of invite in seconds.
    # @macro nometa
    attr_reader max_age: Integer?

    # @return [Time] The time when invite was created.
    # @macro nometa
    attr_reader created_at: Time?
  end

  # 
  # Represents a member of a guild.
  class Member < Discorb::User
    # 
    # Format the member to `Username#Discriminator` style.
    # 
    # @return [String] The formatted member.
    def to_s: () -> String

    def inspect: () -> untyped

    # 
    # Add a role to the member.
    # @macro http
    # @macro async
    # 
    # @param [Discorb::Role] role The role to add.
    # @param [String] reason The reason for the action.
    def add_role: (Discorb::Role role, ?reason: String?) -> untyped

    # 
    # Remove a role to the member.
    # @macro http
    # @macro async
    # 
    # @param [Discorb::Role] role The role to add.
    # @param [String] reason The reason for the action.
    def remove_role: (Discorb::Role role, ?reason: String?) -> untyped

    # 
    # Edit the member.
    # @macro http
    # @macro async
    # @macro edit
    # 
    # @param [String] nick The nickname of the member.
    # @param [Discorb::Role] role The roles of the member.
    # @param [Boolean] mute Whether the member is muted.
    # @param [Boolean] deaf Whether the member is deafened.
    # @param [Discorb::StageChannel] channel The channel the member is moved to.
    # @param [String] reason The reason for the action.
    def edit: (
                ?nick: String,
                ?role: Discorb::Role,
                ?mute: bool,
                ?deaf: bool,
                ?channel: Discorb::StageChannel,
                ?reason: String?
              ) -> untyped

    # 
    # Kick the member.
    # 
    # @param [String] reason The reason for the action.
    def kick: (?reason: String?) -> untyped

    # 
    # Ban the member.
    # 
    # @param [Integer] delete_message_days The number of days to delete messages.
    # @param [String] reason The reason for the action.
    # 
    # @return [Async::Task<Discorb::Guild::Ban>] The ban.
    def ban: (?delete_message_days: Integer, ?reason: String?) -> Async::Task[Discorb::Guild::Ban]
    # @return [Time] The time the member boosted the guild.
    attr_reader premium_since: Time

    # @return [String] The nickname of the member.
    # @return [nil] If the member has no nickname.
    attr_reader nick: String?

    # @return [Time] The time the member joined the guild.
    attr_reader joined_at: Time

    # @return [Discorb::Asset] The custom avatar of the member.
    # @return [nil] If the member has no custom avatar.
    attr_reader custom_avatar: Discorb::Asset?

    # @return [Discorb::Asset] The display avatar of the member.
    attr_reader display_avatar: Discorb::Asset

    # @return [Boolean] Whether the member is muted.
    attr_reader mute: bool

    # @return [Boolean] Whether the member is deafened.
    attr_reader deaf: bool

    # @return [Boolean] Whether the member is pending (Not passed member screening).
    attr_reader pending: bool

    # @return [String] The display name of the member.
    attr_reader name: String

    # @return [String] The mention of the member.
    attr_reader mention: String

    # @return [Discorb::VoiceState] The voice state of the member.
    attr_reader voice_state: Discorb::VoiceState

    # @macro client_cache
    # @return [Array<Discorb::Role>] The roles of the member.
    attr_reader roles: ::Array[Discorb::Role]?

    # @macro client_cache
    # @return [Discorb::Guild] The guild the member is in.
    attr_reader guild: Discorb::Guild?

    # @macro client_cache
    # @return [Discorb::Role] The hoisted role of the member.
    # @return [nil] If the member has no hoisted role.
    attr_reader hoisted_role: Discorb::Role?

    # @return [Boolean] Whether the member has a hoisted role.
    attr_reader hoisted?: bool

    # @return [Discorb::Permission] The permissions of the member.
    attr_reader permissions: Discorb::Permission

    # @macro client_cache
    # @return [Discorb::Presence] The presence of the member.
    attr_reader presence: Discorb::Presence?

    # @macro client_cache
    # @return [Discorb::Activity] The activity of the member. It's from the {#presence}.
    attr_reader activity: Discorb::Activity?

    # @macro client_cache
    # @return [Array<Discorb::Activity>] The activities of the member. It's from the {#presence}.
    attr_reader activities: ::Array[Discorb::Activity]?

    # @macro client_cache
    # @return [Symbol] The status of the member. It's from the {#presence}.
    attr_reader status: Symbol?

    # @return [Boolean] Whether the member is the owner of the guild.
    attr_reader owner?: bool
  end

  # 
  # Represents a channel of Discord.
  # @abstract
  class Channel < Discorb::DiscordModel
    # 
    # Checks if the channel is other channel.
    # 
    # @param [Discorb::Channel] other The channel to check.
    # 
    # @return [Boolean] True if the channel is other channel.
    def ==: (Discorb::Channel other) -> bool

    def inspect: () -> untyped

    # @return [String] The name of the channel.
    attr_reader name: String
  end

  # 
  # Represents a channel in guild.
  # @abstract
  class GuildChannel < Discorb::Channel
    include Comparable

    # 
    # Compares position of two channels.
    # 
    # @param [Discorb::GuildChannel] other The channel to compare.
    # 
    # @return [-1, 1] -1 if the channel is at lower than the other, 1 if the channel is at highter than the other.
    def <=>: (Discorb::GuildChannel other) -> Integer

    # 
    # Checks if the channel is same as another.
    # 
    # @param [Discorb::GuildChannel] other The channel to check.
    # 
    # @return [Boolean] `true` if the channel is same as another.
    def ==: (Discorb::GuildChannel other) -> bool

    # 
    # Stringifies the channel.
    # 
    # @return [String] The name of the channel with `#`.
    def to_s: () -> String

    def mention: () -> untyped

    def parent: () -> untyped

    def guild: () -> untyped

    def inspect: () -> untyped

    # 
    # Deletes the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason of deleting the channel.
    # 
    # @return [Async::Task<self>] The deleted channel.
    def delete!: (?reason: String?) -> Async::Task[self]

    # 
    # Moves the channel to another position.
    # @macro async
    # @macro http
    # 
    # @param [Integer] position The position to move the channel.
    # @param [Boolean] lock_permissions Whether to lock the permissions of the channel.
    # @param [Discorb::CategoryChannel] parent The parent of channel.
    # @param [String] reason The reason of moving the channel.
    # 
    # @return [Async::Task<self>] The moved channel.
    def move: (
                Integer position,
                ?lock_permissions: bool,
                ?parent: Discorb::CategoryChannel,
                ?reason: String?
              ) -> Async::Task[self]
    # @return [Integer] The position of the channel as integer.
    attr_reader position: Integer

    # @return [Hash{Discorb::Role, Discorb::Member => PermissionOverwrite}] The permission overwrites of the channel.
    attr_reader permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]
  end

  # 
  # Represents a text channel.
  class TextChannel < Discorb::GuildChannel
    include Discorb::Messageable

    # 
    # Edits the channel.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Discorb::CategoryChannel, nil] category The parent of channel. Specify `nil` to remove the parent.
    # @param [Discorb::CategoryChannel, nil] parent Alias of `category`.
    # @param [String] topic The topic of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Boolean] announce Whether the channel is announce channel.
    # @param [Integer] rate_limit_per_user The rate limit per user (Slowmode) in the channel.
    # @param [Integer] slowmode Alias of `rate_limit_per_user`.
    # @param [Integer] default_auto_archive_duration The default auto archive duration of the channel.
    # @param [Integer] archive_in Alias of `default_auto_archive_duration`.
    # @param [String] reason The reason of editing the channel.
    # 
    # @return [Async::Task<self>] The edited channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?category: Discorb::CategoryChannel?,
                ?parent: Discorb::CategoryChannel?,
                ?topic: String,
                ?nsfw: bool,
                ?announce: bool,
                ?rate_limit_per_user: Integer,
                ?slowmode: Integer,
                ?default_auto_archive_duration: Integer,
                ?archive_in: Integer,
                ?reason: String?
              ) -> Async::Task[self]

    # 
    # Create webhook in the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the webhook.
    # @param [Discorb::Image] avatar The avatar of the webhook.
    # 
    # @return [Async::Task<Discorb::Webhook::IncomingWebhook>] The created webhook.
    def create_webhook: (String name, ?avatar: Discorb::Image?) -> Async::Task[Discorb::Webhook::IncomingWebhook]

    # 
    # Fetch webhooks in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Webhook>>] The webhooks in the channel.
    def fetch_webhooks: () -> Async::Task[::Array[Discorb::Webhook]]

    # 
    # Bulk delete messages in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] messages The messages to delete.
    # @param [Boolean] force Whether to ignore the validation for message (14 days limit).
    def delete_messages!: (*Discorb::Message messages, ?force: bool) -> untyped

    # 
    # Set the channel's permission overwrite.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Role, Discorb::Member] target The target of the overwrite.
    # @param [String] reason The reason of setting the overwrite.
    # @param [{Symbol => Boolean}] perms The permission overwrites to replace.
    def set_permissions: ((Discorb::Role | Discorb::Member) target, ?reason: String?, **::Hash[Symbol, bool] perms) -> untyped

    # 
    # Delete the channel's permission overwrite.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Role, Discorb::Member] target The target of the overwrite.
    # @param [String] reason The reason of deleting the overwrite.
    def delete_permissions: ((Discorb::Role | Discorb::Member) target, ?reason: String?) -> untyped

    # 
    # Fetch the channel's invites.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Invite>>] The invites in the channel.
    def fetch_invites: () -> Async::Task[::Array[Discorb::Invite]]

    # 
    # Create an invite in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Integer] max_age The max age of the invite.
    # @param [Integer] max_uses The max uses of the invite.
    # @param [Boolean] temporary Whether the invite is temporary.
    # @param [Boolean] unique Whether the invite is unique.
    #   @note if it's `false` it may return existing invite.
    # @param [String] reason The reason of creating the invite.
    # 
    # @return [Async::Task<Invite>] The created invite.
    def create_invite: (
                         ?max_age: Integer?,
                         ?max_uses: Integer?,
                         ?temporary: bool,
                         ?unique: bool,
                         ?reason: String?
                       ) -> Async::Task[Invite]

    # 
    # Follow the existing announcement channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::NewsChannel] target The channel to follow.
    # @param [String] reason The reason of following the channel.
    def follow_from: (Discorb::NewsChannel target, ?reason: String?) -> untyped

    # 
    # Follow the existing announcement channel from self.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::TextChannel] target The channel to follow to.
    # @param [String] reason The reason of following the channel.
    def follow_to: (Discorb::TextChannel target, ?reason: String?) -> untyped

    # 
    # Start thread in the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] name The name of the thread.
    # @param [Discorb::Message] message The message to start the thread.
    # @param [Integer] auto_archive_duration The duration of auto-archiving.
    # @param [Boolean] public Whether the thread is public.
    # @param [Integer] rate_limit_per_user The rate limit per user.
    # @param [Integer] slowmode Alias of `rate_limit_per_user`.
    # @param [String] reason The reason of starting the thread.
    # 
    # @return [Async::Task<Discorb::ThreadChannel>] The started thread.
    def start_thread: (
                        String name,
                        ?message: Discorb::Message?,
                        ?auto_archive_duration: Integer,
                        ?public: bool,
                        ?rate_limit_per_user: Integer?,
                        ?slowmode: Integer?,
                        ?reason: String?
                      ) -> Async::Task[Discorb::ThreadChannel]

    # 
    # Fetch archived threads in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The archived threads in the channel.
    def fetch_archived_public_threads: () -> Async::Task[::Array[Discorb::ThreadChannel]]

    # 
    # Fetch archived private threads in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The archived private threads in the channel.
    def fetch_archived_private_threads: () -> Async::Task[::Array[Discorb::ThreadChannel]]

    # 
    # Fetch joined archived private threads in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The limit of threads to fetch.
    # @param [Time] before <description>
    # 
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The joined archived private threads in the channel.
    def fetch_joined_archived_private_threads: (?limit: Integer?, ?before: Time?) -> Async::Task[::Array[Discorb::ThreadChannel]]
    # 
    # Post a message to the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Async::Task[Discorb::Message]

    # 
    # Edit a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit_message: (
                        _ToS message_id,
                        ?String? content,
                        ?embed: Discorb::Embed?,
                        ?embeds: ::Array[Discorb::Embed]?,
                        ?allowed_mentions: Discorb::AllowedMentions?,
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                        ?supress: bool?
                      ) -> untyped

    # 
    # Delete a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    def delete_message!: (_ToS message_id, ?reason: String?) -> untyped

    # 
    # Fetch a message from ID.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    # 
    # Fetch a message history.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [String] The topic of the channel.
    attr_reader topic: String

    # @return [Boolean] Whether the channel is nsfw.
    attr_reader nsfw: bool

    # @return [Discorb::Snowflake] The id of the last message.
    attr_reader last_message_id: Discorb::Snowflake

    # @return [Integer] The rate limit per user (Slowmode) in the channel.
    attr_reader rate_limit_per_user: Integer

    # @return [Time] The time when the last pinned message was pinned.
    attr_reader last_pin_timestamp: Time

    # @return [Array<Discorb::ThreadChannel>] The threads in the channel.
    attr_reader threads: ::Array[Discorb::ThreadChannel]
  end

  # 
  # Represents a news channel (announcement channel).
  class NewsChannel < Discorb::TextChannel
    include Discorb::Messageable

    # 
    # Post a message to the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Async::Task[Discorb::Message]

    # 
    # Edit a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit_message: (
                        _ToS message_id,
                        ?String? content,
                        ?embed: Discorb::Embed?,
                        ?embeds: ::Array[Discorb::Embed]?,
                        ?allowed_mentions: Discorb::AllowedMentions?,
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                        ?supress: bool?
                      ) -> untyped

    # 
    # Delete a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    def delete_message!: (_ToS message_id, ?reason: String?) -> untyped

    # 
    # Fetch a message from ID.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    # 
    # Fetch a message history.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  # 
  # Represents a voice channel.
  class VoiceChannel < Discorb::GuildChannel
    include Discorb::Connectable

    # 
    # Edit the voice channel.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the voice channel.
    # @param [Integer] position The position of the voice channel.
    # @param [Integer] bitrate The bitrate of the voice channel.
    # @param [Integer] user_limit The user limit of the voice channel.
    # @param [Symbol] rtc_region The region of the voice channel.
    # @param [String] reason The reason of editing the voice channel.
    # 
    # @return [Async::Task<self>] The edited voice channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?bitrate: Integer,
                ?user_limit: Integer,
                ?rtc_region: Symbol,
                ?reason: String?
              ) -> Async::Task[self]
    def connect: () -> untyped

    # @return [Integer] The bitrate of the voice channel.
    attr_reader bitrate: Integer

    # @return [Integer] The user limit of the voice channel.
    # @return [nil] If the user limit is not set.
    attr_reader user_limit: Integer?
  end

  # 
  # Represents a stage channel.
  class StageChannel < Discorb::GuildChannel
    include Discorb::Connectable

    # 
    # Edit the stage channel.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the stage channel.
    # @param [Integer] position The position of the stage channel.
    # @param [Integer] bitrate The bitrate of the stage channel.
    # @param [Symbol] rtc_region The region of the stage channel.
    # @param [String] reason The reason of editing the stage channel.
    # 
    # @return [Async::Task<self>] The edited stage channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?bitrate: Integer,
                ?rtc_region: Symbol,
                ?reason: String?
              ) -> Async::Task[self]

    # 
    # Start a stage instance.
    # @macro async
    # @macro http
    # 
    # @param [String] topic The topic of the stage instance.
    # @param [Boolean] public Whether the stage instance is public or not.
    # @param [String] reason The reason of starting the stage instance.
    # 
    # @return [Async::Task<Discorb::StageInstance>] The started stage instance.
    def start: (String topic, ?public: bool, ?reason: String?) -> Async::Task[Discorb::StageInstance]

    # 
    # Fetch a current stage instance.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<StageInstance>] The current stage instance.
    # @return [Async::Task<nil>] If there is no current stage instance.
    def fetch_stage_instance: () -> Async::Task[StageInstance]
    def connect: () -> untyped

    # @return [Integer] The bitrate of the voice channel.
    attr_reader bitrate: Integer

    # @return [Integer] The user limit of the voice channel.
    attr_reader user_limit: Integer


  end

  # 
  # Represents a thread.
  # @abstract
  class ThreadChannel < Discorb::Channel
    include Discorb::Messageable

    # 
    # Edit the thread.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The name of the thread.
    # @param [Boolean] archived Whether the thread is archived or not.
    # @param [Integer] auto_archive_duration The auto archive duration in seconds.
    # @param [Integer] archive_in Alias of `auto_archive_duration`.
    # @param [Boolean] locked Whether the thread is locked or not.
    # @param [String] reason The reason of editing the thread.
    # 
    # @return [Async::Task<self>] The edited thread.
    # 
    # @see #archive
    # @see #lock
    # @see #unarchive
    # @see #unlock
    def edit: (
                ?name: String,
                ?archived: bool,
                ?auto_archive_duration: Integer,
                ?archive_in: Integer,
                ?locked: bool,
                ?reason: String?
              ) -> Async::Task[self]

    # 
    # Helper method to archive the thread.
    # 
    # @param [String] reason The reason of archiving the thread.
    # 
    # @return [self] The archived thread.
    def archive: (?reason: String?) -> self

    # 
    # Helper method to lock the thread.
    # 
    # @param [String] reason The reason of locking the thread.
    # 
    # @return [self] The locked thread.
    def lock: (?reason: String?) -> self

    # 
    # Helper method to unarchive the thread.
    # 
    # @param [String] reason The reason of unarchiving the thread.
    # 
    # @return [self] The unarchived thread.
    def unarchive: (?reason: String?) -> self

    # 
    # Helper method to unlock the thread.
    # 
    # @param [String] reason The reason of unlocking the thread.
    # 
    # @return [self] The unlocked thread.
    # 
    # @note This method won't unarchive the thread. Use {#unarchive} instead.
    def unlock: (?reason: String?) -> self

    def parent: () -> untyped

    def me: () -> untyped

    def joined?: () -> bool

    def guild: () -> untyped

    def owner: () -> untyped

    def inspect: () -> untyped

    def add_member: (?untyped member) -> untyped

    def remove_member: (?untyped member) -> untyped

    def fetch_members: () -> untyped
    # 
    # Post a message to the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Async::Task[Discorb::Message]

    # 
    # Edit a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit_message: (
                        _ToS message_id,
                        ?String? content,
                        ?embed: Discorb::Embed?,
                        ?embeds: ::Array[Discorb::Embed]?,
                        ?allowed_mentions: Discorb::AllowedMentions?,
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                        ?supress: bool?
                      ) -> untyped

    # 
    # Delete a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    def delete_message!: (_ToS message_id, ?reason: String?) -> untyped

    # 
    # Fetch a message from ID.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    # 
    # Fetch a message history.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [Discorb::Snowflake] The ID of the channel.
    # @note This ID is same as the starter message's ID
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the thread.
    attr_reader name: String

    # @return [Integer] The number of messages in the thread.
    # @note This will stop counting at 50.
    attr_reader message_count: Integer

    # @return [Integer] The number of recipients in the thread.
    # @note This will stop counting at 50.
    attr_reader member_count: Integer

    # @return [Integer] The rate limit per user (slowmode) in the thread.
    attr_reader rate_limit_per_user: Integer

    # @return [Array<Discorb::ThreadChannel::Member>] The members of the thread.
    attr_reader members: ::Array[Discorb::ThreadChannel::Member]

    # @return [Time] The time the thread was archived.
    # @return [nil] If the thread is not archived.
    attr_reader archived_timestamp: Time?

    # @return [Integer] Auto archive duration in seconds.
    attr_reader auto_archive_duration: Integer

    # @return [Boolean] Whether the thread is archived or not.
    attr_reader archived: bool

    class News < Discorb::ThreadChannel
    end

    class Public < Discorb::ThreadChannel
    end

    class Private < Discorb::ThreadChannel
    end

    class Member < Discorb::DiscordModel
      def initialize: (untyped cilent, untyped data) -> void

      def thread: () -> untyped

      def member: () -> untyped

      def id: () -> untyped

      def user: () -> untyped

      def inspect: () -> untyped

      # Returns the value of attribute joined_at.
      attr_reader joined_at: untyped
    end
  end

  class CategoryChannel < Discorb::GuildChannel
    def text_channels: () -> untyped

    def voice_channels: () -> untyped

    def news_channel: () -> untyped

    def stage_channels: () -> untyped

    def create_text_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_voice_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_news_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_stage_channel: (*untyped args, **untyped kwargs) -> untyped
    # Returns the value of attribute channels.
    attr_reader channels: untyped
  end

  class DMChannel < Discorb::Channel
    include Discorb::Messageable

    # 
    # Edit a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit_message: (
                        _ToS message_id,
                        ?String? content,
                        ?embed: Discorb::Embed?,
                        ?embeds: ::Array[Discorb::Embed]?,
                        ?allowed_mentions: Discorb::AllowedMentions?,
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                        ?supress: bool?
                      ) -> untyped

    # 
    # Delete a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    def delete_message!: (_ToS message_id, ?reason: String?) -> untyped

    # 
    # Fetch a message from ID.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    # 
    # Fetch a message history.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  # 
  # A module for Discord Gateway.
  # This module is internal use only.
  module Gateway
    # 
    # Represents an event.
    class GatewayEvent

    end

    # 
    # Represents a reaction event.
    class ReactionEvent < Discorb::Gateway::GatewayEvent
      # Fetch the message.
      # If message is cached, it will be returned.
      # @macro async
      # @macro http
      # 
      # @param [Boolean] force Whether to force fetching the message.
      # 
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: (?force: bool) -> Async::Task[Discorb::Message]

      # @return [Hash] The raw data of the event.
      attr_reader data: ::Hash[untyped, untyped]

      # @return [Discorb::Snowflake] The ID of the user who reacted.
      attr_reader user_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::User] The user who reacted.
      attr_reader user: Discorb::User?

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?

      # @macro client_cache
      # @return [Discorb::Member] The member who reacted.
      attr_reader member: Discorb::Member?

      # @return [Discorb::UnicodeEmoji, Discorb::PartialEmoji] The emoji that was reacted with.
      attr_reader emoji: (Discorb::UnicodeEmoji | Discorb::PartialEmoji)

      # @macro client_cache
      # @return [Discorb::Member, Discorb::User] The user or member who reacted.
      attr_reader fired_by: (Discorb::Member | Discorb::User)?
    end

    # 
    # Represents a `MESSAGE_REACTION_REMOVE_ALL` event.
    class ReactionRemoveAllEvent < Discorb::Gateway::GatewayEvent
      # Fetch the message.
      # If message is cached, it will be returned.
      # @macro async
      # @macro http
      # 
      # @param [Boolean] force Whether to force fetching the message.
      # 
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: (?force: bool) -> Async::Task[Discorb::Message]

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?
    end

    # 
    # Represents a `MESSAGE_REACTION_REMOVE_EMOJI` event.
    class ReactionRemoveEmojiEvent < Discorb::Gateway::GatewayEvent
      # Fetch the message.
      # If message is cached, it will be returned.
      # @macro async
      # @macro http
      # 
      # @param [Boolean] force Whether to force fetching the message.
      # 
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: (?force: bool) -> Async::Task[Discorb::Message]

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?

      # @return [Discorb::UnicodeEmoji, Discorb::PartialEmoji] The emoji that was reacted with.
      attr_reader emoji: (Discorb::UnicodeEmoji | Discorb::PartialEmoji)
    end

    # 
    # Represents a `GUILD_SCHEDULED_EVENT_USER_ADD` and `GUILD_SCHEDULED_EVENT_USER_REMOVE` event.
    class ScheduledEventUserEvent < Discorb::Gateway::GatewayEvent
      # @return [Discorb::User] The user that triggered the event.
      attr_reader user: Discorb::User

      # @return [Discorb::Guild] The guild the event was triggered in.
      attr_reader guild: Discorb::Guild

      # @return [Discorb::ScheduledEvent] The scheduled event.
      attr_reader scheduled_event: Discorb::ScheduledEvent
    end

    # 
    # Represents a `MESSAGE_UPDATE` event.
    class MessageUpdateEvent < Discorb::Gateway::GatewayEvent
      # @!attribute [r] channel
      #   @macro client_cache
      #   @return [Discorb::Channel] The channel the message was sent in.
      # @!attribute [r] guild
      #   @macro client_cache
      #   @return [Discorb::Guild] The guild the message was sent in.
      def initialize: (
                        untyped client,
                        untyped data,
                        untyped before,
                        untyped after
                      ) -> void

      # Fetch the message.
      # @macro async
      # @macro http
      # 
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: () -> Async::Task[Discorb::Message]

      # @return [Discorb::Message] The message before update.
      attr_reader before: Discorb::Message

      # @return [Discorb::Message] The message after update.
      attr_reader after: Discorb::Message

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @return [String] The new content of the message.
      attr_reader content: String

      # @return [Time] The time the message was edited.
      attr_reader timestamp: Time

      # @return [Boolean] Whether the message pings @everyone.
      attr_reader mention_everyone: bool

      # @macro client_cache
      # @return [Array<Discorb::Role>] The roles mentioned in the message.
      attr_reader mention_roles: ::Array[Discorb::Role]?

      # @return [Array<Discorb::Attachment>] The attachments in the message.
      attr_reader attachments: ::Array[Discorb::Attachment]

      # @return [Array<Discorb::Embed>] The embeds in the message.
      attr_reader embeds: ::Array[Discorb::Embed]

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    # 
    # Represents a message but it has only ID.
    class UnknownDeleteBulkMessage < Discorb::Gateway::GatewayEvent
      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    # 
    # Represents a `INVITE_DELETE` event.
    class InviteDeleteEvent < Discorb::Gateway::GatewayEvent
      # @return [String] The invite code.
      attr_reader code: String

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    class GuildIntegrationsUpdateEvent < Discorb::Gateway::GatewayEvent
      def initialize: (untyped client, untyped data) -> void

      def guild: () -> untyped
    end

    # 
    # Represents a `TYPING_START` event.
    class TypingStartEvent < Discorb::Gateway::GatewayEvent
      # @return [Discorb::Snowflake] The ID of the channel the user is typing in.
      attr_reader user_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Member] The member that is typing.
      attr_reader member: Discorb::Member?

      # @macro client_cache
      # @return [Discorb::Channel] The channel the user is typing in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the user is typing in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::User] The user that is typing.
      attr_reader user: Discorb::User?

      # @macro client_cache
      # @return [Discorb::Member, Discorb::User] The member or user that started typing.
      attr_reader fired_by: (Discorb::Member | Discorb::User)?
    end

    # 
    # Represents a message pin event.
    class MessagePinEvent < Discorb::Gateway::GatewayEvent
      # @!attribute [r] pinned?
      #   @return [Boolean] Whether the message was pinned.
      # @!attribute [r] unpinned?
      #   @return [Boolean] Whether the message was unpinned.
      def initialize: (untyped client, untyped data, untyped message) -> void

      # @return [Discorb::Message] The message that was pinned.
      attr_reader message: Discorb::Message

      # @return [:pinned, :unpinned] The type of event.
      attr_reader type: Symbol

      # @return [Boolean] Whether the message was pinned.
      attr_reader pinned?: bool

      # @return [Boolean] Whether the message was unpinned.
      attr_reader unpinned?: bool
    end

    # 
    # Represents a `WEBHOOKS_UPDATE` event.
    class WebhooksUpdateEvent < Discorb::Gateway::GatewayEvent
      # @macro client_cache
      # @return [Discorb::Channel] The channel where the webhook was updated.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild where the webhook was updated.
      attr_reader guild: Discorb::Guild?
    end

    # 
    # A module to handle gateway events.
    module Handler
      def connect_gateway: (untyped reconnect) -> untyped

      def send_gateway: (untyped opcode, **untyped value) -> untyped

      def handle_gateway: (untyped payload, untyped reconnect) -> untyped

      def handle_heartbeat: () -> untyped

      def handle_event: (untyped event_name, untyped data) -> untyped

      def ready: () -> untyped
    end

    # 
    # A class for connecting websocket with raw bytes data.

  end

  # Represents intents.
  class Intents
    # 
    # Create new intents object with default (no members and presence) intents.
    # 
    # @param guilds [Boolean] Whether guild related events are enabled.
    # @param members [Boolean] Whether guild members related events are enabled.
    # @param bans [Boolean] Whether guild ban related events are enabled.
    # @param emojis [Boolean] Whether guild emojis related events are enabled.
    # @param integrations [Boolean] Whether guild integration related events are enabled.
    # @param webhooks [Boolean] Whether guild webhooks related events are enabled.
    # @param invites [Boolean] Whether guild invite related events are enabled.
    # @param voice_states [Boolean] Whether guild voice state related events are enabled.
    # @param presences [Boolean] Whether guild presences related events are enabled.
    # @param messages [Boolean] Whether guild messages related events are enabled.
    # @param reactions [Boolean] Whether guild reaction related events are enabled.
    # @param dm_messages [Boolean] Whether dm messages related events are enabled.
    # @param dm_reactions [Boolean] Whether dm reactions related events are enabled.
    # @param dm_typing [Boolean] Whether dm typing related events are enabled.
    # @param scheduled_events [Boolean] Whether events related scheduled events are enabled.
    # 
    # @note You must enable privileged intents to use `members` and/or `presences` intents.
    def initialize: (
                      ?guilds: bool,
                      ?members: bool,
                      ?bans: bool,
                      ?emojis: bool,
                      ?integrations: bool,
                      ?webhooks: bool,
                      ?invites: bool,
                      ?voice_states: bool,
                      ?presences: bool,
                      ?messages: bool,
                      ?reactions: bool,
                      ?typing: untyped,
                      ?dm_messages: bool,
                      ?dm_reactions: bool,
                      ?dm_typing: bool,
                      ?scheduled_events: bool
                    ) -> void

    # 
    # Returns the value of the flag.
    def method_missing: (untyped name, ?untyped args) -> untyped

    def respond_to_missing?: (untyped sym, untyped include_private) -> bool

    # Returns value of the intent.
    # @return [Integer] The value of the intent.
    def value: () -> Integer

    def inspect: () -> untyped

    def to_h: () -> untyped

    # Create new intent object from raw value.
    # @param value [Integer] The value of the intent.
    def self.from_value: (Integer value) -> untyped

    # Create new intent object with default values.
    # This will return intents without members and presence.
    def self.default: () -> untyped

    # Create new intent object with all intents.
    def self.all: () -> untyped

    # Create new intent object with no intents.
    def self.none: () -> untyped
  end

  # 
  # Represents a allowed mentions in a message.
  class AllowedMentions
    # 
    # Initializes a new instance of the AllowedMentions class.
    # 
    # @param [Boolean] everyone Whether to allow @everyone or @here.
    # @param [Boolean, Array<Discorb::Role>] roles The roles to allow, or false to disable.
    # @param [Boolean, Array<Discorb::User>] users The users to allow, or false to disable.
    # @param [Boolean] replied_user Whether to ping the user that sent the message to reply.
    def initialize: (
                      ?everyone: bool?,
                      ?roles: (bool | ::Array[Discorb::Role])?,
                      ?users: (bool | ::Array[Discorb::User])?,
                      ?replied_user: bool?
                    ) -> void

    def inspect: () -> untyped

    # @return [Boolean] Whether to allow @everyone or @here.
    attr_accessor everyone: bool

    # @return [Boolean, Array<Discorb::Role>] The roles to allow, or false to disable.
    attr_accessor roles: (bool | ::Array[Discorb::Role])

    # @return [Boolean, Array<Discorb::User>] The users to allow, or false to disable.
    attr_accessor users: (bool | ::Array[Discorb::User])

    # @return [Boolean] Whether to ping the user that sent the message to reply.
    attr_accessor replied_user: bool
  end

  # 
  # Represents a message.
  class Message < Discorb::DiscordModel
    # 
    # Removes the mentions from the message.
    # 
    # @param [Boolean] user Whether to clean user mentions.
    # @param [Boolean] channel Whether to clean channel mentions.
    # @param [Boolean] role Whether to clean role mentions.
    # @param [Boolean] emoji Whether to clean emoji.
    # @param [Boolean] everyone Whether to clean `@everyone` and `@here`.
    # @param [Boolean] codeblock Whether to clean codeblocks.
    # 
    # @return [String] The cleaned content of the message.
    def clean_content: (
                         ?user: bool,
                         ?channel: bool,
                         ?role: bool,
                         ?emoji: bool,
                         ?everyone: bool,
                         ?codeblock: bool
                       ) -> String

    # 
    # Edit the message.
    # 
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit: (
                ?String? content,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?supress: bool?
              ) -> untyped

    # 
    # Delete the message.
    # 
    # @param [String] reason The reason for deleting the message.
    def delete!: (?reason: String?) -> untyped

    # 
    # Convert the message to reference object.
    # 
    # @param [Boolean] fail_if_not_exists Whether to raise an error if the message does not exist.
    # 
    # @return [Hash] The reference object.
    def to_reference: (?fail_if_not_exists: bool) -> ::Hash[untyped, untyped]

    # Reply to the message.
    # @macro async
    # @macro http
    # @param (see #post)
    # @return [Async::Task<Discorb::Message>] The message.
    def reply: (*untyped args, **untyped kwargs) -> Async::Task[Discorb::Message]

    # 
    # Publish the message.
    # @macro async
    # @macro http
    def publish: () -> untyped

    # 
    # Add a reaction to the message.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to react with.
    def add_reaction: (Discorb::Emoji emoji) -> untyped

    # 
    # Remove a reaction from the message.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to remove.
    def remove_reaction: (Discorb::Emoji emoji) -> untyped

    # 
    # Remove other member's reaction from the message.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to remove.
    # @param [Discorb::Member] member The member to remove the reaction from.
    def remove_reaction_of: (Discorb::Emoji emoji, Discorb::Member member) -> untyped

    # 
    # Fetch reacted users of reaction.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Emoji] emoji The emoji to fetch.
    # @param [Integer, nil] limit The maximum number of users to fetch. `nil` for no limit.
    # @param [Discorb::Snowflake, nil] after The ID of the user to start fetching from.
    # 
    # @return [Async::Task<Array<Discorb::User>>] The users.
    def fetch_reacted_users: (Discorb::Emoji emoji, ?limit: Integer?, ?after: Discorb::Snowflake?) -> Async::Task[::Array[Discorb::User]]

    # 
    # Pin the message.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason for pinning the message.
    def pin: (?reason: String?) -> untyped

    # 
    # Unpin the message.
    # @macro async
    # @macro http
    # 
    # @param [String] reason The reason for unpinning the message.
    def unpin: (?reason: String?) -> untyped

    # 
    # Start thread from the message.
    # 
    # @param (see Discorb::Channel#start_thread)
    # 
    # @return [Async::Task<Discorb::ThreadChannel>] <description>
    def start_thread: (*untyped args, **untyped kwargs) -> Async::Task[Discorb::ThreadChannel]

    # Meta
    def inspect: () -> untyped
    # @return [Discorb::Snowflake] The ID of the message.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::User, Discorb::Member] The user that sent the message.
    attr_reader author: (Discorb::User | Discorb::Member)

    # @return [String] The content of the message.
    attr_reader content: String

    # @return [Time] The time the message was created.
    attr_reader created_at: Time

    # @return [Time] The time the message was edited.
    # @return [nil] If the message was not edited.
    attr_reader updated_at: Time?

    # @return [Array<Discorb::Attachment>] The attachments of the message.
    attr_reader attachments: ::Array[Discorb::Attachment]

    # @return [Array<Discorb::Embed>] The embeds of the message.
    attr_reader embeds: ::Array[Discorb::Embed]

    # @return [Array<Discorb::Reaction>] The reactions of the message.
    attr_reader reactions: ::Array[Discorb::Reaction]

    # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
    attr_reader webhook_id: Discorb::Snowflake

    # @return [Symbol] The type of the message.
    # Currently, this will be one of:
    # 
    # * `:default`
    # * `:recipient_add`
    # * `:recipient_remove`
    # * `:call`
    # * `:channel_name_change`
    # * `:channel_icon_change`
    # * `:channel_pinned_message`
    # * `:guild_member_join`
    # * `:user_premium_guild_subscription`
    # * `:user_premium_guild_subscription_tier_1`
    # * `:user_premium_guild_subscription_tier_2`
    # * `:user_premium_guild_subscription_tier_3`
    # * `:channel_follow_add`
    # * `:guild_discovery_disqualified`
    # * `:guild_discovery_requalified`
    # * `:guild_discovery_grace_period_initial_warning`
    # * `:guild_discovery_grace_period_final_warning`
    # * `:thread_created`
    # * `:reply`
    # * `:chat_input_command`
    # * `:thread_starter_message`
    # * `:guild_invite_reminder`
    # * `:context_menu_command`
    attr_reader type: Symbol

    # @return [Discorb::Message::Activity] The activity of the message.
    attr_reader activity: Discorb::Message::Activity

    # @return [Discorb::Application] The application of the message.
    attr_reader application_id: Discorb::Application

    # @return [Discorb::Message::Reference] The reference of the message.
    attr_reader message_reference: Discorb::Message::Reference

    # @return [Discorb::Message::Flag] The flag of the message.
    # @see Discorb::Message::Flag
    attr_reader flag: Discorb::Message::Flag

    # @return [Discorb::Message::Sticker] The sticker of the message.
    attr_reader stickers: Discorb::Message::Sticker

    # @return [Discorb::Message::Interaction] The interaction of the message.
    attr_reader interaction: Discorb::Message::Interaction

    # @return [Discorb::ThreadChannel] The thread channel of the message.
    attr_reader thread: Discorb::ThreadChannel

    # @return [Array<Array<Discorb::Component>>] The components of the message.
    attr_reader components: ::Array[::Array[Discorb::Component]]

    # @return [Boolean] Whether the message is deleted.
    attr_reader deleted: bool

    # @return [Boolean] Whether the message is tts.
    attr_reader tts: bool

    # @return [Boolean] Whether the message mentions everyone.
    attr_reader mention_everyone: bool

    # @return [Boolean] Whether the message is pinned.
    attr_reader pinned: bool

    # @macro client_cache
    # @return [Discorb::Channel] The channel the message was sent in.
    attr_reader channel: Discorb::Channel?

    # @macro client_cache
    # @return [Discorb::Guild] The guild the message was sent in.
    # @return [nil] If the message was not sent in a guild.
    attr_reader guild: Discorb::Guild?

    # @return [Boolean] Whether the message was sent by a webhook.
    attr_reader webhook?: bool

    # @return [Boolean] Whether the message was edited.
    attr_reader edited?: bool

    # @return [String] The URL to jump to the message.
    attr_reader jump_url: String

    # @return [Discorb::Embed] The embed of the message.
    # @return [nil] If the message has no embed.
    attr_reader embed: Discorb::Embed?

    # @!attribute [r] channel
    #   @macro client_cache
    #   @return [Discorb::Channel] The channel the message was sent in.
    # @!attribute [r] guild
    #   @macro client_cache
    #   @return [Discorb::Guild] The guild the message was sent in.
    #   @return [nil] If the message was not sent in a guild.
    # @!attribute [r] webhook?
    #   @return [Boolean] Whether the message was sent by a webhook.
    # @!attribute [r] edited?
    #   @return [Boolean] Whether the message was edited.
    # @!attribute [r] jump_url
    #   @return [String] The URL to jump to the message.
    # @!attribute [r] embed
    #   @return [Discorb::Embed] The embed of the message.
    #   @return [nil] If the message has no embed.
    # @!attribute [r] embed?
    #   @return [Boolean] Whether the message has an embed.
    # @!attribute [r] reply?
    #   @return [Boolean] Whether the message is a reply.
    # @!attribute [r] dm?
    #   @return [Boolean] Whether the message was sent in a DM.
    # @!attribute [r] guild?
    #   @return [Boolean] Whether the message was sent in a guild.
    attr_reader embed?: bool

    # @return [Boolean] Whether the message is a reply.
    attr_reader reply?: bool

    # @return [Boolean] Whether the message was sent in a DM.
    attr_reader dm?: bool

    # @return [Boolean] Whether the message was sent in a guild.
    attr_reader guild?: bool

    # 
    # Represents message flag.
    # ## Flag fields
    # |Field|Value|
    # |-|-|
    # |`1 << 0`|`:crossposted`|
    # |`1 << 1`|`:crosspost`|
    # |`1 << 2`|`:supress_embeds`|
    # |`1 << 3`|`:source_message_deleted`|
    # |`1 << 4`|`:urgent`|
    # |`1 << 5`|`:has_thread`|
    # |`1 << 6`|`:ephemeral`|
    # |`1 << 7`|`:loading`|
    class Flag < Discorb::Flag
    end

    # 
    # Represents reference of message.
    class Reference
      # 
      # Initialize a new reference.
      # 
      # @param [Discorb::Snowflake] guild_id The guild ID.
      # @param [Discorb::Snowflake] channel_id The channel ID.
      # @param [Discorb::Snowflake] message_id The message ID.
      # @param [Boolean] fail_if_not_exists Whether fail the request if the message is not found.
      def initialize: (
                        Discorb::Snowflake guild_id,
                        Discorb::Snowflake channel_id,
                        Discorb::Snowflake message_id,
                        ?fail_if_not_exists: bool
                      ) -> void

      # 
      # Convert the reference to a hash.
      # 
      # @return [Hash] The hash.
      def to_hash: () -> ::Hash[untyped, untyped]

      # 
      # Initialize a new reference from a hash.
      # 
      # @param [Hash] data The hash.
      # 
      # @return [Discorb::Message::Reference] The reference.
      # @see https://discord.com/developers/docs/resources/channel#message-reference-object
      def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::Message::Reference

      # @return [Discorb::Snowflake] The guild ID.
      attr_accessor guild_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The channel ID.
      attr_accessor channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The message ID.
      attr_accessor message_id: Discorb::Snowflake

      # @return [Boolean] Whether fail the request if the message is not found.
      attr_accessor fail_if_not_exists: bool
    end

    class Sticker
      def initialize: (untyped data) -> void

      # Returns the value of attribute id.
      attr_reader id: untyped

      # Returns the value of attribute name.
      attr_reader name: untyped

      # Returns the value of attribute format.
      attr_reader format: untyped
    end

    # 
    # Represents a interaction of message.
    class Interaction < Discorb::DiscordModel
      # @return [Discorb::Snowflake] The user ID.
      attr_reader id: Discorb::Snowflake

      # @return [String] The name of command.
      # @return [nil] If the message is not a command.
      attr_reader name: String?

      # @return [Class] The type of interaction.
      attr_reader type: Class

      # @return [Discorb::User] The user.
      attr_reader user: Discorb::User
    end

    # 
    # Represents a activity of message.
    class Activity < Discorb::DiscordModel
      # @return [String] The name of activity.
      attr_reader name: String

      # @return [Symbol] The type of activity.
      attr_reader type: Symbol
    end
  end

  # 
  # Module for sending and reading messages.
  module Messageable
    # 
    # Post a message to the channel.
    # @macro async
    # @macro http
    # 
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # 
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?
              ) -> Async::Task[Discorb::Message]

    # 
    # Edit a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    def edit_message: (
                        _ToS message_id,
                        ?String? content,
                        ?embed: Discorb::Embed?,
                        ?embeds: ::Array[Discorb::Embed]?,
                        ?allowed_mentions: Discorb::AllowedMentions?,
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                        ?supress: bool?
                      ) -> untyped

    # 
    # Delete a message.
    # @macro async
    # @macro http
    # 
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    def delete_message!: (_ToS message_id, ?reason: String?) -> untyped

    # 
    # Fetch a message from ID.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Snowflake] id The ID of the message.
    # 
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    # 
    # Fetch a message history.
    # @macro async
    # @macro http
    # 
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    # 
    # Fetch the pinned messages in the channel.
    # @macro async
    # @macro http
    # 
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    # 
    # Pin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    def pin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Unpin a message in the channel.
    # @macro async
    # @macro http
    # 
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> untyped

    # 
    # Trigger the typing indicator in the channel.
    # @macro async
    # @macro http
    # 
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  # 
  # Module for connecting to a voice channel.
  # This will be discord-voice gem.
  module Connectable
    def connect: () -> untyped
  end

  # 
  # Represents a sticker.
  class Sticker < Discorb::DiscordModel
    # @return [String] The name of the sticker.
    attr_reader name: String

    # @return [Array<String>] The tags of the sticker.
    attr_reader tags: ::Array[String]

    # @return [:official, :guild] The type of sticker.
    attr_reader type: Symbol

    # @return [:png, :apng, :lottie] The format of the sticker.
    attr_reader format: Symbol

    # @return [String] The URL of the sticker.
    attr_reader description: String

    # @return [Discorb::Sticker] The ID of the sticker pack.
    attr_reader pack_id: Discorb::Sticker

    # @return [Integer] The sort value of the sticker.
    attr_reader sort_value: Integer

    # @return [Discorb::Snowflake] The ID of the guild the sticker is in.
    attr_reader guild_id: Discorb::Snowflake

    # @return [Discorb::User] The user who created the sticker.
    attr_reader user: Discorb::User

    # @return [Boolean] Whether the sticker is available.
    attr_reader available: bool

    # 
    # Represents a sticker of guilds.
    class GuildSticker < Discorb::Sticker
      def guild: () -> untyped

      # 
      # Edits the sticker.
      # @macro async
      # @macro http
      # @macro edit
      # 
      # @param [String] name The new name of the sticker.
      # @param [String] description The new description of the sticker.
      # @param [Discorb::Emoji] tag The new tags of the sticker.
      # @param [String] reason The reason for the edit.
      def edit: (
                  ?name: String,
                  ?description: String,
                  ?tag: Discorb::Emoji,
                  ?reason: String
                ) -> untyped

      # 
      # Deletes the sticker.
      # @macro async
      # @macro http
      # 
      # @param [String] reason The reason for the deletion.
      def delete!: (?reason: String?) -> untyped
    end

    # 
    # Represents a sticker pack.
    class Pack < Discorb::DiscordModel
      # @return [Discorb::Snowflake] The ID of the sticker pack.
      attr_reader id: Discorb::Snowflake

      # @return [String] The name of the sticker pack.
      attr_reader name: String

      # @return [Discorb::Snowflake] The cover sticker of the pack.
      attr_reader cover_sticker_id: Discorb::Snowflake

      # @return [String] The description of the pack.
      attr_reader description: String

      # @return [Array<Discorb::Sticker>] The stickers in the pack.
      attr_reader stickers: ::Array[Discorb::Sticker]

      # @return [Discorb::Asset] The banner of the pack.
      attr_reader banner: Discorb::Asset
    end
  end

  # 
  # Represents a webhook.
  # @abstract
  class Webhook
    # 
    # Posts a message to the webhook.
    # @macro async
    # @macro http
    # 
    # @param [String] content The content of the message.
    # @param [Boolean] tts Whether the message should be sent as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # @param [String] username The username of the message.
    # @param [String] avatar_url The avatar URL of the message.
    # @param [Boolean] wait Whether to wait for the message to be sent.
    # 
    # @return [Discorb::Webhook::Message] The message that was sent.
    # @return [Async::Task<nil>] If `wait` is false.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?file: Discorb::File?,
                ?files: ::Array[Discorb::File]?,
                ?username: String?,
                ?avatar_url: String,
                ?wait: bool
              ) -> Discorb::Webhook::Message

    # 
    # Edits the webhook.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new name of the webhook.
    # @param [Discorb::Image] avatar The new avatar of the webhook.
    # @param [Discorb::GuildChannel] channel The new channel of the webhook.
    def edit: (?name: String, ?avatar: Discorb::Image, ?channel: Discorb::GuildChannel) -> untyped

    # 
    # Deletes the webhook.
    # @macro async
    # @macro http
    def delete!: () -> untyped

    # 
    # Edits the webhook's message.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [Discorb::Webhook::Message] message The message to edit.
    # @param [String] content The new content of the message.
    # @param [Discorb::Embed] embed The new embed of the message.
    # @param [Array<Discorb::Embed>] embeds The new embeds of the message.
    # @param [Array<Discorb::Attachment>] attachments The attachments to remain.
    # @param [Discorb::File] file The file to send.
    # @param [Array<Discorb::File>] files The files to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    def edit_message: (
                        Discorb::Webhook::Message message,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?file: Discorb::File,
                        ?files: ::Array[Discorb::File],
                        ?attachments: ::Array[Discorb::Attachment],
                        ?allowed_mentions: Discorb::AllowedMentions
                      ) -> untyped

    # 
    # Deletes the webhook's message.
    # 
    # @param [Discorb::Webhook::Message] message The message to delete.
    def delete_message!: (Discorb::Webhook::Message message) -> untyped

    # 
    # Creates URLWebhook.
    # 
    # @param [String] url The URL of the webhook.
    # 
    # @return [Discorb::Webhook::URLWebhook] The URLWebhook.
    def self.new: (String url) -> Discorb::Webhook::URLWebhook

    def self.from_url: (untyped url) -> untyped

    # @return [String] The name of the webhook.
    attr_reader name: String

    # @return [Discorb::Snowflake] The ID of the guild this webhook belongs to.
    attr_reader guild_id: Discorb::Snowflake

    # @return [Discorb::Snowflake] The ID of the channel this webhook belongs to.
    attr_reader channel_id: Discorb::Snowflake

    # @return [Discorb::User] The user that created this webhook.
    attr_reader user: Discorb::User

    # @return [Discorb::Asset] The avatar of the webhook.
    attr_reader avatar: Discorb::Asset

    # @return [Discorb::Snowflake] The application ID of the webhook.
    # @return [nil] If the webhook is not an application webhook.
    attr_reader application_id: Discorb::Snowflake?

    # @return [String] The URL of the webhook.
    attr_reader token: String

    # 
    # Represents a webhook from URL.
    class URLWebhook < Discorb::Webhook
      # 
      # Initializes the webhook from URL.
      # 
      # @param [String] url The URL of the webhook.
      def initialize: (String url) -> void

      # @return [String] The URL of the webhook.
      attr_reader url: String
    end

    # 
    # Represents a bot created webhook.
    class IncomingWebhook < Discorb::Webhook
      # @return [String] The URL of the webhook.
      attr_reader url: String
    end

    # 
    # Represents a webhook of channel following.
    class FollowerWebhook < Discorb::Webhook
      # Represents a source guild of follower webhook.
      # @return [Discorb::Guild, Discorb::Webhook::FollowerWebhook::Guild] The source guild of follower webhook.
      attr_reader source_guild: (Discorb::Guild | Discorb::Webhook::FollowerWebhook::Guild)

      # Represents a source channel of follower webhook.
      # @return [Discorb::Channel, Discorb::Webhook::FollowerWebhook::Channel] The source channel of follower webhook.
      attr_reader source_channel: (Discorb::Channel | Discorb::Webhook::FollowerWebhook::Channel)

      # 
      # Represents a guild of follower webhook.
      class Guild < Discorb::DiscordModel
        # @return [Discorb::Snowflake] The ID of the guild.
        attr_reader id: Discorb::Snowflake

        # @return [String] The name of the guild.
        attr_reader name: String

        # @return [Discorb::Asset] The icon of the guild.
        attr_reader icon: Discorb::Asset
      end

      # 
      # Represents a channel of follower webhook.
      class Channel < Discorb::DiscordModel
        # @return [Discorb::Snowflake] The ID of the channel.
        attr_reader id: Discorb::Snowflake

        # @return [String] The name of the channel.
        attr_reader name: String
      end
    end

    # 
    # Represents a webhook from oauth2.
    class ApplicationWebhook < Discorb::Webhook
    end

    # 
    # Represents a webhook message.
    class Message < Discorb::Message
      # 
      # Edits the message.
      # @macro async
      # @macro http
      # @macro edit
      # 
      # @param (see Webhook#edit_message)
      def edit: () -> untyped

      # 
      # Deletes the message.
      # @macro async
      # @macro http
      def delete!: () -> untyped
      # @return [Discorb::Snowflake] The ID of the channel.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild.
      attr_reader guild_id: Discorb::Snowflake

      # 
      # Represents an author of webhook message.
      class Author < Discorb::DiscordModel
        # 
        # Format author with `Name#Discriminator` style.
        # 
        # @return [String] Formatted author.
        def to_s: () -> String

        # @return [Boolean] Whether the author is a bot.
        # @note This will be always `true`.
        attr_reader bot: bool

        # @return [Discorb::Snowflake] The ID of the author.
        attr_reader id: Discorb::Snowflake

        # @return [String] The name of the author.
        attr_reader username: String

        # @return [Discorb::Asset] The avatar of the author.
        attr_reader avatar: Discorb::Asset

        # @return [String] The discriminator of the author.
        attr_reader discriminator: String
      end
    end
  end

  # 
  # Represents a presence of user.
  class Presence < Discorb::DiscordModel
    # @return [Array<Discorb::Presence::Activity>] The activities of the user.
    attr_reader activities: ::Array[Discorb::Presence::Activity]

    # @return [Discorb::Presence::ClientStatus] The client status of the user.
    attr_reader client_status: Discorb::Presence::ClientStatus

    # @return [Discorb::User] The user of the presence.
    attr_reader user: Discorb::User

    # @return [Discorb::Guild] The guild of the presence.
    attr_reader guild: Discorb::Guild

    # @return [Discorb::Presence::Activity] The activity of the presence.
    attr_reader activity: Discorb::Presence::Activity

    # 
    # Represents an activity of a user.
    class Activity < Discorb::DiscordModel
      # 
      # Convert the activity to a string.
      # 
      # @return [String] The string representation of the activity.
      def to_s: () -> String

      # @return [String] The name of the activity.
      attr_reader name: String

      # @return [:game, :streaming, :listening, :watching, :custom, :competing] The type of the activity.
      attr_reader type: Symbol

      # @return [String] The url of the activity.
      attr_reader url: String

      # @return [Time] The time the activity was created.
      attr_reader created_at: Time

      # @return [Discorb::Presence::Activity::Timestamps] The timestamps of the activity.
      attr_reader timestamps: Discorb::Presence::Activity::Timestamps

      # @return [Discorb::Snowflake] The application id of the activity.
      attr_reader application_id: Discorb::Snowflake

      # @return [String] The details of the activity.
      attr_reader details: String

      # @return [String] The state of party.
      attr_reader state: String

      # @return [Discorb::Emoji] The emoji of the activity.
      attr_reader emoji: Discorb::Emoji

      # @return [Discorb::Presence::Activity::Party] The party of the activity.
      # @return [nil] If the activity is not a party activity.
      attr_reader party: Discorb::Presence::Activity::Party?

      # @return [Discorb::Presence::Activity::Asset] The assets of the activity.
      # @return [nil] If the activity has no assets.
      attr_reader assets: Discorb::Presence::Activity::Asset?

      # @return [Discorb::StageInstance] The instance of the activity.
      # @return [nil] If the activity is not a stage activity.
      attr_reader instance: Discorb::StageInstance?

      # @return [Array<Discorb::Presence::Activity::Button>] The buttons of the activity.
      # @return [nil] If the activity has no buttons.
      attr_reader buttons: ::Array[Discorb::Presence::Activity::Button]?

      # @return [Discorb::Presence::Activity::Flag] The flags of the activity.
      attr_reader flags: Discorb::Presence::Activity::Flag

      # 
      # Represents the timestamps of an activity.
      class Timestamps < Discorb::DiscordModel
        # @return [Time] The start time of the activity.
        attr_reader start: Time

        # @return [Time] The end time of the activity.
        attr_reader end: Time
      end

      class Party < Discorb::DiscordModel
        # @return [String] The id of the party.
        attr_reader id: String

        # @return [Integer] The current size of the party.
        attr_reader current_size: Integer

        # @return [Integer] The max size of the party.
        attr_reader max_size: Integer
      end

      # 
      # Represents the assets of an activity.
      class Asset < Discorb::DiscordModel
        def initialize: (untyped data) -> void

        # @return [String] The large image ID of the asset.
        attr_reader large_image: String

        # @return [String] The large text of the activity.
        attr_reader large_text: String

        # @return [String] The small image ID of the activity.
        attr_reader small_image: String

        # @return [String] The small text of the activity.
        attr_reader small_text: String
      end

      # 
      # Represents the flags of an activity.
      # ## Flag fields
      # |`1 << 0`|`:instance`|
      # |`1 << 1`|`:join`|
      # |`1 << 2`|`:spectate`|
      # |`1 << 3`|`:join_request`|
      # |`1 << 4`|`:sync`|
      # |`1 << 5`|`:play`|
      class Flag < Discorb::Flag
      end

      # 
      # Represents a secrets of an activity.
      class Secrets < Discorb::DiscordModel
        # @return [String] The join secret of the activity.
        attr_reader join: String

        # @return [String] The spectate secret of the activity.
        attr_reader spectate: String

        # @return [String] The match secret of the activity.
        attr_reader match: String
      end

      # 
      # Represents a button of an activity.
      class Button < Discorb::DiscordModel
        # @return [String] The text of the button.
        attr_reader label: String

        # @return [String] The URL of the button.
        attr_reader url: String
      end
    end

    # 
    # Represents a user's client status.
    class ClientStatus < Discorb::DiscordModel
      # @return [Symbol] The desktop status of the user.
      attr_reader desktop: Symbol

      # @return [Symbol] The mobile status of the user.
      attr_reader mobile: Symbol

      # @return [Symbol] The web status of the user.
      attr_reader web: Symbol

      # @return [Boolean] Whether the user is not offline on desktop.
      attr_reader desktop?: bool

      # @return [Boolean] Whether the user is not offline on mobile.
      attr_reader mobile?: bool

      # @return [Boolean] Whether the user is not offline on web.
      attr_reader web?: bool
    end
  end

  # 
  # Represents a reaction to a message.
  class Reaction < Discorb::DiscordModel
    # 
    # Fetch the user that reacted with this emoji.
    # 
    # @param (see Message#fetch_reacted_users)
    # 
    # @return [Array<Discorb::User>] The users that reacted with this emoji.
    def fetch_users: () -> ::Array[Discorb::User]
    # @return [Integer] The number of users that have reacted with this emoji.
    attr_reader count: Integer

    # @return [Discorb::Emoji] The emoji that was reacted with.
    attr_reader emoji: Discorb::Emoji

    # @return [Discorb::Message] The message that this reaction is on.
    attr_reader message: Discorb::Message

    # @return [Boolean] Whether client user reacted with this emoji.
    attr_reader me: bool
  end

  # 
  # Abstract class to make extension.
  # Include from this module to make your own extension.
  # @see file:docs/extension.md
  # @abstract
  module Extension
    def initialize: (untyped client) -> void

    def events: () -> untyped

    def self.included: (untyped base) -> untyped

    module ClassMethods
      include Discorb::ApplicationCommand::Handler

      # 
      # Define a new event.
      # 
      # @param [Symbol] event_name The name of the event.
      # @param [Symbol] id The id of the event. Used to delete the event.
      # @param [Hash] metadata Other metadata.
      # 
      # @return [Discorb::EventHandler] The event.
      def event: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] metadata) -> Discorb::EventHandler

      # 
      # Define a new once event.
      # 
      # @param [Symbol] event_name The name of the event.
      # @param [Symbol] id The id of the event. Used to delete the event.
      # @param [Hash] metadata Other metadata.
      # @param [Proc] block The block to execute when the event is triggered.
      # 
      # @return [Discorb::EventHandler] The event.
      def once_event: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] metadata) -> Discorb::EventHandler

      def self.extended: (untyped klass) -> untyped

      # 
      # Add new top-level command.
      # 
      # @param [String] command_name Command name.
      # @param [String] description Command description.
      # @param [Hash{String => Hash{:description => String, :optional => Boolean, :type => Object}}] options Command options.
      #   The key is the option name, the value is a hash with the following keys:
      # 
      #   | Key | Type | Description |
      #   | --- | --- | --- |
      #   | `:description` | `String` | Description of the option. |
      #   | `:required` | Whether the argument is required. `optional` will be used if not specified. |
      #   | `:optional` | Whether the argument is optional. `required` will be used if not specified. |
      #   | `:type` | `Object` | Type of the option. |
      #   | `:choice` | `Hash{String => String, Integer, Float}` | Type of the option. |
      #   | `:default` | `Object` | Default value of the option. |
      #   | `:channel_types` | `Array<Class<Discorb::Channel>>` | Type of the channel option. |
      #   | `:autocomplete` | `Proc` | Autocomplete function. |
      #   | `:range` | `Range` | Range of the option. Only valid for numeric options. (`:int`, `:float`) |
      # 
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Proc] block Command block.
      # 
      # @return [Discorb::ApplicationCommand::Command::SlashCommand] Command object.
      # 
      # @see file:docs/application_command.md#register-slash-command
      # @see file:docs/cli/setup.md
      def slash: (
                   String command_name,
                   String description,
                   ?::Hash[String, String | Integer | Float] options,
                   ?guild_ids: (::Array[untyped] | bool)?
                 ) -> Discorb::ApplicationCommand::Command::SlashCommand

      # 
      # Add new command with group.
      # 
      # @param [String] command_name Command name.
      # @param [String] description Command description.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # 
      # @yield Block to yield with the command.
      # @yieldparam [Discorb::ApplicationCommand::Command::GroupCommand] group Group command.
      # 
      # @return [Discorb::ApplicationCommand::Command::GroupCommand] Command object.
      # 
      # @see file:docs/slash_command.md
      # @see file:docs/cli/setup.md
      def slash_group: (String command_name, String description, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::ApplicationCommand::Command::GroupCommand group) -> void } -> Discorb::ApplicationCommand::Command::GroupCommand

      # 
      # Add message context menu command.
      # 
      # @param [String] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Proc] block Command block.
      # @yield [interaction, message] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::Message] message Message object.
      # 
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def message_command: (String command_name, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::Message message) -> void } -> Discorb::ApplicationCommand::Command

      # 
      # Add user context menu command.
      # 
      # @param [String] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Proc] block Command block.
      # @yield [interaction, user] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::User] user User object.
      # 
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def user_command: (String command_name, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::User user) -> void } -> Discorb::ApplicationCommand::Command

      # 
      # Setup commands.
      # @see Client#initialize
      # 
      # @param [String] token Bot token.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to use as default. If `false` is given, it will be global command.
      # 
      # @note `token` parameter only required if you don't run client.
      def setup_commands: (?String? token, ?guild_ids: (::Array[untyped] | bool)?) -> untyped

      # @return [Hash{Symbol => Array<Discorb::EventHandler>}] The events of the extension.
      attr_reader events: ::Hash[Symbol, ::Array[Discorb::EventHandler]]

      # @return [Array<Discorb::ApplicationCommand::Command>] The commands of the extension.
      attr_reader commands: ::Array[Discorb::ApplicationCommand::Command]


    end
  end

  # 
  # Represents a Discord audit log.
  class AuditLog < Discorb::DiscordModel
    # 
    # Gets an entry from entries.
    # 
    # @param [Integer] index The index of the entry.
    # 
    # @return [Discorb::AuditLog::Entry] The entry.
    # @return [nil] If the index is out of range.
    def []: (Integer index) -> Discorb::AuditLog::Entry

    # @return [Array<Discorb::Webhook>] The webhooks in this audit log.
    attr_reader webhooks: ::Array[Discorb::Webhook]

    # @return [Array<Discorb::User>] The users in this audit log.
    attr_reader users: ::Array[Discorb::User]

    # @return [Array<Discorb::ThreadChannel>] The threads in this audit log.
    attr_reader threads: ::Array[Discorb::ThreadChannel]

    # @return [Array<Discorb::AuditLog::Entry>] The entries in this audit log.
    attr_reader entries: ::Array[Discorb::AuditLog::Entry]

    # 
    # Represents an entry in an audit log.
    class Entry < Discorb::DiscordModel
      # 
      # Get a change with the given key.
      # 
      # @param [Symbol] key The key to get.
      # 
      # @return [Discorb::AuditLog::Entry::Change] The change with the given key.
      # @return [nil] The change with the given key does not exist.
      def []: (Symbol key) -> Discorb::AuditLog::Entry::Change

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The ID of the entry.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the user who performed the action.
      attr_reader user_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the target of the action.
      attr_reader target_id: Discorb::Snowflake

      # @return [Symbol] The type of the entry.
      # These symbols will be used:
      # 
      # * `:guild_update`
      # * `:channel_create`
      # * `:channel_update`
      # * `:channel_delete`
      # * `:channel_overwrite_create`
      # * `:channel_overwrite_update`
      # * `:channel_overwrite_delete`
      # * `:member_kick`
      # * `:member_prune`
      # * `:member_ban_add`
      # * `:member_ban_remove`
      # * `:member_update`
      # * `:member_role_update`
      # * `:member_move`
      # * `:member_disconnect`
      # * `:bot_add`
      # * `:role_create`
      # * `:role_update`
      # * `:role_delete`
      # * `:invite_create`
      # * `:invite_update`
      # * `:invite_delete`
      # * `:webhook_create`
      # * `:webhook_update`
      # * `:webhook_delete`
      # * `:emoji_create`
      # * `:emoji_update`
      # * `:emoji_delete`
      # * `:message_delete`
      # * `:message_bulk_delete`
      # * `:message_pin`
      # * `:message_unpin`
      # * `:integration_create`
      # * `:integration_update`
      # * `:integration_delete`
      # * `:stage_instance_create`
      # * `:stage_instance_update`
      # * `:stage_instance_delete`
      # * `:sticker_create`
      # * `:sticker_update`
      # * `:sticker_delete`
      # * `:guild_scheduled_event_create`
      # * `:guild_scheduled_event_update`
      # * `:guild_scheduled_event_delete`
      # * `:thread_create`
      # * `:thread_update`
      # * `:thread_delete`
      attr_reader type: Symbol

      # @return [Discorb::AuditLog::Entry::Changes] The changes in this entry.
      attr_reader changes: Discorb::AuditLog::Entry::Changes

      # @return [Discorb::Channel, Discorb::Role, Discorb::Member, Discorb::Guild, Discorb::Message] The target of the entry.
      attr_reader target: (Discorb::Channel | Discorb::Role | Discorb::Member | Discorb::Guild | Discorb::Message)

      # @return [Hash{Symbol => Object}] The optional data for this entry.
      # @note You can use dot notation to access the data.
      attr_reader options: ::Hash[Symbol, Object]

      # @return [Discorb::User] The user who performed the action.
      attr_reader user: Discorb::User

      # 
      # Represents the changes in an audit log entry.
      class Changes < Discorb::DiscordModel
        # 
        # 
        # Get keys of changes.
        # 
        # @return [Array<Symbol>] The keys of the changes.
        def keys: () -> ::Array[Symbol]

        # 
        # Get a change with the given key.
        # 
        # @param [Symbol] key The key to get.
        # 
        # @return [Discorb::AuditLog::Entry::Change] The change with the given key.
        # @return [nil] The change with the given key does not exist.
        def []: (Symbol key) -> Discorb::AuditLog::Entry::Change

        # Returns the value of attribute data.
        attr_reader data: untyped
      end

      # 
      # Represents a change in an audit log entry.
      # @note This instance will try to call a method of {#new_value} if the method wasn't defined.
      class Change < Discorb::DiscordModel
        # 
        # Send a message to the new value.
        def method_missing: (untyped method) -> untyped

        def inspect: () -> untyped

        def respond_to_missing?: (untyped method, ?untyped include_private) -> bool

        # @return [Symbol] The key of the change.
        attr_reader key: Symbol

        # @return [Object] The old value of the change.
        attr_reader old_value: Object

        # @return [Object] The new value of the change.
        attr_reader new_value: Object
      end
    end

    # 
    # Represents an integration in an audit log entry.
    class Integration < Discorb::DiscordModel
      # @return [Discorb::Snowflake] The ID of the integration.
      attr_reader id: Discorb::Snowflake

      # @return [Symbol] The type of the integration.
      attr_reader type: Symbol

      # @return [String] The name of the integration.
      attr_reader name: String

      # @return [Discorb::Integration::Account] The account of the integration.
      attr_reader account: Discorb::Integration::Account
    end
  end

  # 
  # @abstract
  # Represents a Discord component.
  class Component
    def inspect: () -> untyped

    # 
    # Create a new component from hash data.
    # 
    # @see https://discord.com/developers/docs/interactions/message-components Official Discord API documentation
    # @param [Hash] data Hash data.
    # 
    # @return [Component] A new component.
    def self.from_hash: (::Hash[untyped, untyped] data) -> Component

    # 
    # Convert components to a hash.
    # 
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components Components.
    # 
    # @return [Array<Hash>] Hash data.
    def self.to_payload: ((::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]) components) -> ::Array[::Hash[untyped, untyped]]
  end

  # 
  # Represents a button component.
  class Button < Discorb::Component
    # 
    # Initialize a new button.
    # 
    # @param [String] label The label of the button.
    # @param [:primary, :secondary, :success, :danger, :link] style The style of the button.
    # @param [Discorb::Emoji] emoji The emoji of the button.
    # @param [String] custom_id The custom ID of the button.
    # @param [String] url The URL of the button.
    # @param [Boolean] disabled Whether the button is disabled.
    def initialize: (
                      String label,
                      ?Symbol style,
                      ?emoji: Discorb::Emoji?,
                      ?custom_id: String?,
                      ?url: String?,
                      ?disabled: bool
                    ) -> void

    # 
    # Converts the button to a hash.
    # 
    # @see https://discord.com/developers/docs/interactions/message-components#button-object-button-structure Official Discord API docs
    # @return [Hash] A hash representation of the button.
    def to_hash: () -> ::Hash[untyped, untyped]

    def inspect: () -> untyped

    def hash_emoji: (untyped emoji) -> untyped

    # @return [String] The label of the button.
    attr_accessor label: String

    # @return [:primary, :secondary, :success, :danger, :link] The style of the button.
    attr_accessor style: Symbol

    # @return [Discorb::Emoji] The emoji of the button.
    attr_accessor emoji: Discorb::Emoji

    # @return [String] The custom ID of the button.
    #   Won't be used if the style is `:link`.
    attr_accessor custom_id: String

    # @return [String] The URL of the button.
    #   Only used when the style is `:link`.
    attr_accessor url: String

    # @return [Boolean] Whether the button is disabled.
    attr_accessor disabled: bool
  end

  # 
  # Represents a select menu component.
  class SelectMenu < Discorb::Component
    # 
    # Initialize a new select menu.
    # 
    # @param [String, Symbol] custom_id Custom ID of the select menu.
    # @param [Array<Discorb::SelectMenu::Option>] options The options of the select menu.
    # @param [String] placeholder The placeholder of the select menu.
    # @param [Integer] min_values The minimum number of values.
    # @param [Integer] max_values The maximum number of values.
    def initialize: (
                      (String | Symbol) custom_id,
                      ::Array[Discorb::SelectMenu::Option] options,
                      ?placeholder: String?,
                      ?min_values: Integer,
                      ?max_values: Integer
                    ) -> void

    # 
    # Converts the select menu to a hash.
    # 
    # @see https://discord.com/developers/docs/interactions/message-components#select-menu-object-select-menu-structure Official Discord API docs
    # @return [Hash] A hash representation of the select menu.
    def to_hash: () -> ::Hash[untyped, untyped]

    def inspect: () -> untyped

    def hash_emoji: (untyped emoji) -> untyped

    # @return [String] The custom ID of the select menu.
    attr_accessor custom_id: String

    # @return [Array<SelectMenu::Option>] The options of the select menu.
    attr_accessor options: ::Array[SelectMenu::Option]

    # @return [Integer] The minimum number of values.
    attr_accessor min_values: Integer

    # @return [Integer] The maximum number of values.
    attr_accessor max_values: Integer

    # @return [Boolean] Whether the select menu is disabled.
    attr_accessor disabled: bool

    # 
    # Represents an option of a select menu.
    class Option
      # 
      # Initialize a new option.
      # 
      # @param [String] label The label of the option.
      # @param [String] value The value of the option.
      # @param [String] description The description of the option.
      # @param [Discorb::Emoji] emoji The emoji of the option.
      # @param [Boolean] default Whether the option is default.
      def initialize: (
                        String label,
                        String value,
                        ?description: String?,
                        ?emoji: Discorb::Emoji?,
                        ?default: bool
                      ) -> void

      # 
      # Converts the option to a hash.
      # 
      # @see https://discord.com/developers/docs/interactions/message-components#select-menu-object-select-option-structure Official Discord API docs
      # @return [Hash] Hash representation of the option.
      def to_hash: () -> ::Hash[untyped, untyped]

      # 
      # Creates a new option from a hash.
      # 
      # @param [Hash] data A hash representing the option.
      # 
      # @return [Discorb::SelectMenu::Option] A new option.
      def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::SelectMenu::Option

      # @return [String] The label of the option.
      attr_accessor label: String

      # @return [String] The value of the option.
      attr_accessor value: String

      # @return [String] The description of the option.
      attr_accessor description: String

      # @return [Discorb::Emoji] The emoji of the option.
      attr_accessor emoji: Discorb::Emoji

      # @return [Boolean] Whether the option is default.
      attr_accessor default: bool
    end
  end

  class Dictionary[K, V]
    # 
    # Initialize a new Dictionary.
    # 
    # @param [Hash] hash A hash of items to add to the dictionary.
    # @param [Integer] limit The maximum number of items in the dictionary.
    # @param [false, Proc] sort Whether to sort the items in the dictionary.
    def initialize: (?::Hash[untyped, untyped] hash, ?limit: Integer?, ?sort: (bool | Proc)) -> void

    # 
    # Registers a new item in the dictionary.
    # 
    # @param [#to_s] id The ID of the item.
    # @param [Object] body The item to register.
    # 
    # @return [self] The dictionary.
    def register: (_ToS id, Object body) -> self

    # 
    # Merges another dictionary into this one.
    # 
    # @param [Discorb::Dictionary] other The dictionary to merge.
    def merge: (Discorb::Dictionary other) -> untyped

    # 
    # Removes an item from the dictionary.
    # 
    # @param [#to_s] id The ID of the item to remove.
    def remove: (_ToS id) -> untyped

    # 
    # Get an item from the dictionary.
    # 
    # @param [#to_s] id The ID of the item.
    # @return [Object] The item.
    # @return [nil] if the item was not found.
    # 
    # @overload get(index)
    #   @param [Integer] index The index of the item.
    # 
    #   @return [Object] The item.
    #   @return [nil] if the item is not found.
    def get: (K id) -> V?

    # 
    # Returns the values of the dictionary.
    # 
    # @return [Array] The values of the dictionary.
    def values: () -> ::Array[V]

    # 
    # Checks if the dictionary has an ID.
    # 
    # @param [#to_s] id The ID to check.
    # 
    # @return [Boolean] `true` if the dictionary has the ID, `false` otherwise.
    def has?: (_ToS id) -> bool

    # 
    # Send a message to the array of values.
    def method_missing: (untyped name) -> untyped

    def respond_to_missing?: (untyped name, untyped args, untyped kwargs) -> bool

    def inspect: () -> untyped

    # @return [Integer] The maximum number of items in the dictionary.
    attr_accessor limit: Integer
  end

  # 
  # Represents a permission per guild.
  # ## Flag fields
  # 
  # | Field | Value |
  # |-------|-------|
  # |`1 << 0`|`:create_instant_invite`|
  # |`1 << 1`|`:kick_members`|
  # |`1 << 2`|`:ban_members`|
  # |`1 << 3`|`:administrator`|
  # |`1 << 4`|`:manage_channels`|
  # |`1 << 5`|`:manage_guild`|
  # |`1 << 6`|`:add_reactions`|
  # |`1 << 7`|`:view_audit_log`|
  # |`1 << 8`|`:priority_speaker`|
  # |`1 << 9`|`:stream`|
  # |`1 << 10`|`:view_channel`|
  # |`1 << 11`|`:send_messages`|
  # |`1 << 12`|`:send_tts_messages`|
  # |`1 << 13`|`:manage_messages`|
  # |`1 << 14`|`:embed_links`|
  # |`1 << 15`|`:attach_files`|
  # |`1 << 16`|`:read_message_history`|
  # |`1 << 17`|`:mention_everyone`|
  # |`1 << 18`|`:use_external_emojis`|
  # |`1 << 19`|`:view_guild_insights`|
  # |`1 << 20`|`:connect`|
  # |`1 << 21`|`:speak`|
  # |`1 << 22`|`:mute_members`|
  # |`1 << 23`|`:deafen_members`|
  # |`1 << 24`|`:move_members`|
  # |`1 << 25`|`:use_vad`|
  # |`1 << 26`|`:change_nickname`|
  # |`1 << 27`|`:manage_nicknames`|
  # |`1 << 28`|`:manage_roles`|
  # |`1 << 29`|`:manage_webhooks`|
  # |`1 << 30`|`:manage_emojis`|
  # |`1 << 31`|`:use_slash_commands`|
  # |`1 << 32`|`:request_to_speak`|
  # |`1 << 34`|`:manage_threads`|
  # |`1 << 35`|`:use_public_threads`|
  # |`1 << 36`|`:use_private_threads`|
  class Permission < Discorb::Flag
  end

  # 
  # Represents a permission per channel.
  class PermissionOverwrite
    # 
    # Converts the permission overwrite to a hash.
    # 
    # @return [Hash] The permission overwrite as a hash.
    def to_hash: () -> ::Hash[untyped, untyped]

    # 
    # Union of the permission overwrites.
    # 
    # @param [Discorb::PermissionOverwrite] other The other permission overwrite.
    # 
    # @return [Discorb::PermissionOverwrite] The union of the permission overwrites.
    def +: (Discorb::PermissionOverwrite other) -> Discorb::PermissionOverwrite

    # 
    # Returns whether overwrite of the given field.
    # 
    # @param [Symbol] field The field to check.
    # 
    # @return [true, false, nil] Whether the field is allowed, denied or not set.
    def []: (Symbol field) -> bool?

    # 
    # Sets the given field to the given value.
    # 
    # @param [Symbol] key The field to set.
    # @param [Boolean] bool The value to set.
    def []=: (Symbol key, bool bool) -> untyped

    # 
    # Returns the value of the flag.
    def method_missing: (untyped method, ?untyped bool) -> untyped

    def respond_to_missing?: (untyped method, untyped _arg) -> bool

    # 
    # Initializes a permission overwrite from a hash.
    # 
    # @param [Hash] hash The hash to initialize the permission overwrite from.
    # 
    # @return [Discorb::PermissionOverwrite] The permission overwrite.
    def self.from_hash: (::Hash[untyped, untyped] hash) -> Discorb::PermissionOverwrite
  end

  # 
  # Class to handle rate limiting.
  # 
  # Handles application commands.
  module ApplicationCommand
    # 
    # Module to handle application commands.
    module Handler
      # 
      # Add new top-level command.
      # 
      # @param [String] command_name Command name.
      # @param [String] description Command description.
      # @param [Hash{String => Hash{:description => String, :optional => Boolean, :type => Object}}] options Command options.
      #   The key is the option name, the value is a hash with the following keys:
      # 
      #   | Key | Type | Description |
      #   | --- | --- | --- |
      #   | `:description` | `String` | Description of the option. |
      #   | `:required` | Whether the argument is required. `optional` will be used if not specified. |
      #   | `:optional` | Whether the argument is optional. `required` will be used if not specified. |
      #   | `:type` | `Object` | Type of the option. |
      #   | `:choice` | `Hash{String => String, Integer, Float}` | Type of the option. |
      #   | `:default` | `Object` | Default value of the option. |
      #   | `:channel_types` | `Array<Class<Discorb::Channel>>` | Type of the channel option. |
      #   | `:autocomplete` | `Proc` | Autocomplete function. |
      #   | `:range` | `Range` | Range of the option. Only valid for numeric options. (`:int`, `:float`) |
      # 
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Proc] block Command block.
      # 
      # @return [Discorb::ApplicationCommand::Command::SlashCommand] Command object.
      # 
      # @see file:docs/application_command.md#register-slash-command
      # @see file:docs/cli/setup.md
      def slash: (
                   String command_name,
                   String description,
                   ?::Hash[String, String | Integer | Float] options,
                   ?guild_ids: (::Array[untyped] | bool)?
                 ) -> Discorb::ApplicationCommand::Command::SlashCommand

      # 
      # Add new command with group.
      # 
      # @param [String] command_name Command name.
      # @param [String] description Command description.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # 
      # @yield Block to yield with the command.
      # @yieldparam [Discorb::ApplicationCommand::Command::GroupCommand] group Group command.
      # 
      # @return [Discorb::ApplicationCommand::Command::GroupCommand] Command object.
      # 
      # @see file:docs/slash_command.md
      # @see file:docs/cli/setup.md
      def slash_group: (String command_name, String description, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::ApplicationCommand::Command::GroupCommand group) -> void } -> Discorb::ApplicationCommand::Command::GroupCommand

      # 
      # Add message context menu command.
      # 
      # @param [String] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Proc] block Command block.
      # @yield [interaction, message] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::Message] message Message object.
      # 
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def message_command: (String command_name, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::Message message) -> void } -> Discorb::ApplicationCommand::Command

      # 
      # Add user context menu command.
      # 
      # @param [String] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Proc] block Command block.
      # @yield [interaction, user] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::User] user User object.
      # 
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def user_command: (String command_name, ?guild_ids: (::Array[untyped] | bool)?) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::User user) -> void } -> Discorb::ApplicationCommand::Command

      # 
      # Setup commands.
      # @see Client#initialize
      # 
      # @param [String] token Bot token.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to use as default. If `false` is given, it will be global command.
      # 
      # @note `token` parameter only required if you don't run client.
      def setup_commands: (?String? token, ?guild_ids: (::Array[untyped] | bool)?) -> untyped
    end

    # 
    # Represents a application command.
    # @abstract
    class Command < Discorb::DiscordModel
      # @return [String] The name of the command.
      attr_reader name: String

      # @return [Array<#to_s>] The guild ids that the command is enabled in.
      attr_reader guild_ids: ::Array[untyped]

      # @return [Proc] The block of the command.
      attr_reader block: Proc

      # @return [:chat_input, :user, :message] The type of the command.
      attr_reader type: Symbol

      # @return [Integer] The raw type of the command.
      attr_reader type_raw: Integer

      # @return [Discorb::Dictionary{Discorb::Snowflake, :global => Discorb::Snowflake}] The ID mapping.
      attr_reader id_map: Discorb::Dictionary[Discorb::Snowflake, Symbol, Discorb::Snowflake]

      # 
      # Represents the slash command.
      class SlashCommand < Discorb::ApplicationCommand::Command
        # 
        # Returns the commands name.
        # 
        # @return [String] The name of the command.
        def to_s: () -> String

        # @return [String] The description of the command.
        attr_reader description: String

        # @return [Hash{String => Hash}] The options of the command.
        attr_reader options: ::Hash[String, ::Hash[untyped, untyped]]
      end

      # 
      # Represents the command with subcommands.
      class GroupCommand < Discorb::ApplicationCommand::Command
        # 
        # Add new subcommand.
        # 
        # @param (see Discorb::ApplicationCommand::Handler#slash)
        # @return [Discorb::ApplicationCommand::Command::SlashCommand] The added subcommand.
        def slash: (String command_name, String description, ?::Hash[String, String | Integer | Float] options) -> Discorb::ApplicationCommand::Command::SlashCommand

        # 
        # Add new subcommand group.
        # 
        # @param [String] command_name Group name.
        # @param [String] description Group description.
        # 
        # @yield Block to yield with the command.
        # @yieldparam [Discorb::ApplicationCommand::Command::SubcommandGroup] group Group command.
        # 
        # @return [Discorb::ApplicationCommand::Command::SubcommandGroup] Command object.
        # 
        # @see file:docs/slash_command.md
        def group: (String command_name, String description) ?{ (Discorb::ApplicationCommand::Command::SubcommandGroup group) -> void } -> Discorb::ApplicationCommand::Command::SubcommandGroup

        # 
        # Returns the command name.
        # 
        # @return [String] The command name.
        def to_s: () -> String

        # @return [Array<Discorb::ApplicationCommand::Command::SlashCommand, Discorb::ApplicationCommand::Command::SubcommandGroup>] The subcommands of the command.
        attr_reader commands: ::Array[(Discorb::ApplicationCommand::Command::SlashCommand | Discorb::ApplicationCommand::Command::SubcommandGroup)]

        # @return [String] The description of the command.
        attr_reader description: String
      end

      # 
      # Represents the subcommand group.
      class SubcommandGroup < Discorb::ApplicationCommand::Command::GroupCommand
        # 
        # Add new subcommand.
        # @param (see Discorb::ApplicationCommand::Handler#slash)
        # @return [Discorb::ApplicationCommand::Command::SlashCommand] The added subcommand.
        def slash: (String command_name, String description, ?::Hash[String, String | Integer | Float] options) -> Discorb::ApplicationCommand::Command::SlashCommand

        # @return [Array<Discorb::ApplicationCommand::Command::SlashCommand>] The subcommands of the command.
        attr_reader commands: ::Array[Discorb::ApplicationCommand::Command::SlashCommand]
      end
    end
  end

  # 
  # Represents a Discord application.
  class Application < Discorb::DiscordModel
    # @return [Discorb::Snowflake] The application's ID.
    attr_reader id: Discorb::Snowflake

    # @return [String] The application's name.
    attr_reader name: String

    # @return [Discorb::Asset] The application's icon.
    attr_reader icon: Discorb::Asset

    # @return [String] The application's description.
    attr_reader description: String

    # @return [String] The application's summary.
    attr_reader summary: String

    # @return [String] The application's public key.
    attr_reader verify_key: String

    # @return [Discorb::User] The application's owner.
    attr_reader owner: Discorb::User

    # @return [Discorb::Application::Team] The application's team.
    attr_reader team: Discorb::Application::Team

    # @return [Boolean] Whether the application's bot is public.
    attr_reader bot_public: bool

    # @return [Boolean] Whether the application's bot requires a code grant.
    attr_reader bot_require_code_grant: bool

    # @return [Discorb::Application::Flag] The application's flags.
    attr_reader flags: Discorb::Application::Flag

    # 
    # Represents a flag for an application.
    # ## Flag fields
    # 
    # | Field|Value|
    # |---|---|
    # | `1 << 12` | `:gateway_presence` |
    # | `1 << 13` | `:gateway_presence_limited` |
    # | `1 << 14` | `:gateway_guild_members` |
    # | `1 << 15` | `:gateway_guild_members_limited` |
    # | `1 << 16` | `:verification_pending_guild_limit` |
    # | `1 << 17` | `:embedded` |
    # | `1 << 18` | `:gateway_message_content` |
    # | `1 << 19` | `:gateway_message_content_limited` |
    class Flag < Discorb::Flag
    end

    # 
    # Represents a team for an application.
    class Team < Discorb::DiscordModel
      # 
      # The team's owner.
      # 
      # @return [Discorb::Application::Team::Member] The team's owner.
      def owner: () -> Discorb::Application::Team::Member

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The team's ID.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Asset] The team's icon.
      attr_reader icon: Discorb::Asset

      # @return [String] The team's name.
      attr_reader name: String

      # @return [Discorb::Snowflake] The team's owner's ID.
      attr_reader owner_user_id: Discorb::Snowflake

      # @return [Discorb::Application::Team::Member] The team's member.
      attr_reader members: Discorb::Application::Team::Member

      # 
      # Represents a member of team.
      class Member < Discorb::DiscordModel
        def initialize: (untyped client, untyped team, untyped data) -> void

        def pending?: () -> bool

        def accepted?: () -> bool

        def inspect: () -> untyped

        def owner?: () -> bool

        def ==: (untyped other) -> untyped

        # @return [Discorb::User] The user.
        attr_reader user: Discorb::User

        # @return [Snowflake] The ID of member's team.
        attr_reader team_id: Snowflake

        # @return [:invited, :accepted] The member's membership state.
        attr_reader membership_state: Symbol

        # @return [Array<Symbol>] The permissions of the member.
        # @note This always return `:*`.
        attr_reader permissions: ::Array[Symbol]
      end
    end
  end

  # 
  # A table of emoji names and their unicode values.
  module EmojiTable
    DISCORD_TO_UNICODE: untyped
    UNICODE_TO_DISCORD: untyped
    SKIN_TONES: untyped
  end

  # 
  # Represents a integration.
  class Integration < Discorb::DiscordModel
    # 
    # Delete the integration.
    # 
    # @param [String] reason The reason for deleting the integration.
    def delete!: (?reason: String?) -> untyped
    # @return [Discorb::Snowflake] The ID of the integration.
    attr_reader id: Discorb::Snowflake

    # @return [Symbol] The type of integration.
    attr_reader type: Symbol

    # @return [Boolean] Whether the integration is enabled.
    attr_reader enabled: bool

    # @return [Boolean] Whether the integration is syncing.
    attr_reader syncing: bool

    # @return [Boolean] Whether the integration is enabled emoticons.
    attr_reader enable_emoticons: bool

    # @return [:remove_role, :kick] The behavior of the integration when it expires.
    attr_reader expire_behavior: Symbol

    # @return [Integer] The grace period of the integration.
    attr_reader expire_grace_period: Integer

    # @return [Discorb::User] The user for the integration.
    attr_reader user: Discorb::User

    # @return [Discorb::Integration::Account] The account for the integration.
    attr_reader account: Discorb::Integration::Account

    # @return [Integer] The number of subscribers for the integration.
    attr_reader subscriber_count: Integer

    # @return [Boolean] Whether the integration is revoked.
    attr_reader revoked: bool

    # @return [Discorb::Application] The application for the integration.
    attr_reader application: Discorb::Application

    # 
    # Represents an account for an integration.
    class Account < Discorb::DiscordModel
      # @return [String] The ID of the account.
      attr_reader id: String

      # @return [String] The name of the account.
      attr_reader name: String
    end
  end

  class VoiceState < Discorb::DiscordModel
    # @return [Discorb::Snowflake] The ID of the guild this voice state is for.
    attr_reader session_id: Discorb::Snowflake

    # @return [Time] The time at which the user requested to speak.
    attr_reader request_to_speak_timestamp: Time

    # @return [Boolean] Whether the user is deafened.
    attr_reader self_deaf: bool

    # @return [Boolean] Whether the user is muted.
    attr_reader self_mute: bool

    # @return [Boolean] Whether the user is streaming.
    attr_reader self_stream: bool

    # @return [Boolean] Whether the user is video-enabled.
    attr_reader self_video: bool

    # @return [Boolean] Whether the user is suppressed. (Is at audience)
    attr_reader suppress: bool

    # @return [Boolean] Whether the user is deafened.
    attr_reader deaf?: bool

    # @return [Boolean] Whether the user is muted.
    attr_reader mute?: bool

    # @return [Boolean] Whether the user is deafened on the server.
    attr_reader server_deaf?: bool

    # @return [Boolean] Whether the user is muted on the server.
    attr_reader server_mute?: bool

    # @macro client_cache
    # @return [Discorb::Guild] The guild this voice state is for.
    attr_reader guild: Discorb::Guild?

    # @macro client_cache
    # @return [Discorb::Channel] The channel this voice state is for.
    attr_reader channel: Discorb::Channel?

    # @macro client_cache
    # @return [Discorb::User] The user this voice state is for.
    attr_reader user: Discorb::User?
  end

  # 
  # Represents a stage instance of a voice state.
  class StageInstance < Discorb::DiscordModel
    # 
    # Edits the stage instance.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] topic The new topic of the stage instance.
    # @param [:public, :guild_only] privacy_level The new privacy level of the stage instance.
    # @param [String] reason The reason for editing the stage instance.
    def edit: (?topic: String, ?privacy_level: Symbol, ?reason: String?) -> untyped

    # 
    # Deletes the stage instance.
    # 
    # @param [String] reason The reason for deleting the stage instance.
    def delete!: (?reason: String?) -> untyped
    # @return [Discorb::Snowflake] The ID of the guild this voice state is for.
    attr_reader id: Discorb::Snowflake

    # @return [String] The topic of the stage instance.
    attr_reader topic: String

    # @return [:public, :guild_only] The privacy level of the stage instance.
    attr_reader privacy_level: Symbol
  end

  # 
  # Represents a voice region.
  class VoiceRegion < Discorb::DiscordModel
    # @return [Discorb::Snowflake] The ID of the voice region.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the voice region.
    attr_reader name: String

    # @return [Boolean] Whether the voice region is VIP.
    attr_reader vip: bool

    # @return [Boolean] Whether the voice region is optimal.
    attr_reader optimal: bool

    # @return [Boolean] Whether the voice region is deprecated.
    attr_reader deprecated: bool

    # @return [Boolean] Whether the voice region is custom.
    attr_reader custom: bool
  end

  # 
  # Represents a event handler.
  # This class shouldn't be instantiated directly.
  # Use {Client#on} instead.
  class EventHandler
    def initialize: (untyped block, _ToS id, untyped metadata) -> void

    def inspect: () -> untyped

    # 
    # Calls the block associated with the event.
    def call: () -> untyped

    # @return [Proc] the block to be called.
    attr_reader block: Proc

    # @return [Symbol] the event id.
    attr_reader id: Symbol

    # @return [Hash] the event metadata.
    attr_reader metadata: ::Hash[untyped, untyped]

    # @return [Boolean] whether the event is once or not.
    attr_reader once: bool
  end

  # 
  # Represents a guild template.
  class GuildTemplate < Discorb::DiscordModel
    # 
    # Edit the template.
    # @macro async
    # @macro http
    # @macro edit
    # 
    # @param [String] name The new name of the template.
    # @param [String] description The new description of the template.
    def edit: (?String? name, ?String description) -> untyped

    # 
    # Update the template.
    # @macro async
    # @macro http
    def update: () -> untyped

    # 
    # Delete the template.
    # @macro async
    # @macro http
    def delete!: () -> untyped
    # @return [String] The code of the template.
    attr_reader code: String

    # @return [String] The name of the template.
    attr_reader name: String

    # @return [String] The description of the template.
    attr_reader description: String

    # @return [Integer] The number of times this template has been used.
    attr_reader usage_count: Integer

    # @return [Discorb::User] The user who created this template.
    attr_reader creator: Discorb::User

    # @return [Time] The time this template was created.
    attr_reader created_at: Time

    # @return [Time] The time this template was last updated.
    attr_reader updated_at: Time

    # @return [Discorb::Guild] The guild where the template was created.
    attr_reader source_guild_id: Discorb::Guild

    # @return [Discorb::GuildTemplate::TemplateGuild] The guild where the template was created.
    attr_reader serialized_source_guild: Discorb::GuildTemplate::TemplateGuild

    # @return [Boolean] Whether this template is dirty.
    attr_reader is_dirty: bool

    # @macro client_cache
    # @return [Discorb::Guild] The guild this template is based on.
    # @return [nil] Client wasn't able to find the guild this template is based on.
    attr_reader source_guild: Discorb::Guild?

    # 
    # Represents a guild in guild template.
    class TemplateGuild < Discorb::DiscordModel
      # @return [String] The name of the guild.
      attr_reader name: String

      # @return [Integer] The AFK timeout of the guild.
      attr_reader afk_timeout: Integer

      # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Role}] A dictionary of roles in the guild.
      attr_reader roles: Discorb::Dictionary[Discorb::Snowflake, Discorb::Role]

      # @return [Discorb::SystemChannelFlag] The flag for the system channel.
      attr_reader system_channel_flags: Discorb::SystemChannelFlag

      # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::GuildChannel}] A dictionary of channels in the guild.
      attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::GuildChannel]

      # @return [String] The description of the guild.
      attr_reader description: String

      # @return [Symbol] The preffered language of the guild.
      # @note This modifies the language code, `-` will be replaced with `_`.
      attr_reader preferred_locale: Symbol

      # @return [:none, :low, :medium, :high, :very_high] The verification level of the guild.
      attr_reader verification_level: Symbol

      # @return [:all_messages, :only_mentions] The default message notification level of the guild.
      attr_reader default_message_notifications: Symbol

      # @return [:disabled_in_text, :members_without_roles, :all_members] The explict content filter level of the guild.
      attr_reader explicit_content_filter: Symbol

      # @return [Boolean] Whether the guild enabled the widget.
      attr_reader widget_enabled: bool

      # 
      # Represents a role in guild template.
      class Role < Discorb::DiscordModel
        # @return [String] The name of the role.
        attr_reader name: String

        # @return [Discorb::Permission] The permissions of the role.
        attr_reader permissions: Discorb::Permission

        # @return [Discorb::Color] The color of the role.
        attr_reader color: Discorb::Color
      end

      # 
      # Represents a channel in guild template.
      class Channel < Discorb::DiscordModel
        # @return [String] The name of the channel.
        attr_reader name: String

        # @return [Integer] The position of the channel.
        attr_reader position: Integer

        # @return [String] The type of the channel.
        attr_reader topic: String

        # @return [Integer] The bitrate of the channel.
        attr_reader bitrate: Integer

        # @return [Integer] The user limit of the channel.
        attr_reader user_limit: Integer

        # @return [Boolean] Whether the channel is nsfw.
        attr_reader nsfw: bool

        # @return [Integer] The rate limit of the channel.
        attr_reader rate_limit_per_user: Integer

        # @return [Class] The class of the channel.
        attr_reader type: Class
      end
    end
  end

  # 
  # Represents an activity for Gateway Command.
  class Activity
    # 
    # Initializes a new Activity.
    # 
    # @param [String] name The name of the activity.
    # @param [:playing, :streaming, :listening, :watching, :competing] type The type of activity.
    # @param [String] url The URL of the activity.
    def initialize: (String name, ?Symbol _type, ?String? url) -> void

    # 
    # Converts the activity to a hash.
    # 
    # @return [Hash] A hash representation of the activity.
    def to_hash: () -> ::Hash[untyped, untyped]

    def inspect: () -> untyped
  end

  # 
  # Represents a user interaction with the bot.
  class Interaction < Discorb::DiscordModel
    # @return [Discorb::Snowflake] The ID of the interaction.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::Snowflake] The ID of the application that created the interaction.
    attr_reader application_id: Discorb::Snowflake

    # @return [Symbol] The type of interaction.
    attr_reader type: Symbol

    # @return [Discorb::Member] The member that created the interaction.
    attr_reader member: Discorb::Member

    # @return [Discorb::User] The user that created the interaction.
    attr_reader user: Discorb::User

    # @return [Integer] The type of interaction.
    # @note This is always `1` for now.
    attr_reader version: Integer

    # @return [String] The token for the interaction.
    attr_reader token: String

    # 
    # A module for response with source.
    module SourceResponse
      # 
      # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
      # 
      # @macro async
      # @macro http
      # 
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      def defer_source: (?ephemeral: bool) -> untyped

      # 
      # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
      # 
      # @macro async
      # @macro http
      # 
      # @param [String] content The content of the response.
      # @param [Boolean] tts Whether to send the message as text-to-speech.
      # @param [Discorb::Embed] embed The embed to send.
      # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
      # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
      # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      # 
      # @return [Discorb::Interaction::SourceResponse::CallbackMessage, Discorb::Webhook::Message] The callback message.
      def post: (
                  ?String? content,
                  ?tts: bool,
                  ?embed: Discorb::Embed?,
                  ?embeds: ::Array[Discorb::Embed]?,
                  ?allowed_mentions: Discorb::AllowedMentions?,
                  ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                  ?ephemeral: bool
                ) -> (Discorb::Interaction::SourceResponse::CallbackMessage | Discorb::Webhook::Message)

      class CallbackMessage
        # 
        # Edits the callback message.
        # @macro async
        # @macro http
        # @macro edit
        # 
        # @param [String] content The new content of the message.
        # @param [Discorb::Embed] embed The new embed of the message.
        # @param [Array<Discorb::Embed>] embeds The new embeds of the message.
        # @param [Array<Discorb::Attachment>] attachments The attachments to remain.
        # @param [Discorb::File] file The file to send.
        # @param [Array<Discorb::File>] files The files to send.
        def edit: (
                    ?String content,
                    ?embed: Discorb::Embed,
                    ?embeds: ::Array[Discorb::Embed],
                    ?file: Discorb::File,
                    ?files: ::Array[Discorb::File],
                    ?attachments: ::Array[Discorb::Attachment]
                  ) -> untyped

        # 
        # Deletes the callback message.
        # @note This will fail if the message is ephemeral.
        def delete!: () -> untyped
      end
    end

    # 
    # A module for response with update.
    module UpdateResponse
      # 
      # Response with `DEFERRED_UPDATE_MESSAGE`(`6`).
      # 
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      def defer_update: (?ephemeral: bool) -> untyped

      # 
      # Response with `UPDATE_MESSAGE`(`7`).
      # 
      # @macro async
      # @macro http
      # 
      # @param [String] content The content of the response.
      # @param [Boolean] tts Whether to send the message as text-to-speech.
      # @param [Discorb::Embed] embed The embed to send.
      # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
      # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
      # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      def edit: (
                  String content,
                  ?tts: bool,
                  ?embed: Discorb::Embed?,
                  ?embeds: ::Array[Discorb::Embed]?,
                  ?allowed_mentions: Discorb::AllowedMentions?,
                  ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                  ?ephemeral: bool
                ) -> untyped
    end
  end

  # 
  # Represents a command interaction.
  class CommandInteraction < Discorb::Interaction
    include Discorb::Interaction::SourceResponse
    # 
    # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
    # 
    # @macro async
    # @macro http
    # 
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    def defer_source: (?ephemeral: bool) -> untyped

    # 
    # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
    # 
    # @macro async
    # @macro http
    # 
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    # 
    # @return [Discorb::Interaction::SourceResponse::CallbackMessage, Discorb::Webhook::Message] The callback message.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> (Discorb::Interaction::SourceResponse::CallbackMessage | Discorb::Webhook::Message)

    # 
    # Represents a slash command interaction.
    class SlashCommand < Discorb::CommandInteraction
    end

    # 
    # Represents a user context menu interaction.
    class UserMenuCommand < Discorb::CommandInteraction      # @return [Discorb::Member, Discorb::User] The target user.
      attr_reader target: (Discorb::Member | Discorb::User)
    end

    # 
    # Represents a message context menu interaction.
    class MessageMenuCommand < Discorb::CommandInteraction      # @return [Discorb::Message] The target message.
      attr_reader target: Discorb::Message
    end
  end

  # 
  # Represents a message component interaction.
  # @abstract
  class MessageComponentInteraction < Discorb::Interaction
    include Discorb::Interaction::SourceResponse
    include Discorb::Interaction::UpdateResponse

    # 
    # Response with `DEFERRED_UPDATE_MESSAGE`(`6`).
    # 
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    def defer_update: (?ephemeral: bool) -> untyped

    # 
    # Response with `UPDATE_MESSAGE`(`7`).
    # 
    # @macro async
    # @macro http
    # 
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    def edit: (
                String content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> untyped

    # 
    # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
    # 
    # @macro async
    # @macro http
    # 
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    def defer_source: (?ephemeral: bool) -> untyped

    # 
    # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
    # 
    # @macro async
    # @macro http
    # 
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    # 
    # @return [Discorb::Interaction::SourceResponse::CallbackMessage, Discorb::Webhook::Message] The callback message.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> (Discorb::Interaction::SourceResponse::CallbackMessage | Discorb::Webhook::Message)

    # @return [String] The content of the response.
    attr_reader custom_id: String

    # @return [Discorb::Message] The target message.
    attr_reader message: Discorb::Message

    # 
    # Represents a button interaction.
    class Button < Discorb::MessageComponentInteraction      # @return [String] The custom id of the button.
      attr_reader custom_id: String
    end

    # 
    # Represents a select menu interaction.
    class SelectMenu < Discorb::MessageComponentInteraction      # @return [String] The custom id of the select menu.
      attr_reader custom_id: String

      # @return [Array<String>] The selected options.
      attr_reader values: ::Array[String]

      # @!attribute [r] value
      #   @return [String] The first selected value.
      attr_reader value: untyped
    end
  end

  # 
  # Represents auto complete interaction.
  class AutoComplete < Discorb::Interaction

  end

  # HTTP client for discorb.
  class HTTP
  end
  
  # Logger for discorb.
  class Logger
  end
end

class Time
  # 
  # Format a time object to a Discord formatted string.
  # 
  # @param ["f", "F", "d", "D", "t", "T", "R"] type The format to use.
  # 
  # @return [String] The formatted time.
  def to_df: (?("f" | "F" | "d" | "D" | "t" | "T" | "R")? _type) -> String
end

module Async
  class Task
  end
end

module Net
  class HTTPResponse
  end
end