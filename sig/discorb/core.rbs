module Discorb
  #
  # Represents a client user.
  class ClientUser < Discorb::User
    #
    # Edit the client user.
    # @async
    # @macro edit
    #
    # @param [String] name The new username.
    # @param [Discorb::Image] avatar The new avatar.
    #
    # @return [Async::Task<void>] The task.
    def edit: (?name: String, ?avatar: Discorb::Image) -> Async::Task[void]
  end

  #
  # Represents a single asset.
  class Asset < Discorb::DiscordModel
    #
    # Initialize a new instance of the Asset class.
    # @private
    #
    # @param [Discorb::Client] client The client that instantiated the object.
    # @param [Hash] data The data of the object.
    def initialize: (untyped target, untyped hash, ?path: untyped) -> void

    #
    # URL of the asset.
    #
    # @param [String] image_format The image format.
    # @param [Integer] size The size of the image.
    #
    # @return [String] URL of the asset.
    def url: (?image_format: String?, ?size: Integer) -> String

    def inspect: () -> untyped

    def endpoint: () -> untyped

    # @return [String] The hash of asset.
    attr_reader hash: String

    # @return [Boolean] Whether the asset is animated.
    attr_reader animated?: bool
  end

  #
  # Represents a default avatar.
  class DefaultAvatar < Discorb::DiscordModel
    #
    # Initialize a new instance of the DefaultAvatar class.
    # @private
    def initialize: (untyped discriminator) -> void

    #
    # Returns the URL of the avatar.
    #
    # @param [String] image_format The image format. This is compatible with {Asset#url}, will be ignored.
    # @param [Integer] size The size of the image. This is compatible with {Asset#url}, will be ignored.
    #
    # @return [String] URL of the avatar.
    #
    # rubocop: disable Lint/UnusedMethodArgument
    def url: (?image_format: String?, ?size: Integer) -> String

    def inspect: () -> untyped

    # @return [false] For compatibility with {Asset}, always `false`.
    attr_reader animated?: bool
  end

  #
  # Represents RGB color.
  class Color
    #
    # Create a color from a Integer.
    #
    # @param [Integer] value A color value.
    def initialize: (Integer value) -> void

    #
    # Integerize a color.
    #
    # @return [Integer] A color value.
    def to_i: () -> Integer

    #
    # Convert a color to a hexadecimal value.
    #
    # @return [String] A hexadecimal value.
    def to_hex: () -> String

    #
    # Convert a color to RGB array.
    #
    # @return [Array(Integer, Integer, Integer)] A RGB array.
    def to_rgb: () -> [Integer, Integer, Integer]

    #
    # Convert a color to RGB hash.
    #
    # @return [Hash{:r, :g, :b => Integer}] A RGB hash.
    def to_rgb_hash: () -> { r: Integer, g: Integer, b: Integer}

    #
    # Converts a color to a `#000000` string.
    #
    # @return [String] Converted string.
    def to_s: () -> String

    def inspect: () -> untyped

    #
    # Create a color from a hexadecimal string.
    #
    # @param [String] hex A hexadecimal string.
    #
    # @return [Discorb::Color] A color object.
    def self.from_hex: (String hex) -> Discorb::Color

    #
    # Create a color from a RGB array.
    #
    # @param [Integer] red A red value.
    # @param [Integer] green A green value.
    # @param [Integer] blue A blue value.
    #
    # @return [Discorb::Color] A color object.
    def self.from_rgb: (Integer red, Integer green, Integer blue) -> Discorb::Color

    #
    # Create a color from a Discord's color.
    # Currently these colors are supported:
    #
    # | Color Name | Hexadecimal |
    # |------------|------------|
    # | `:teal` | `#1abc9c` |
    # | `:dark_teal` | `#11806a` |
    # | `:green` | `#2ecc71` |
    # | `:dark_green` | `#1f8b4c` |
    # | `:blue` | `#3498db` |
    # | `:dark_blue` | `#206694` |
    # | `:purple` | `#9b59b6` |
    # | `:dark_purple` | `#71368a` |
    # | `:magenta` | `#e91e63` |
    # | `:dark_magenta` | `#ad1457` |
    # | `:gold` | `#f1c40f` |
    # | `:dark_gold` | `#c27c0e` |
    # | `:orange` | `#e67e22` |
    # | `:dark_orange` | `#a84300` |
    # | `:red` | `#e74c3c` |
    # | `:dark_red` | `#992d22` |
    # | `:lighter_grey` | `#95a5a6` |
    # | `:lighter_gray` | `#95a5a6` |
    # | `:dark_grey` | `#607d8b` |
    # | `:dark_gray` | `#607d8b` |
    # | `:light_grey` | `#979c9f` |
    # | `:light_gray` | `#979c9f` |
    # | `:darker_grey` | `#546e7a` |
    # | `:darker_gray` | `#546e7a` |
    # | `:og_blurple` | `#7289da` |
    # | `:blurple` | `#5865f2` |
    # | `:greyple` | `#99aab5` |
    # | `:dark_theme` | `#36393f` |
    # | `:fuchsia` | `#eb459e` |
    # | `:dark_teal` | `#11806a` |
    # | `:green` | `#2ecc71` |
    # | `:dark_green` | `#1f8b4c` |
    # | `:blue` | `#3498db` |
    # | `:dark_blue` | `#206694` |
    # | `:purple` | `#9b59b6` |
    # | `:dark_purple` | `#71368a` |
    # | `:magenta` | `#e91e63` |
    # | `:dark_magenta` | `#ad1457` |
    # | `:gold` | `#f1c40f` |
    # | `:dark_gold` | `#c27c0e` |
    # | `:orange` | `#e67e22` |
    # | `:dark_orange` | `#a84300` |
    # | `:red` | `#e74c3c` |
    # | `:dark_red` | `#992d22` |
    # | `:lighter_grey` | `#95a5a6` |
    # | `:lighter_gray` | `#95a5a6` |
    # | `:dark_grey` | `#607d8b` |
    # | `:dark_gray` | `#607d8b` |
    # | `:light_grey` | `#979c9f` |
    # | `:light_gray` | `#979c9f` |
    # | `:darker_grey` | `#546e7a` |
    # | `:darker_gray` | `#546e7a` |
    # | `:og_blurple` | `#7289da` |
    # | `:blurple` | `#5865f2` |
    # | `:greyple` | `#99aab5` |
    # | `:dark_theme` | `#36393f` |
    # | `:fuchsia` | `#eb459e` |
    #
    # @param [Symbol] color A Discord color name.
    #
    # @return [Discorb::Color] A color object.
    def self.[]: (Symbol color) -> Discorb::Color

    # Returns the value of attribute value.
    attr_accessor value: untyped
  end

  #
  # Represents an embed of discord.
  class Embed
    #
    # Initialize a new Embed object.
    #
    # @param [String] title The title of embed.
    # @param [String] description The description of embed.
    # @param [Discorb::Color] color The color of embed.
    # @param [String] url The url of embed.
    # @param [Time] timestamp The timestamp of embed.
    # @param [Discorb::Embed::Author] author The author field of embed.
    # @param [Array<Discorb::Embed::Field>] fields The fields of embed.
    # @param [Discorb::Embed::Footer] footer The footer of embed.
    # @param [Discorb::Embed::Image, String] image The image of embed.
    # @param [Discorb::Embed::Thumbnail, String] thumbnail The thumbnail of embed.
    def initialize: (
                      ?String? title,
                      ?String? description,
                      ?color: Discorb::Color?,
                      ?url: String?,
                      ?timestamp: Time?,
                      ?author: Discorb::Embed::Author?,
                      ?fields: ::Array[Discorb::Embed::Field]?,
                      ?footer: Discorb::Embed::Footer?,
                      ?image: (Discorb::Embed::Image | String)?,
                      ?thumbnail: (Discorb::Embed::Thumbnail | String)?
                    ) -> void

    #
    # Initialize embed from hash.
    # @private
    #
    # @param [Hash] data The hash data to initialize embed.
    def initialize_hash: (::Hash[untyped, untyped] data) -> untyped

    def inspect: () -> untyped

    #
    # Convert embed to hash.
    #
    # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-structure Offical Discord API Docs
    # @return [Hash] Converted embed.
    def to_hash: () -> ::Hash[untyped, untyped]

    def self.from_hash: (untyped data) -> untyped

    # @return [String, nil] The title of embed.
    attr_accessor title: String?

    # @return [String, nil] The description of embed.
    attr_accessor description: String?

    # @return [String, nil] The url of embed.
    attr_accessor url: String?

    # @return [Time, nil] The timestamp of embed.
    attr_accessor timestamp: Time?

    # @return [Discorb::Color, nil] The color of embed.
    attr_accessor color: Discorb::Color?

    # @return [Discorb::Embed::Author, nil] The author of embed.
    attr_accessor author: Discorb::Embed::Author?

    # @return [Array<Discorb::Embed::Field>] The fields of embed.
    attr_accessor fields: ::Array[Discorb::Embed::Field]

    # @return [Discorb::Embed::Footer, nil] The footer of embed.
    attr_accessor footer: Discorb::Embed::Footer?

    # @return [Symbol] The type of embed.
    attr_reader type: Symbol

    # @return [Discorb::Embed::Image] The image of embed.
    attr_accessor image: Discorb::Embed::Image

    # @return [Discorb::Embed::Thumbnail] The thumbnail of embed.
    attr_accessor thumbnail: Discorb::Embed::Thumbnail

    #
    # Represents an entry in embed.
    # @abstract
    # @private
    class Entry
      def inspect: () -> untyped
    end

    #
    # Represents an author of embed.
    class Author < Discorb::Embed::Entry
      #
      # Initialize a new Author object.
      #
      # @param [String] name The name of author.
      # @param [String] url The url of author.
      # @param [String] icon The icon url of author.
      def initialize: (String name, ?url: String?, ?icon: String?) -> void

      #
      # Convert author to hash.
      #
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-author-structure
      #   Offical Discord API Docs
      # @return [Hash] Converted author.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The name of author.
      attr_accessor name: String

      # @return [String, nil] The url of author.
      attr_accessor url: String?

      # @return [String, nil] The icon url of author.
      attr_accessor icon: String?
    end

    #
    # Represemts a footer of embed.
    class Footer < Discorb::Embed::Entry
      #
      # Initialize a new Footer object.
      #
      # @param [String] text The text of footer.
      # @param [String] icon The icon url of footer.
      def initialize: (String text, ?icon: String?) -> void

      #
      # Convert footer to hash.
      #
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-footer-structure
      #   Offical Discord API Docs
      # @return [Hash] Converted footer.
      def to_hash: () -> ::Hash[untyped, untyped]

      # Returns the value of attribute text.
      attr_accessor text: untyped

      # Returns the value of attribute icon.
      attr_accessor icon: untyped
    end

    #
    # Represents a field of embed.
    class Field < Discorb::Embed::Entry
      #
      # Initialize a new Field object.
      #
      # @param [String] name The name of field.
      # @param [String] value The value of field.
      # @param [Boolean] inline Whether the field is inline.
      def initialize: (String name, String value, ?inline: bool) -> void

      #
      # Convert field to hash.
      #
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure
      #   Offical Discord API Docs
      # @return [Hash] Converted field.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The name of field.
      attr_accessor name: String

      # @return [String] The value of field.
      attr_accessor value: String

      # @return [Boolean] Whether the field is inline.
      attr_accessor inline: bool
    end

    #
    # Represents an image of embed.
    class Image < Discorb::Embed::Entry
      #
      # Initialize a new Image object.
      #
      # @param [String] url URL of image.
      def initialize: (String url) -> void

      #
      # Convert image to hash for sending.
      #
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-image-structure
      #   Offical Discord API Docs
      # @return [Hash] Converted image.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The url of image.
      attr_accessor url: String

      # @return [String] The proxy url of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader proxy_url: String?

      # @return [Integer] The height of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader height: Integer?

      # @return [Integer] The width of image.
      # @return [nil] The Image object wasn't created from gateway.
      attr_reader width: Integer?
    end

    #
    # Represents a thumbnail of embed.
    class Thumbnail < Discorb::Embed::Entry
      #
      # Initialize a new Thumbnail object.
      #
      # @param [String] url URL of thumbnail.
      def initialize: (String url) -> void

      #
      # Convert thumbnail to hash for sending.
      #
      # @see https://discord.com/developers/docs/resources/channel#embed-object-embed-thumbnail-structure
      #   Offical Discord API Docs
      # @return [Hash] Converted thumbnail.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [String] The url of thumbnail.
      attr_accessor url: String

      # @return [String] The proxy url of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader proxy_url: String?

      # @return [Integer] The height of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader height: Integer?

      # @return [Integer] The width of thumbnail.
      # @return [nil] The Thumbnail object wasn't created from gateway.
      attr_reader width: Integer?
    end

    #
    # Represents a video of embed.
    class Video < Discorb::Embed::Entry
      #
      # Initialize a new Video object.
      # @private
      #
      # @param [Hash] data The data of video.
      def initialize: (::Hash[untyped, untyped] data) -> void

      # @return [String] The url of video.
      attr_reader url: String

      # @return [String] The proxy url of video.
      attr_reader proxy_url: String

      # @return [Integer] The height of video.
      attr_reader height: Integer

      # @return [Integer] The width of video.
      attr_reader width: Integer
    end

    #
    # Represents a provider of embed.
    class Provider < Discorb::Embed::Entry
      #
      # Initialize a new Provider object.
      # @private
      #
      # @param [Hash] data The data of provider.
      def initialize: (::Hash[untyped, untyped] data) -> void

      # @return [String] The name of provider.
      attr_reader name: String

      # @return [String] The url of provider.
      attr_reader url: String
    end
  end

  # Represents a Discord emoji.
  # @abstract
  class Emoji
    def eql?: (untyped other) -> bool

    def ==: (untyped other) -> untyped

    def inspect: () -> untyped
  end

  # Represents a custom emoji in discord.
  class CustomEmoji < Discorb::Emoji
    #
    # Initialize a new custom emoji.
    # @private
    #
    # @param [Discorb::Client] client The client that owns this emoji.
    # @param [Discorb::Guild] guild The guild that owns this emoji.
    # @param [Hash] data The data of the emoji.
    def initialize: (Discorb::Client client, Discorb::Guild guild, ::Hash[untyped, untyped] data) -> void

    #
    # Format the emoji for sending.
    #
    # @return [String] the formatted emoji.
    def to_s: () -> String

    #
    # Format the emoji for URI.
    #
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    #
    # Edit the emoji.
    # @async
    # @macro edit
    #
    # @param [String] name The new name of the emoji.
    # @param [Array<Discorb::Role>] roles The new roles that can use this emoji.
    # @param [String] reason The reason for editing the emoji.
    #
    # @return [Async::Task<self>] The edited emoji.
    def edit: (?name: String, ?roles: ::Array[Discorb::Role], ?reason: String?) -> Async::Task[self]

    #
    # Delete the emoji.
    # @async
    #
    # @param [String] reason The reason for deleting the emoji.
    #
    # @return [Async::Task<self>] The deleted emoji.
    def delete!: (?reason: String?) -> Async::Task[self]

    #
    # Converts the object to a hash.
    # @private
    #
    # @return [Hash] The hash represents the object.
    def to_hash: () -> ::Hash[untyped, untyped]

    # @return [Discorb::Snowflake] The ID of the emoji.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the emoji.
    attr_reader name: String

    # @return [Array<Discorb::Role>] The roles that can use this emoji.
    attr_reader roles: ::Array[Discorb::Role]

    # @return [Discorb::User] The user that created this emoji.
    attr_reader user: Discorb::User

    # @return [Boolean] Whether the emoji requires colons.
    attr_reader guild: bool

    # @return [Boolean] whether the emoji is managed by integration (ex: Twitch).
    attr_reader managed: bool

    # @return [Boolean] whether the emoji requires colons.
    attr_reader require_colons: bool

    # @return [Boolean] whether the emoji is available.
    attr_reader available: bool

    # @return [Boolean] whether or not this emoji is restricted to certain roles.
    attr_reader roles?: bool
  end

  #
  # Represents a partial custom emoji in discord.
  class PartialEmoji < Discorb::DiscordModel
    #
    # Initialize a new partial custom emoji.
    # @private
    #
    # @param [Hash] data The data of the emoji.
    def initialize: (::Hash[untyped, untyped] data) -> void

    #
    # Format the emoji for URI.
    #
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    #
    # Format the emoji for sending.
    #
    # @return [String] the formatted emoji.
    def to_s: () -> String

    # @return [Discorb::Snowflake] The ID of the emoji.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the emoji.
    attr_reader name: String

    # @return [Boolean] Whether the emoji is deleted.
    attr_reader deleted: bool
  end

  #
  # Represents a unicode emoji (default emoji) in discord.
  class UnicodeEmoji < Discorb::Emoji
    #
    # Initialize a new unicode emoji.
    #
    # @param [String] name The name of the emoji.
    # @param [Integer] tone The skin tone of the emoji.
    def initialize: (String name, ?tone: Integer) -> void

    # @return [String] The unicode string of the emoji.
    def to_s: () -> String

    #
    # Format the emoji for URI.
    #
    # @return [String] the formatted emoji.
    def to_uri: () -> String

    def inspect: () -> untyped

    #
    # Converts the object to a hash.
    # @private
    #
    # @return [Hash] The hash represents the object.
    def to_hash: () -> ::Hash[untyped, untyped]

    # @return [String] The name of the emoji. (e.g. :grinning:)
    attr_reader name: String

    # @return [String] The unicode value of the emoji. (e.g. U+1F600)
    attr_reader value: String

    # @return [Integer] The skin tone of the emoji.
    attr_reader skin_tone: Integer
  end

  #
  # Error class for Discorb.
  # @abstract
  class DiscorbError < StandardError
    def enumerate_errors: (untyped hash) -> untyped

    def _recr_items: (untyped key, untyped item, untyped res) -> untyped
  end

  #
  # Represents a HTTP error.
  # @abstract
  class HTTPError < Discorb::DiscorbError
    #
    # Initialize a new instance of the HTTPError class.
    # @private
    def initialize: (untyped resp, untyped data) -> void

    # @return [String] the JSON response code.
    # @see https://discord.com/developers/docs/topics/opcodes-and-status-codes#json-json-error-codes
    attr_reader code: String

    # @return [Net::HTTPResponse] the HTTP response.
    attr_reader response: Net::HTTPResponse
  end

  #
  # Represents a 400 error.
  class BadRequestError < Discorb::HTTPError
    #
    # Initialize a new instance of the BadRequestError class.
    # @private
    def initialize: (untyped resp, untyped data) -> void
  end

  #
  # Represents a 401 error.
  class UnauthorizedError < Discorb::HTTPError
  end

  #
  # Represents a 403 error.
  class ForbiddenError < Discorb::HTTPError
  end

  #
  # Represents a 404 error.
  class NotFoundError < Discorb::HTTPError
  end

  #
  # Represents a error because of a cloudflare ban.
  class CloudFlareBanError < Discorb::HTTPError
    def initialize: (untyped _resp, untyped client) -> void
  end

  #
  # Represents a error in client-side.
  class ClientError < Discorb::DiscorbError
  end

  #
  # Represents a timeout error.
  class TimeoutError < Discorb::DiscorbError
  end

  #
  # Represents a warning.
  class NotSupportedWarning < Discorb::DiscorbError
    def initialize: (untyped message) -> void
  end

  #
  # Represents an event in guild.
  class ScheduledEvent < Discorb::DiscordModel
    PRIVACY_LEVEL: untyped
    STATUS: untyped
    ENTITY_TYPE: untyped

    # @!visibility private
    def initialize: (untyped client, untyped data) -> void

    #
    # Create a scheduled event for the guild.
    # @async
    #
    # @param [:stage_instance, :voice, :external] type The type of event to create.
    # @param [String] name The name of the event.
    # @param [String] description The description of the event.
    # @param [Time] start_time The start time of the event.
    # @param [Time, nil] end_time The end time of the event. Defaults to `nil`.
    # @param [Discorb::Channel, Discorb::Snowflake, nil] channel The channel to run the event in.
    # @param [String, nil] location The location of the event. Defaults to `nil`.
    # @param [:guild_only] privacy_level The privacy level of the event. This must be `:guild_only`.
    # @param [:active, :completed, :canceled] status The status of the event.
    #
    # @return [Async::Task<Discorb::ScheduledEvent>] The event that was created.
    #
    # @see Event#start
    # @see Event#cancel
    # @see Event#complete
    def edit: (
                ?type: Symbol,
                ?name: String,
                ?description: String,
                ?start_time: Time,
                ?end_time: Time?,
                ?privacy_level: Symbol,
                ?location: String?,
                ?channel: (Discorb::Channel | Discorb::Snowflake)?,
                ?status: Symbol
              ) -> Async::Task[Discorb::ScheduledEvent]

    #
    # Starts the event. Shortcut for `edit(status: :active)`.
    def start: () -> untyped

    #
    # Completes the event. Shortcut for `edit(status: :completed)`.
    def complete: () -> untyped

    #
    # Cancels the event. Shortcut for `edit(status: :canceled)`.
    def cancel: () -> untyped

    #
    # Deletes the event.
    # @async
    #
    # @return [Async::Task<void>] The task.
    def delete!: () -> Async::Task[void]

    #
    # Fetches the event users.
    # @async
    #
    # @note You can fetch all of members by not specifying a parameter.
    #
    # @param [Integer] limit The maximum number of users to fetch. Defaults to `100`.
    # @param [#to_s] after The ID of the user to start fetching from. Defaults to `nil`.
    # @param [#to_s] before The ID of the user to stop fetching at. Defaults to `nil`.
    # @param [Boolean] with_member Whether to include the member object of the event. Defaults to `false`.
    #   This should be used for manual fetching of members.
    #
    # @return [Async::Task<Array<Discorb::Member>>] The event users.
    def fetch_users: (
                       ?Integer? limit,
                       ?before: untyped,
                       ?after: untyped,
                       ?with_member: bool
                     ) -> Async::Task[::Array[Discorb::Member]]

    # @return [Discorb::Snowflake] The ID of the event.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the event.
    attr_reader name: String

    # @return [String] The description of the event.
    attr_reader description: String

    # @return [Time] The time the event starts.
    attr_reader scheduled_start_time: Time

    # @return [Time] The time the event ends.
    attr_reader scheduled_end_time: Time

    # @return [:guild_only] The privacy level of the event.
    attr_reader privacy_level: Symbol

    # @return [:scheduled, :active, :completed, :canceled] The status of the event.
    attr_reader status: Symbol

    # @return [:stage_instance, :voice, :external] The type of the event.
    attr_reader entity_type: Symbol

    # @return [Discorb::Snowflake] The ID of the entity the event is for.
    attr_reader entity_id: Discorb::Snowflake

    # @return [Discorb::ScheduledEvent::Metadata] The metadata of the event.
    attr_reader metadata: Discorb::ScheduledEvent::Metadata

    # @return [Integer] The user count of the event.
    attr_reader user_count: Integer

    # @!attribute [r] guild
    #   @return [Discorb::Guild, nil] The guild of the event.
    # @!attribute [r] channel
    #   @return [Discorb::Channel, nil] The channel of the event.
    #     Only present if the event will do in stage instance or voice channel.
    # @!attribute [r] creator
    #   @return [Discorb::User] The user who created the event.#
    # @!attribute [r] time
    #   @return [Range<Time>] The time range of the event.
    attr_reader guild: untyped

    # @return [Discorb::Channel, nil] The channel of the event.
    #   Only present if the event will do in stage instance or voice channel.
    attr_reader channel: Discorb::Channel?

    # @return [Discorb::User] The user who created the event.#
    attr_reader creator: Discorb::User

    # @return [Range<Time>] The time range of the event.
    attr_reader time: ::Range[Time]

    #
    # Represents the metadata of the event.
    class Metadata
      # @!visibility private
      def initialize: (untyped data) -> void

      def inspect: () -> untyped

      # @return [String, nil] The location of the event. Only present if the event is a external event.
      attr_reader location: String?
    end
  end

  #
  # Represents a guild in the Discord.
  class Guild < Discorb::DiscordModel
    include Discorb::ChannelContainer
    MFA_LEVELS: untyped
    NSFW_LEVELS: untyped
    VERIFICATION_LEVELS: untyped
    DEFAULT_MESSAGE_NOTIFICATIONS: untyped
    EXPLICIT_CONTENT_FILTER: untyped

    #
    # Creates a new guild object.
    # @private
    #
    # @param [Discorb::Client] client The client that owns this guild.
    # @param [Hash] data The data of the guild.
    # @param [Boolean] is_create_event Whether the guild is created by a `GUILD_CREATE` event.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data, bool is_create_event) -> void

    def inspect: () -> untyped

    #
    # Leave the guild.
    # @async
    #
    # @return [Async::Task<void>] The task.
    def leave!: () -> Async::Task[void]

    #
    # Fetch scheduled events for the guild.
    # @async
    #
    # @param [Boolean] with_user_count Whether to include the user count in the events.
    #   Defaults to `true`.
    #
    # @return [Array<Discorb::ScheduledEvent>] The events for the guild.
    def fetch_scheduled_events: (?with_user_count: bool) -> ::Array[Discorb::ScheduledEvent]

    #
    # Fetch the scheduled event by ID.
    # @async
    #
    # @param [#to_s] id The ID of the scheduled event.
    #
    # @return [Async::Task<Discorb::ScheduledEvent>] The event with the given ID.
    # @return [Async::Task<nil>] If no event with the given ID exists.
    def fetch_scheduled_event: (_ToS id) -> Async::Task[Discorb::ScheduledEvent]

    #
    # Create a scheduled event for the guild.
    # @async
    #
    # @param [:stage_instance, :voice, :external] type The type of event to create.
    # @param [String] name The name of the event.
    # @param [String] description The description of the event.
    # @param [Time] start_time The start time of the event.
    # @param [Time, nil] end_time The end time of the event. Defaults to `nil`.
    # @param [Discorb::Channel, Discorb::Snowflake, nil] channel The channel to run the event in.
    # @param [String, nil] location The location of the event. Defaults to `nil`.
    # @param [:guild_only] privacy_level The privacy level of the event. This must be `:guild_only`.
    #
    # @return [Async::Task<Discorb::ScheduledEvent>] The created event.
    def create_scheduled_event: (
                                  Symbol type,
                                  String name,
                                  String description,
                                  Time start_time,
                                  ?Time? end_time,
                                  ?privacy_level: Symbol,
                                  ?location: String?,
                                  ?channel: (Discorb::Channel | Discorb::Snowflake)?
                                ) -> Async::Task[Discorb::ScheduledEvent]

    #
    # Fetch emoji list of the guild.
    # @async
    # @note This querys the API every time. We recommend using {#emojis} instead.
    #
    # @return [Async::Task<Discorb::Dictionary{Discorb::Snowflake => Discorb::CustomEmoji}>]
    #   A dictionary of emoji in the guild.
    def fetch_emoji_list: () -> Async::Task[Discorb::Dictionary[Discorb::Snowflake, Discorb::CustomEmoji]]

    #
    # Fetch emoji id of the guild.
    # @async
    # @note This querys the API every time. We recommend using {#emojis} instead.
    #
    # @param [#to_s] id The emoji id.
    #
    # @return [Async::Task<Discorb::CustomEmoji>] The emoji with the given id.
    def fetch_emoji: (_ToS id) -> Async::Task[Discorb::CustomEmoji]

    #
    # Create a custom emoji.
    # @async
    #
    # @param [#to_s] name The name of the emoji.
    # @param [Discorb::Image] image The image of the emoji.
    # @param [Array<Discorb::Role>] roles A list of roles to give the emoji.
    #
    # @return [Async::Task<Discorb::CustomEmoji>] The created emoji.
    def create_emoji: (untyped name, Discorb::Image image, ?roles: ::Array[Discorb::Role]) -> Async::Task[Discorb::CustomEmoji]

    #
    # Fetch webhooks of the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Webhook>>] A list of webhooks in the guild.
    def fetch_webhooks: () -> Async::Task[::Array[Discorb::Webhook]]

    #
    # Fetch audit log of the guild.
    # @async
    #
    # @return [Async::Task<Discorb::AuditLog>] The audit log of the guild.
    def fetch_audit_log: () -> Async::Task[Discorb::AuditLog]

    #
    # Fetch channels of the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Channel>>] A list of channels in the guild.
    def fetch_channels: () -> Async::Task[::Array[Discorb::Channel]]

    #
    # Create a new text channel.
    # @async
    #
    # @param [String] name The name of the channel.
    # @param [String] topic The topic of the channel.
    # @param [Integer] rate_limit_per_user The rate limit per user in the channel.
    # @param [Integer] slowmode Alias for `rate_limit_per_user`.
    # @param [Integer] position The position of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites
    #   A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    #
    # @return [Async::Task<Discorb::TextChannel>] The created text channel.
    def create_text_channel: (
                               String name,
                               ?topic: String?,
                               ?rate_limit_per_user: Integer?,
                               ?slowmode: Integer?,
                               ?position: Integer?,
                               ?nsfw: bool?,
                               ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                               ?parent: Discorb::CategoryChannel?,
                               ?reason: String?
                             ) -> Async::Task[Discorb::TextChannel]

    #
    # Create a new voice channel.
    # @async
    #
    # @param [String] name The name of the channel.
    # @param [Integer] bitrate The bitrate of the channel.
    # @param [Integer] user_limit The user limit of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites
    #   A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    #
    # @return [Async::Task<Discorb::VoiceChannel>] The created voice channel.
    def create_voice_channel: (
                                String name,
                                ?bitrate: Integer,
                                ?user_limit: Integer?,
                                ?position: Integer?,
                                ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                ?parent: Discorb::CategoryChannel?,
                                ?reason: String?
                              ) -> Async::Task[Discorb::VoiceChannel]

    # Create a new category channel.
    # @async
    #
    # @param [String] name The name of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites
    #  A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    #
    # @return [Async::Task<Discorb::CategoryChannel>] The created category channel.
    def create_category_channel: (
                                   String name,
                                   ?position: Integer?,
                                   ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                   ?parent: Discorb::CategoryChannel?,
                                   ?reason: String?
                                 ) -> Async::Task[Discorb::CategoryChannel]

    #
    # Create a new stage channel.
    # @async
    #
    # @param [String] name The name of the channel.
    # @param [Integer] bitrate The bitrate of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites
    #   A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    #
    # @return [Async::Task<Discorb::StageChannel>] The created stage channel.
    def create_stage_channel: (
                                String name,
                                ?bitrate: Integer,
                                ?position: Integer?,
                                ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                                ?parent: Discorb::CategoryChannel?,
                                ?reason: String?
                              ) -> Async::Task[Discorb::StageChannel]

    #
    # Create a new news channel.
    # @async
    #
    # @param [String] name The name of the channel.
    # @param [String] topic The topic of the channel.
    # @param [Integer] rate_limit_per_user The rate limit per user in the channel.
    # @param [Integer] slowmode Alias for `rate_limit_per_user`.
    # @param [Integer] position The position of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Hash{Discorb::Role, Discorb::Member => Discorb::PermissionOverwrite}] permission_overwrites
    #   A list of permission overwrites.
    # @param [Discorb::CategoryChannel] parent The parent of the channel.
    # @param [String] reason The reason for creating the channel.
    #
    # @return [Async::Task<Discorb::NewsChannel>] The created news channel.
    def create_news_channel: (
                               String name,
                               ?topic: String?,
                               ?rate_limit_per_user: Integer?,
                               ?slowmode: Integer?,
                               ?position: Integer?,
                               ?nsfw: bool?,
                               ?permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]?,
                               ?parent: Discorb::CategoryChannel?,
                               ?reason: String?
                             ) -> Async::Task[Discorb::NewsChannel]

    #
    # Fetch a list of active threads in the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The list of threads.
    def fetch_active_threads: () -> Async::Task[::Array[Discorb::ThreadChannel]]

    #
    # Fetch a member in the guild.
    # @async
    #
    # @param [#to_s] id The ID of the member to fetch.
    #
    # @return [Async::Task<Discorb::Member>] The member.
    # @return [Async::Task<nil>] If the member is not found.
    def fetch_member: (_ToS id) -> Async::Task[Discorb::Member]

    # Fetch members in the guild.
    # @async
    # @macro members_intent
    #
    # @param [Integer] limit The maximum number of members to fetch, 0 for all.
    # @param [Integer] after The ID of the member to start fetching after.
    #
    # @return [Async::Task<Array<Discorb::Member>>] The list of members.
    def fetch_members: (?limit: Integer, ?after: Integer?) -> Async::Task[::Array[Discorb::Member]]

    #
    # Search for members by name in the guild.
    # @async
    #
    # @param [String] name The name of the member to search for.
    # @param [Integer] limit The maximum number of members to return.
    #
    # @return [Async::Task<Array<Discorb::Member>>] The list of members.
    def fetch_members_named: (String name, ?limit: Integer) -> Async::Task[::Array[Discorb::Member]]

    #
    # Almost the same as {#fetch_members_named}, but returns a single member.
    # @async
    #
    # @return [Async::Task<Discorb::Member>] The member.
    # @return [Async::Task<nil>] If the member is not found.
    def fetch_member_named: () -> Async::Task[Discorb::Member]

    #
    # Change nickname of client member.
    # @async
    #
    # @param [String] nickname The nickname to set.
    # @param [String] reason The reason for changing the nickname.
    #
    # @return [Async::Task<void>] The task.
    def edit_nickname: (String nickname, ?reason: String?) -> Async::Task[void]

    #
    # Kick a member from the guild.
    # @async
    #
    # @param [Discorb::Member] member The member to kick.
    # @param [String] reason The reason for kicking the member.
    #
    # @return [Async::Task<void>] The task.
    def kick_member: (Discorb::Member member, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a list of bans in the guild.
    # @async
    #
    # @param [Integer] limit The number of bans to fetch.
    # @param [Discorb::Snowflake] before The ID of the ban to fetch before.
    # @param [Discorb::Snowflake] after The ID of the ban to fetch after.
    # @param [Discorb::Snowflake] around The ID of the ban to fetch around.
    #
    # @return [Async::Task<Array<Discorb::Guild::Ban>>] The list of bans.
    def fetch_bans: (
                      ?Integer limit,
                      ?before: Discorb::Snowflake?,
                      ?after: Discorb::Snowflake?,
                      ?around: Discorb::Snowflake?
                    ) -> Async::Task[::Array[Discorb::Guild::Ban]]

    #
    # Fetch a ban in the guild.
    # @async
    #
    # @param [Discorb::User] user The user to fetch.
    #
    # @return [Async::Task<Discorb::Guild::Ban>] The ban.
    # @return [Async::Task<nil>] If the ban is not found.
    def fetch_ban: (Discorb::User user) -> Async::Task[Discorb::Guild::Ban]

    #
    # Checks the user was banned from the guild.
    # @async
    #
    # @param [Discorb::User] user The user to check.
    #
    # @return [Async::Task<Boolean>] Whether the user was banned.
    def banned?: (Discorb::User user) -> Async::Task[bool]

    #
    # Ban a member from the guild.
    # @async
    #
    # @param [Discorb::Member] member The member to ban.
    # @param [Integer] delete_message_days The number of days to delete messages.
    # @param [String] reason The reason for banning the member.
    #
    # @return [Async::Task<Discorb::Guild::Ban>] The ban.
    def ban_member: (Discorb::Member member, ?delete_message_days: Integer, ?reason: String?) -> Async::Task[Discorb::Guild::Ban]

    #
    # Unban a user from the guild.
    # @async
    #
    # @param [Discorb::User] user The user to unban.
    # @param [String] reason The reason for unbanning the user.
    #
    # @return [Async::Task<void>] The task.
    def unban_user: (Discorb::User user, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a list of roles in the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Role>>] The list of roles.
    def fetch_roles: () -> Async::Task[::Array[Discorb::Role]]

    #
    # Create a role in the guild.
    # @async
    #
    # @param [String] name The name of the role.
    # @param [Discorb::Color] color The color of the role.
    # @param [Boolean] hoist Whether the role should be hoisted.
    # @param [Boolean] mentionable Whether the role should be mentionable.
    # @param [String] reason The reason for creating the role.
    #
    # @return [Async::Task<Discorb::Role>] The role.
    def create_role: (
                       ?String? name,
                       ?color: Discorb::Color?,
                       ?hoist: bool?,
                       ?mentionable: bool?,
                       ?reason: String?
                     ) -> Async::Task[Discorb::Role]

    #
    # Fetch how many members will be pruned.
    # @async
    #
    # @param [Integer] days The number of days to prune.
    # @param [Array<Discorb::Role>] roles The roles that include for pruning.
    #
    # @return [Async::Task<Integer>] The number of members that will be pruned.
    def fetch_prune: (?Integer days, ?roles: ::Array[Discorb::Role]) -> Async::Task[Integer]

    #
    # Prune members from the guild.
    # @async
    #
    # @param [Integer] days The number of days to prune.
    # @param [Array<Discorb::Role>] roles The roles that include for pruning.
    # @param [String] reason The reason for pruning.
    #
    # @return [Async::Task<Integer>] The number of members that were pruned.
    def prune: (?Integer days, ?roles: ::Array[Discorb::Role], ?reason: String?) -> Async::Task[Integer]

    #
    # Fetch voice regions that are available in the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::VoiceRegion>>] The available voice regions.
    def fetch_voice_regions: () -> Async::Task[::Array[Discorb::VoiceRegion]]

    #
    # Fetch invites in the guild.
    # @async
    #
    # @return [Async::Task<Array<Invite>>] The invites.
    def fetch_invites: () -> Async::Task[::Array[Invite]]

    #
    # Fetch integrations in the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Integration>>] The integrations.
    def fetch_integrations: () -> Async::Task[::Array[Discorb::Integration]]

    #
    # Fetch the widget of the guild.
    # @async
    #
    # @return [Async::Task<Discorb::Guild::Widget>] The widget.
    def fetch_widget: () -> Async::Task[Discorb::Guild::Widget]

    #
    # Fetch the vanity URL of the guild.
    # @async
    #
    # @return [Async::Task<Discorb::Guild::VanityInvite>] The vanity URL.
    def fetch_vanity_invite: () -> Async::Task[Discorb::Guild::VanityInvite]

    #
    # Fetch the welcome screen of the guild.
    # @async
    #
    # @return [Async::Task<Discorb::WelcomeScreen>] The welcome screen.
    def fetch_welcome_screen: () -> Async::Task[Discorb::WelcomeScreen]

    #
    # Fetch stickers in the guild.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Sticker::GuildSticker>>] The stickers.
    def fetch_stickers: () -> Async::Task[::Array[Discorb::Sticker::GuildSticker]]

    #
    # Fetch the sticker by ID.
    # @async
    #
    # @param [#to_s] id The ID of the sticker.
    #
    # @return [Async::Task<Discorb::Sticker::GuildSticker>] The sticker.
    # @return [Async::Task<nil>] If the sticker does not exist.
    def fetch_sticker: (_ToS id) -> Async::Task[Discorb::Sticker::GuildSticker]

    #
    # Fetch templates in the guild.
    # @async
    #
    # @return [Async::Task<Discorb::GuildTemplate>] The templates.
    def fetch_templates: () -> Async::Task[Discorb::GuildTemplate]

    #
    # Almost the same as {#fetch_templates}, but returns a single template.
    #
    # @return [Discorb::GuildTemplate] The template.
    # @return [Async::Task<nil>] If the template does not exist.
    def fetch_template: () -> Discorb::GuildTemplate

    #
    # Create a new template in the guild.
    #
    # @param [String] name The name of the template.
    # @param [String] description The description of the template.
    # @param [String] reason The reason for creating the template.
    #
    # @return [Async::Task<Discorb::GuildTemplate>] The template.
    def create_template: (String name, ?String? description, ?reason: String?) -> Async::Task[Discorb::GuildTemplate]

    #
    # Returns a banner url from the guild's ID.
    #
    # @param [#to_s] guild_id The ID of the guild.
    # @param [:shield, :banner1, :banner2, :banner3, :banner4] style The style of the banner.
    #
    # @return [String] The url of the banner.
    def self.banner: (_ToS guild_id, ?style: Symbol) -> String

    #
    # Returns text channels.
    #
    # @return [Array<Discorb::TextChannel>] The text channels.
    def text_channels: () -> ::Array[Discorb::TextChannel]

    #
    # Returns voice channels.
    #
    # @return [Array<Discorb::VoiceChannel>] The voice channels.
    def voice_channels: () -> ::Array[Discorb::VoiceChannel]

    #
    # Returns news channels.
    #
    # @return [Array<Discorb::NewsChannel>] The news channels.
    def news_channels: () -> ::Array[Discorb::NewsChannel]

    #
    # Returns stage channels.
    #
    # @return [Array<Discorb::StageChannel>] The stage channels.
    def stage_channels: () -> ::Array[Discorb::StageChannel]

    # @return [Discorb::Snowflake] ID of the guild.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the guild.
    attr_reader name: String

    # @return [Discorb::Asset] The splash of the guild.
    attr_reader splash: Discorb::Asset

    # @return [Discorb::Asset] The discovery splash of the guild.
    attr_reader discovery_splash: Discorb::Asset

    # @return [Discorb::Snowflake] ID of the guild owner.
    attr_reader owner_id: Discorb::Snowflake

    # @return [Discorb::Permission] The bot's permission in the guild.
    attr_reader permissions: Discorb::Permission

    # @return [Integer] The AFK timeout of the guild.
    attr_reader afk_timeout: Integer

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Role}] A dictionary of roles in the guild.
    attr_reader roles: Discorb::Dictionary[Discorb::Snowflake, Discorb::Role]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::CustomEmoji}]
    #   A dictionary of custom emojis in the guild.
    attr_reader emojis: Discorb::Dictionary[Discorb::Snowflake, Discorb::CustomEmoji]

    # @return [Array<Symbol>] features that are enabled in the guild.
    # @see https://discord.com/developers/docs/resources/guild#guild-object-guild-features Official Discord API docs
    attr_reader features: ::Array[Symbol]

    # @return [:none, :elevated] The MFA level of the guild.
    attr_reader mfa_level: Symbol

    # @return [Discorb::SystemChannelFlag] The flag for the system channel.
    attr_reader system_channel_flags: Discorb::SystemChannelFlag

    # @return [Time] Time that representing when bot has joined the guild.
    attr_reader joined_at: Time

    # @return [Boolean] Whether the guild is unavailable.
    attr_reader unavailable: bool

    # @return [Integer] The amount of members in the guild.
    attr_reader member_count: Integer

    # @return [Discorb::Asset] The icon of the guild.
    attr_reader icon: Discorb::Asset

    # @return [Discorb::Dictionary{Discorb::User => Discorb::VoiceState}] A dictionary of voice states in the guild.
    attr_reader voice_states: Discorb::Dictionary[Discorb::User, Discorb::VoiceState]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Member}] A dictionary of members in the guild.
    # @macro members_intent
    attr_reader members: Discorb::Dictionary[Discorb::Snowflake, Discorb::Member]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::GuildChannel}] A dictionary of channels in the guild.
    attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::GuildChannel]

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::ThreadChannel}] A dictionary of threads in the guild.
    attr_reader threads: Discorb::Dictionary[Discorb::Snowflake, Discorb::ThreadChannel]

    # @return [Discorb::Dictionary{Discorb::User => Discorb::Presence}] A dictionary of presence in the guild.
    attr_reader presences: Discorb::Dictionary[Discorb::User, Discorb::Presence]

    # @return [Integer] Number of online members in the guild.
    attr_reader max_presences: Integer

    # @return [String] The vanity invite URL for the guild.
    # @return [nil] If the guild does not have a vanity invite URL.
    attr_reader vanity_url_code: String?

    # @return [String] The description of the guild.
    attr_reader description: String

    # @return [Discorb::Asset] The banner of the guild.
    # @return [nil] If the guild does not have a banner.
    attr_reader banner: Discorb::Asset?

    # @return [Integer] The premium tier (Boost Level) of the guild.
    attr_reader premium_tier: Integer

    # @return [Integer] The amount of premium subscriptions (Server Boosts) the guild has.
    attr_reader premium_subscription_count: Integer

    # @return [Symbol] The preffered language of the guild.
    # @note This modifies the language code, `-` will be replaced with `_`.
    attr_reader preferred_locale: Symbol

    # @return [Integer] The maximum amount of users in a video channel.
    attr_reader max_video_channel_users: Integer

    # @return [Integer] The approxmate amount of members in the guild.
    attr_reader approximate_member_count: Integer

    # @return [Integer] The approxmate amount of non-offline members in the guild.
    attr_reader approximate_presence_count: Integer

    # @return [Discorb::WelcomeScreen] The welcome screen of the guild.
    attr_reader welcome_screen: Discorb::WelcomeScreen

    # @return [:default, :explicit, :safe, :age_restricted] The nsfw level of the guild.
    attr_reader nsfw_level: Symbol

    # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::StageInstance}]
    #   A dictionary of stage instances in the guild.
    attr_reader stage_instances: Discorb::Dictionary[Discorb::Snowflake, Discorb::StageInstance]

    # @return [:none, :low, :medium, :high, :very_high] The verification level of the guild.
    attr_reader verification_level: Symbol

    # @return [:all_messages, :only_mentions] The default message notification level of the guild.
    attr_reader default_message_notifications: Symbol

    # @return [:disabled_in_text, :members_without_roles, :all_members] The explict content filter level of the guild.
    attr_reader explicit_content_filter: Symbol

    # @return [Boolean] Whether the client is the owner of the guild.
    attr_reader owner: bool

    # @return [Boolean] Whether the guild is large.
    attr_reader large: bool

    # @return [Boolean] Whether the guild enabled the widget.
    attr_reader widget_enabled: bool

    # @return [Boolean] Whether the guild is available.
    attr_reader available: bool

    # @return [Dictionary{Discorb::Snowflake => Discorb::ScheduledEvent}] A dictionary of scheduled events in the guild.
    attr_reader scheduled_events: Dictionary[Discorb::Snowflake, Discorb::ScheduledEvent]

    # @return [Discorb::VoiceChannel] The AFK channel for this guild.
    # @macro client_cache
    attr_reader afk_channel: Discorb::VoiceChannel?

    # @return [Discorb::TextChannel] The system message channel for this guild.
    # @macro client_cache
    attr_reader system_channel: Discorb::TextChannel?

    # @return [Discorb::TextChannel] The rules channel for this guild.
    # @macro client_cache
    attr_reader rules_channel: Discorb::TextChannel?

    # @return [Discorb::TextChannel] The public updates channel (`#moderator-only`) for this guild.
    # @macro client_cache
    attr_reader public_updates_channel: Discorb::TextChannel?

    # @return [Discorb::Member] The client's member in the guild.
    attr_reader me: Discorb::Member

    #
    # Represents a vanity invite.
    class VanityInvite < Discorb::DiscordModel
      #
      # Initialize a new instance of the {VanityInvite} class.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Discorb::Guild] guild The guild.
      # @param [Hash] data The data of the invite.
      def initialize: (Discorb::Client client, Discorb::Guild guild, ::Hash[untyped, untyped] data) -> void

      # @return [String] The vanity invite code.
      attr_reader code: String

      # @return [Integer] The number of uses.
      attr_reader uses: Integer

      # @return [String] The vanity URL.
      attr_reader url: String
    end

    #
    # Represents a guild widget.
    class Widget < Discorb::DiscordModel
      #
      # Initialize a new instance of the {Widget} class.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Discorb::Snowflake] guild_id The guild ID.
      # @param [Hash] data The data from Discord.
      def initialize: (Discorb::Client client, Discorb::Snowflake guild_id, ::Hash[untyped, untyped] data) -> void

      #
      # Edit the widget.
      # @async
      # @macro edit
      #
      # @param [Boolean] enabled Whether the widget is enabled.
      # @param [Discorb::GuildChannel] channel The channel.
      # @param [String] reason The reason for editing the widget.
      #
      # @return [Async::Task<void>] The task.
      def edit: (?enabled: bool?, ?channel: Discorb::GuildChannel?, ?reason: String?) -> Async::Task[void]

      #
      # Return iframe HTML of the widget.
      #
      # @param ["dark", "light"] theme The theme of the widget.
      # @param [Integer] width The width of the widget.
      # @param [Integer] height The height of the widget.
      #
      # @return [String] The iframe HTML.
      def iframe: (?theme: ("dark" | "light"), ?width: Integer, ?height: Integer) -> String

      # @return [Discorb::Snowflake] The guild ID.
      attr_reader guild_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The channel ID.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Boolean] Whether the widget is enabled.
      attr_reader enabled: bool

      # @macro client_cache
      # @return [Discorb::Channel] The channel.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild.
      attr_reader guild: Discorb::Guild?

      # @return [String] The JSON URL.
      attr_reader json_url: String
    end

    #
    # Represents a ban.
    class Ban < Discorb::DiscordModel
      #
      # Initialize a new instance of the {Ban} class.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Discorb::Guild] guild The guild.
      # @param [Hash] data The data from Discord.
      def initialize: (Discorb::Client client, Discorb::Guild guild, ::Hash[untyped, untyped] data) -> void

      def inspect: () -> untyped

      # @return [Discorb::User] The user.
      attr_reader user: Discorb::User

      # @return [String] The reason for the ban.
      attr_reader reason: String
    end
  end

  #
  # Represents a system channel flag.
  # ## Flag fields
  # |Field|Value|
  # |-|-|
  # |`1 << 0`|`:member_join`|
  # |`1 << 1`|`:server_boost`|
  # |`1 << 2`|`:setup_tips`|
  # |`1 << 3`|`:join_stickers`|
  class SystemChannelFlag < Discorb::Flag
  end

  #
  # Represents a welcome screen.
  class WelcomeScreen < Discorb::DiscordModel
    #
    # Initializes the welcome screen.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Discorb::Guild] guild The guild the welcome screen belongs to.
    # @param [Hash] data The data of the welcome screen.
    def initialize: (Discorb::Client client, Discorb::Guild guild, ::Hash[untyped, untyped] data) -> void

    # @return [String] The description of the welcome screen.
    attr_reader description: String

    # @return [Array<Discorb::WelcomeScreen::Channel>] The channels to display the welcome screen.
    attr_reader channels: ::Array[Discorb::WelcomeScreen::Channel]

    # @return [Discorb::Guild] The guild the welcome screen belongs to.
    attr_reader guild: Discorb::Guild

    #
    # Represents a channel to display the welcome screen.
    class Channel < Discorb::DiscordModel
      #
      # Initialize a new welcome screen channel.
      #
      # @param [Discorb::TextChannel] channel The channel to display the welcome screen.
      # @param [String] description The channel's name.
      # @param [Discorb::Emoji] emoji The emoji to display.
      def initialize: (Discorb::TextChannel channel, String description, Discorb::Emoji emoji) -> void

      #
      # Converts the channel to a hash.
      #
      # @return [Hash] The hash.
      # @see https://discord.com/developers/docs/resources/guild#welcome-screen-object
      def to_hash: () -> ::Hash[untyped, untyped]

      #
      # Edits the welcome screen.
      # @async
      # @macro edit
      #
      # @param [Boolean] enabled Whether the welcome screen is enabled.
      # @param [Array<Discorb::WelcomeScreen::Channel>] channels The channels to display the welcome screen.
      # @param [String] description The description of the welcome screen.
      # @param [String] reason The reason for editing the welcome screen.
      #
      # @return [Async::Task<void>] The task.
      def edit: (
                  ?enabled: bool,
                  ?channels: ::Array[Discorb::WelcomeScreen::Channel],
                  ?description: String,
                  ?reason: String?
                ) -> Async::Task[void]

      # @return [String] The channel's name.
      attr_reader description: String

      # @return [Discorb::Emoji] The emoji to display.
      attr_reader emoji: Discorb::Emoji

      # @macro client_cache
      # @return [Discorb::Channel] The channel to display the welcome screen.
      attr_reader channel: Discorb::Channel?
    end
  end

  #
  # Represents an image.
  class Image
    #
    # Initializes a new Image.
    #
    # @param [#read, String] source The IO source or path of the image.
    # @param [String] type The MIME type of the image.
    def initialize: ((untyped | String) source, ?String? type) -> void

    #
    # Formats the image as a Discord style.
    #
    # @return [String] The image as a Discord style.
    def to_s: () -> String

    def inspect: () -> untyped
  end

  #
  # Represents a shard.
  class Shard
    #
    # Initializes a new shard.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Integer] id The ID of the shard.
    # @param [Integer] count The number of shards.
    # @param [Integer] index The index of the shard.
    def initialize: (
                      Discorb::Client client,
                      Integer id,
                      Integer count,
                      Integer index
                    ) -> void

    #
    # Starts the shard.
    #
    # @return [void]
    def start: () -> void

    #
    # Stops the shard.
    #
    # @return [void]
    def close!: () -> void

    def inspect: () -> untyped

    # @return [Integer] The ID of the shard.
    attr_reader id: Integer

    # @return [Thread] The thread of the shard.
    attr_reader thread: Thread

    # @return [Logger] The logger of the shard.
    attr_reader logger: Logger

    # @private
    # @return [Integer] The internal index of the shard.
    attr_reader index: Integer

    # @private
    attr_accessor status: untyped

    # @private
    attr_accessor connection: untyped

    # @private
    attr_accessor session_id: untyped

    # @private
    attr_accessor next_shard: untyped

    # @private
    attr_accessor main_task: untyped
  end

  # @private
  module Utils
    def try: (untyped object, untyped message) -> untyped

    def self.try: (untyped object, untyped message) -> untyped
  end

  #
  # @abstract
  # Represents Discord model.
  class DiscordModel
    def eql?: (untyped other) -> bool

    def ==: (untyped other) -> untyped

    def inspect: () -> untyped

    # @private
    def hash: () -> untyped
  end

  #
  # Represents Snowflake of Discord.
  #
  # @see https://discord.com/developers/docs/reference#snowflakes Official Discord API docs
  class Snowflake < String
    #
    # Initialize new snowflake.
    # @private
    #
    # @param [#to_s] value The value of the snowflake.
    def initialize: (untyped value) -> void

    #
    # Compares snowflake with other object.
    #
    # @param [#to_s] other Object to compare with.
    #
    # @return [Boolean] True if snowflake is equal to other object.
    def ==: (untyped other) -> bool

    #
    # Alias of {#==}.
    def eql?: (untyped other) -> bool

    # Return hash of snowflake.
    def hash: () -> untyped

    def inspect: () -> untyped

    # Timestamp of snowflake.
    #
    # @return [Time] Timestamp of snowflake.
    attr_reader timestamp: Time

    # Worker ID of snowflake.
    #
    # @return [Integer] Worker ID of snowflake.
    attr_reader worker_id: Integer

    # Process ID of snowflake.
    #
    # @return [Integer] Process ID of snowflake.
    attr_reader process_id: Integer

    # Increment of snowflake.
    #
    # @return [Integer] Increment of snowflake.
    attr_reader increment: Integer

    # Alias of to_s.
    #
    # @return [String] The snowflake.
    attr_reader id: String
  end

  #
  # Represents an endpoint.
  # @private
  class Route
    def initialize: (untyped url, untyped key, untyped method) -> void

    def inspect: () -> untyped

    def hash: () -> untyped

    def identifier: () -> untyped

    def major_param: () -> untyped

    # Returns the value of attribute url.
    attr_reader url: untyped

    # Returns the value of attribute key.
    attr_reader key: untyped

    # Returns the value of attribute method.
    attr_reader method: untyped
  end

  #
  # Represents invite of discord.
  class Invite < Discorb::DiscordModel
    TARGET_TYPES: untyped

    #
    # Initialize a new invite.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of invite.
    # @param [Boolean] gateway Whether the data is from gateway.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data, bool gateway) -> void

    # Delete the invite.
    # @async
    # @return [Async::Task<void>] The task.
    def delete!: (?reason: untyped) -> Async::Task[void]

    # @return [String] The code of invite.
    attr_reader code: String

    # @return [:voice, :stream, :guild] The type of invite.
    attr_reader target_type: Symbol

    # @return [User] The user of invite.
    attr_reader target_user: User

    # @return [Integer] The approximate number of online users of invite.
    attr_reader approximate_presence_count: Integer

    # @return [Integer] The approximate number of members of invite.
    attr_reader approximate_member_count: Integer

    # @return [Time] The time when invite expires.
    # @return [nil] The invite never expires.
    # @macro [new] nometa
    #   @return [nil] The invite doesn't have metadata.
    attr_reader expires_at: Time?

    # @return [Integer] The number of uses of invite.
    # @macro nometa
    attr_reader uses: Integer?

    # @return [Integer] The maximum number of uses of invite.
    # @macro nometa
    attr_reader max_uses: Integer?

    # @return [Integer] Duration of invite in seconds.
    # @macro nometa
    attr_reader max_age: Integer?

    # @return [Time] The time when invite was created.
    # @macro nometa
    attr_reader created_at: Time?

    # Channel of the invite.
    #
    # @return [Discorb::Channel] Channel of invite.
    # @macro client_cache
    attr_reader channel: Discorb::Channel?

    # Guild of the invite.
    #
    # @return [Discorb::Guild] Guild of invite.
    # @macro client_cache
    attr_reader guild: Discorb::Guild?

    # Number of remaining uses of invite.
    # @return [Integer] Number of remaining uses of invite.
    attr_reader remain_uses: Integer

    # Full url of invite.
    # @return [String] Full url of invite.
    attr_reader url: String

    # Whether the invite is temporary.
    # @return [Boolean]
    attr_reader temporary?: bool
  end

  #
  # Represents a member of a guild.
  class Member < Discorb::User
    #
    # Initialize a new instance of the member.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Discorb::Snowflake] guild_id The ID of the guild.
    # @param [Hash] user_data The data of the user.
    # @param [Hash] member_data The data of the member.
    def initialize: (
                      Discorb::Client client,
                      Discorb::Snowflake guild_id,
                      ::Hash[untyped, untyped] user_data,
                      ::Hash[untyped, untyped] member_data
                    ) -> void

    #
    # Format the member to `Username#Discriminator` style.
    #
    # @return [String] The formatted member.
    def to_s: () -> String

    def inspect: () -> untyped

    #
    # Add a role to the member.
    # @async
    #
    # @param [Discorb::Role] role The role to add.
    # @param [String] reason The reason for the action.
    #
    # @return [Async::Task<void>] The task.
    def add_role: (Discorb::Role role, ?reason: String?) -> Async::Task[void]

    #
    # Remove a role to the member.
    # @async
    #
    # @param [Discorb::Role] role The role to add.
    # @param [String] reason The reason for the action.
    #
    # @return [Async::Task<void>] The task.
    def remove_role: (Discorb::Role role, ?reason: String?) -> Async::Task[void]

    #
    # Edit the member.
    # @async
    # @macro edit
    #
    # @param [String] nick The nickname of the member.
    # @param [Discorb::Role] role The roles of the member.
    # @param [Boolean] mute Whether the member is muted.
    # @param [Boolean] deaf Whether the member is deafened.
    # @param [Discorb::StageChannel] channel The channel the member is moved to.
    # @param [Time, nil] communication_disabled_until The time the member is timed out. Set to `nil` to end the timeout.
    # @param [Time, nil] timeout_until Alias of `communication_disabled_until`.
    # @param [String] reason The reason for the action.
    #
    # @return [Async::Task<void>] The task.
    def edit: (
                ?nick: String,
                ?role: Discorb::Role,
                ?mute: bool,
                ?deaf: bool,
                ?channel: Discorb::StageChannel,
                ?communication_disabled_until: Time?,
                ?timeout_until: Time?,
                ?reason: String?
              ) -> Async::Task[void]

    #
    # Timeout the member.
    # @async
    #
    # @param [Time] time The time until the member is timeout.
    # @param [String] reason The reason for the action.
    #
    # @return [Async::Task<void>] The task.
    def timeout: (Time time, ?reason: String?) -> Async::Task[void]

    #
    # Kick the member.
    # @async
    #
    # @param [String] reason The reason for the action.
    #
    # @return [Async::Task<void>] The task.
    def kick: (?reason: String?) -> Async::Task[void]

    #
    # Ban the member.
    # @async
    #
    # @param [Integer] delete_message_days The number of days to delete messages.
    # @param [String] reason The reason for the action.
    #
    # @return [Async::Task<Discorb::Guild::Ban>] The ban.
    def ban: (?delete_message_days: Integer, ?reason: String?) -> Async::Task[Discorb::Guild::Ban]

    #
    # Checks if the member can manage the given role.
    #
    # @param [Discorb::Role] role The role.
    #
    # @return [Boolean] `true` if the member can manage the role.
    def can_manage?: (Discorb::Role role) -> bool

    # @return [Time] The time the member boosted the guild.
    attr_reader premium_since: Time

    # @return [String] The nickname of the member.
    # @return [nil] If the member has no nickname.
    attr_reader nick: String?

    # @return [Time] The time the member joined the guild.
    attr_reader joined_at: Time

    # @return [Discorb::Asset] The custom avatar of the member.
    # @return [nil] If the member has no custom avatar.
    attr_reader custom_avatar: Discorb::Asset?

    # @return [Discorb::Asset] The display avatar of the member.
    attr_reader display_avatar: Discorb::Asset

    # @return [Boolean] Whether the member is muted.
    attr_reader mute: bool

    # @return [Boolean] Whether the member is deafened.
    attr_reader deaf: bool

    # @return [Boolean] Whether the member is pending (Not passed member screening).
    attr_reader pending: bool

    # @return [String] The display name of the member.
    attr_reader name: String

    # @return [String] The mention of the member.
    attr_reader mention: String

    # @return [Discorb::VoiceState] The voice state of the member.
    attr_reader voice_state: Discorb::VoiceState

    # @macro client_cache
    # @return [Array<Discorb::Role>] The roles of the member.
    attr_reader roles: ::Array[Discorb::Role]?

    # @macro client_cache
    # @return [Discorb::Guild] The guild the member is in.
    attr_reader guild: Discorb::Guild?

    # @macro client_cache
    # @return [Discorb::Role] The hoisted role of the member.
    # @return [nil] If the member has no hoisted role.
    attr_reader hoisted_role: Discorb::Role?

    # @return [Boolean] Whether the member has a hoisted role.
    attr_reader hoisted?: bool

    # @return [Discorb::Permission] The permissions of the member.
    attr_reader permissions: Discorb::Permission

    # @macro client_cache
    # @return [Discorb::Presence] The presence of the member.
    attr_reader presence: Discorb::Presence?

    # @macro client_cache
    # @return [Discorb::Activity] The activity of the member. It's from the {#presence}.
    attr_reader activity: Discorb::Activity?

    # @macro client_cache
    # @return [Array<Discorb::Activity>] The activities of the member. It's from the {#presence}.
    attr_reader activities: ::Array[Discorb::Activity]?

    # @macro client_cache
    # @return [Symbol] The status of the member. It's from the {#presence}.
    attr_reader status: Symbol?

    # @return [Boolean] Whether the member is the owner of the guild.
    attr_reader owner?: bool
  end

  #
  # A module for Discord Gateway.
  # This module is internal use only.
  module Gateway
    #
    # Represents an event.
    # @abstract
    class GatewayEvent
      #
      # Initializes a new instance of the GatewayEvent class.
      # @private
      #
      # @param [Hash] data The data of the event.
      def initialize: (::Hash[untyped, untyped] data) -> void

      def inspect: () -> untyped
    end

    #
    # Represents a reaction event.
    class ReactionEvent < Discorb::Gateway::GatewayEvent
      #
      # Initializes a new instance of the ReactionEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # Fetch the message.
      # If message is cached, it will be returned.
      # @async
      #
      # @param [Boolean] force Whether to force fetching the message.
      #
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: (?force: bool) -> Async::Task[Discorb::Message]

      # @return [Hash] The raw data of the event.
      attr_reader data: ::Hash[untyped, untyped]

      # @return [Discorb::Snowflake] The ID of the user who reacted.
      attr_reader user_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::User] The user who reacted.
      attr_reader user: Discorb::User?

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?

      # @macro client_cache
      # @return [Discorb::Member] The member who reacted.
      attr_reader member: Discorb::Member?

      # @return [Discorb::UnicodeEmoji, Discorb::PartialEmoji] The emoji that was reacted with.
      attr_reader emoji: (Discorb::UnicodeEmoji | Discorb::PartialEmoji)

      # @macro client_cache
      # @return [Discorb::Member, Discorb::User] The user or member who reacted.
      attr_reader fired_by: (Discorb::Member | Discorb::User)?
    end

    #
    # Represents a `INTEGRATION_DELETE` event.
    class IntegrationDeleteEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the IntegrationDeleteEvent class.
      # @private
      #
      #
      # @param [Hash] data The data of the event.
      def initialize: (untyped _client, ::Hash[untyped, untyped] data) -> void

      # @return [Discorb::Snowflake] The ID of the integration.
      attr_reader id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Guild] The guild of the integration.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::User] The user associated with the integration.
      attr_reader user: Discorb::User?
    end

    #
    # Represents a `MESSAGE_REACTION_REMOVE_ALL` event.
    class ReactionRemoveAllEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the ReactionRemoveAllEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # Fetch the message.
      # If message is cached, it will be returned.
      # @async
      #
      # @param [Boolean] force Whether to force fetching the message.
      #
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: (?force: bool) -> Async::Task[Discorb::Message]

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?
    end

    #
    # Represents a `MESSAGE_REACTION_REMOVE_EMOJI` event.
    class ReactionRemoveEmojiEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the ReactionRemoveEmojiEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # Fetch the message.
      # If message is cached, it will be returned.
      # @async
      #
      # @param [Boolean] force Whether to force fetching the message.
      #
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: (?force: bool) -> Async::Task[Discorb::Message]

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader message_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::Message] The message the reaction was sent in.
      attr_reader message: Discorb::Message?

      # @return [Discorb::UnicodeEmoji, Discorb::PartialEmoji] The emoji that was reacted with.
      attr_reader emoji: (Discorb::UnicodeEmoji | Discorb::PartialEmoji)
    end

    #
    # Represents a `GUILD_SCHEDULED_EVENT_USER_ADD` and `GUILD_SCHEDULED_EVENT_USER_REMOVE` event.
    class ScheduledEventUserEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the ScheduledEventUserEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # @return [Discorb::User] The user that triggered the event.
      attr_reader user: Discorb::User

      # @return [Discorb::Guild] The guild the event was triggered in.
      attr_reader guild: Discorb::Guild

      # @return [Discorb::ScheduledEvent] The scheduled event.
      attr_reader scheduled_event: Discorb::ScheduledEvent
    end

    #
    # Represents a `MESSAGE_UPDATE` event.
    class MessageUpdateEvent < Discorb::Gateway::GatewayEvent
      # @!attribute [r] channel
      #   @macro client_cache
      #   @return [Discorb::Channel] The channel the message was sent in.
      # @!attribute [r] guild
      #   @macro client_cache
      #   @return [Discorb::Guild] The guild the message was sent in.
      def initialize: (
                        untyped client,
                        untyped data,
                        untyped before,
                        untyped after
                      ) -> void

      # Fetch the message.
      # @async
      #
      # @return [Async::Task<Discorb::Message>] The message.
      def fetch_message: () -> Async::Task[Discorb::Message]

      # @return [Discorb::Message] The message before update.
      attr_reader before: Discorb::Message

      # @return [Discorb::Message] The message after update.
      attr_reader after: Discorb::Message

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild the message was sent in.
      attr_reader guild_id: Discorb::Snowflake

      # @return [String] The new content of the message.
      attr_reader content: String

      # @return [Time] The time the message was edited.
      attr_reader timestamp: Time

      # @return [Boolean] Whether the message pings @everyone.
      attr_reader mention_everyone: bool

      # @macro client_cache
      # @return [Array<Discorb::Role>] The roles mentioned in the message.
      attr_reader mention_roles: ::Array[Discorb::Role]?

      # @return [Array<Discorb::Attachment>] The attachments in the message.
      attr_reader attachments: ::Array[Discorb::Attachment]

      # @return [Array<Discorb::Embed>] The embeds in the message.
      attr_reader embeds: ::Array[Discorb::Embed]

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    #
    # Represents a message but it has only ID.
    class UnknownDeleteBulkMessage < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the UnknownDeleteBulkMessage class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, _ToS id, ::Hash[untyped, untyped] data) -> void

      # @return [Discorb::Snowflake] The ID of the message.
      attr_reader id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    #
    # Represents a `INVITE_DELETE` event.
    class InviteDeleteEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the InviteDeleteEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # @return [String] The invite code.
      attr_reader code: String

      # @macro client_cache
      # @return [Discorb::Channel] The channel the message was sent in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the message was sent in.
      attr_reader guild: Discorb::Guild?
    end

    #
    # Represents a `TYPING_START` event.
    class TypingStartEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the TypingStartEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # @return [Discorb::Snowflake] The ID of the channel the user is typing in.
      attr_reader user_id: Discorb::Snowflake

      # @macro client_cache
      # @return [Discorb::Member] The member that is typing.
      attr_reader member: Discorb::Member?

      # @macro client_cache
      # @return [Discorb::Channel] The channel the user is typing in.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild the user is typing in.
      attr_reader guild: Discorb::Guild?

      # @macro client_cache
      # @return [Discorb::User] The user that is typing.
      attr_reader user: Discorb::User?

      # @macro client_cache
      # @return [Discorb::Member, Discorb::User] The member or user that started typing.
      attr_reader fired_by: (Discorb::Member | Discorb::User)?
    end

    #
    # Represents a message pin event.
    class MessagePinEvent < Discorb::Gateway::GatewayEvent
      # @!attribute [r] pinned?
      #   @return [Boolean] Whether the message was pinned.
      # @!attribute [r] unpinned?
      #   @return [Boolean] Whether the message was unpinned.
      def initialize: (untyped client, untyped data, untyped message) -> void

      # @return [Discorb::Message] The message that was pinned.
      attr_reader message: Discorb::Message

      # @return [:pinned, :unpinned] The type of event.
      attr_reader type: Symbol

      # @return [Boolean] Whether the message was pinned.
      attr_reader pinned?: bool

      # @return [Boolean] Whether the message was unpinned.
      attr_reader unpinned?: bool
    end

    #
    # Represents a `WEBHOOKS_UPDATE` event.
    class WebhooksUpdateEvent < Discorb::Gateway::GatewayEvent
      #
      # Initialize a new instance of the WebhooksUpdateEvent class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the event.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # @macro client_cache
      # @return [Discorb::Channel] The channel where the webhook was updated.
      attr_reader channel: Discorb::Channel?

      # @macro client_cache
      # @return [Discorb::Guild] The guild where the webhook was updated.
      attr_reader guild: Discorb::Guild?
    end

    #
    # A module to handle gateway events.
    module Handler
      def connect_gateway: (untyped reconnect) -> untyped

      def send_gateway: (untyped opcode, **untyped value) -> untyped

      def handle_gateway: (untyped payload, untyped reconnect) -> untyped

      def handle_heartbeat: () -> untyped

      def handle_event: (untyped event_name, untyped data) -> untyped

      def ready: () -> untyped
    end

    #
    # A class for connecting websocket with raw bytes data.
    # @private
    class RawConnection
      def initialize: () -> void

      def inspect: () -> untyped

      def closed?: () -> bool

      def close: () -> untyped

      def force_close: () -> untyped

      def io: () -> untyped

      def parse: (untyped buffer) -> untyped

      def dump: (untyped object) -> untyped
    end
  end

  # Represents intents.
  class Intents
    INTENT_BITS: untyped

    #
    # Create new intents object with default (no members and presence) intents.
    #
    # @param guilds [Boolean] Whether guild related events are enabled.
    # @param members [Boolean] Whether guild members related events are enabled.
    # @param bans [Boolean] Whether guild ban related events are enabled.
    # @param emojis [Boolean] Whether guild emojis related events are enabled.
    # @param integrations [Boolean] Whether guild integration related events are enabled.
    # @param webhooks [Boolean] Whether guild webhooks related events are enabled.
    # @param invites [Boolean] Whether guild invite related events are enabled.
    # @param voice_states [Boolean] Whether guild voice state related events are enabled.
    # @param presences [Boolean] Whether guild presences related events are enabled.
    # @param messages [Boolean] Whether guild messages related events are enabled.
    # @param reactions [Boolean] Whether guild reaction related events are enabled.
    # @param dm_messages [Boolean] Whether dm messages related events are enabled.
    # @param dm_reactions [Boolean] Whether dm reactions related events are enabled.
    # @param dm_typing [Boolean] Whether dm typing related events are enabled.
    # @param message_content [Boolean] Whether message content will be sent with events.
    # @param scheduled_events [Boolean] Whether events related scheduled events are enabled.
    #
    # @note You must enable privileged intents to use `members` and/or `presences` intents.
    # @note Message Content Intent is not required to use `message_content` intents for now,
    #   this will be required in September 1, 2022. [Learn More](https://support-dev.discord.com/hc/en-us/articles/4404772028055).
    #   You should specify `message_content` intent for preventing unexpected changes in the future.
    def initialize: (
                      ?guilds: bool,
                      ?members: bool,
                      ?bans: bool,
                      ?emojis: bool,
                      ?integrations: bool,
                      ?webhooks: bool,
                      ?invites: bool,
                      ?voice_states: bool,
                      ?presences: bool,
                      ?messages: bool,
                      ?reactions: bool,
                      ?typing: untyped,
                      ?dm_messages: bool,
                      ?dm_reactions: bool,
                      ?dm_typing: bool,
                      ?message_content: bool?,
                      ?scheduled_events: bool
                    ) -> void

    #
    # Returns the value of the flag.
    def method_missing: (untyped name, ?untyped args) -> untyped

    def respond_to_missing?: (untyped name, untyped include_private) -> bool

    # Returns value of the intent.
    # @return [Integer] The value of the intent.
    def value: () -> Integer

    def inspect: () -> untyped

    def to_h: () -> untyped

    # Create new intent object from raw value.
    # @param value [Integer] The value of the intent.
    def self.from_value: (Integer value) -> untyped

    # Create new intent object with all intents.
    def self.all: () -> untyped

    # Create new intent object with no intents.
    def self.none: () -> untyped
  end

  #
  # Represents a message in Discord.
  class Message < Discorb::DiscordModel
    MESSAGE_TYPE: untyped

    #
    # Initialize a new message.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the welcome screen.
    # @param [Boolean] no_cache Whether to disable caching.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data, ?no_cache: bool) -> void

    #
    # Removes the mentions from the message.
    #
    # @param [Boolean] user Whether to clean user mentions.
    # @param [Boolean] channel Whether to clean channel mentions.
    # @param [Boolean] role Whether to clean role mentions.
    # @param [Boolean] emoji Whether to clean emoji.
    # @param [Boolean] everyone Whether to clean `@everyone` and `@here`.
    # @param [Boolean] codeblock Whether to clean codeblocks.
    #
    # @return [String] The cleaned content of the message.
    def clean_content: (
                         ?user: bool,
                         ?channel: bool,
                         ?role: bool,
                         ?emoji: bool,
                         ?everyone: bool,
                         ?codeblock: bool
                       ) -> String

    #
    # Edit the message.
    # @async
    #
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Attachment>] attachments The new attachments.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    #
    # @return [Async::Task<void>] The task.
    def edit: (
                ?String content,
                ?embed: Discorb::Embed,
                ?embeds: ::Array[Discorb::Embed],
                ?allowed_mentions: Discorb::AllowedMentions,
                ?attachments: ::Array[Discorb::Attachment],
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]),
                ?supress: bool
              ) -> Async::Task[void]

    #
    # Delete the message.
    # @async
    #
    # @param [String] reason The reason for deleting the message.
    #
    # @return [Async::Task<void>] The task.
    def delete!: (?reason: String?) -> Async::Task[void]

    #
    # Convert the message to reference object.
    #
    # @param [Boolean] fail_if_not_exists Whether to raise an error if the message does not exist.
    #
    # @return [Hash] The reference object.
    def to_reference: (?fail_if_not_exists: bool) -> ::Hash[untyped, untyped]

    # Reply to the message.
    # @async
    # @param (see #post)
    # @return [Async::Task<Discorb::Message>] The message.
    def reply: (*untyped args, **untyped kwargs) -> Async::Task[Discorb::Message]

    #
    # Publish the message.
    # @async
    #
    # @return [Async::Task<void>] The task.
    def publish: () -> Async::Task[void]

    #
    # Add a reaction to the message.
    # @async
    #
    # @param [Discorb::Emoji] emoji The emoji to react with.
    #
    # @return [Async::Task<void>] The task.
    def add_reaction: (Discorb::Emoji emoji) -> Async::Task[void]

    #
    # Remove a reaction from the message.
    # @async
    #
    # @param [Discorb::Emoji] emoji The emoji to remove.
    #
    # @return [Async::Task<void>] The task.
    def remove_reaction: (Discorb::Emoji emoji) -> Async::Task[void]

    #
    # Remove other member's reaction from the message.
    # @async
    #
    # @param [Discorb::Emoji] emoji The emoji to remove.
    # @param [Discorb::Member] member The member to remove the reaction from.
    #
    # @return [Async::Task<void>] The task.
    def remove_reaction_of: (Discorb::Emoji emoji, Discorb::Member member) -> Async::Task[void]

    #
    # Fetch reacted users of reaction.
    # @async
    #
    # @param [Discorb::Emoji] emoji The emoji to fetch.
    # @param [Integer, nil] limit The maximum number of users to fetch. `nil` for no limit.
    # @param [Discorb::Snowflake, nil] after The ID of the user to start fetching from.
    #
    # @return [Async::Task<Array<Discorb::User>>] The users.
    def fetch_reacted_users: (Discorb::Emoji emoji, ?limit: Integer?, ?after: Discorb::Snowflake?) -> Async::Task[::Array[Discorb::User]]

    #
    # Pin the message.
    # @async
    #
    # @param [String] reason The reason for pinning the message.
    #
    # @return [Async::Task<void>] The task.
    def pin: (?reason: String?) -> Async::Task[void]

    #
    # Unpin the message.
    # @async
    #
    # @param [String] reason The reason for unpinning the message.
    #
    # @return [Async::Task<void>] The task.
    def unpin: (?reason: String?) -> Async::Task[void]

    #
    # Start thread from the message.
    # @async
    #
    # @param (see Discorb::Channel#start_thread)
    #
    # @return [Async::Task<Discorb::ThreadChannel>] <description>
    def start_thread: (*untyped args, **untyped kwargs) -> Async::Task[Discorb::ThreadChannel]

    # Meta
    def inspect: () -> untyped

    # @return [Discorb::Snowflake] The ID of the message.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::User, Discorb::Member] The user that sent the message.
    attr_reader author: (Discorb::User | Discorb::Member)

    # @return [String] The content of the message.
    attr_reader content: String

    # @return [Time] The time the message was created.
    attr_reader created_at: Time

    # @return [Time] The time the message was edited.
    # @return [nil] If the message was not edited.
    attr_reader updated_at: Time?

    # @return [Array<Discorb::Attachment>] The attachments of the message.
    attr_reader attachments: ::Array[Discorb::Attachment]

    # @return [Array<Discorb::Embed>] The embeds of the message.
    attr_reader embeds: ::Array[Discorb::Embed]

    # @return [Array<Discorb::Reaction>] The reactions of the message.
    attr_reader reactions: ::Array[Discorb::Reaction]

    # @return [Discorb::Snowflake] The ID of the channel the message was sent in.
    attr_reader webhook_id: Discorb::Snowflake

    # @return [Symbol] The type of the message.
    # Currently, this will be one of:
    #
    # * `:default`
    # * `:recipient_add`
    # * `:recipient_remove`
    # * `:call`
    # * `:channel_name_change`
    # * `:channel_icon_change`
    # * `:channel_pinned_message`
    # * `:guild_member_join`
    # * `:user_premium_guild_subscription`
    # * `:user_premium_guild_subscription_tier_1`
    # * `:user_premium_guild_subscription_tier_2`
    # * `:user_premium_guild_subscription_tier_3`
    # * `:channel_follow_add`
    # * `:guild_discovery_disqualified`
    # * `:guild_discovery_requalified`
    # * `:guild_discovery_grace_period_initial_warning`
    # * `:guild_discovery_grace_period_final_warning`
    # * `:thread_created`
    # * `:reply`
    # * `:chat_input_command`
    # * `:thread_starter_message`
    # * `:guild_invite_reminder`
    # * `:context_menu_command`
    attr_reader type: Symbol

    # @return [Discorb::Message::Activity] The activity of the message.
    attr_reader activity: Discorb::Message::Activity

    # @return [Discorb::Application] The application of the message.
    attr_reader application_id: Discorb::Application

    # @return [Discorb::Message::Reference] The reference of the message.
    attr_reader message_reference: Discorb::Message::Reference

    # @return [Discorb::Message::Flag] The flag of the message.
    # @see Discorb::Message::Flag
    attr_reader flag: Discorb::Message::Flag

    # @return [Discorb::Message::Sticker] The sticker of the message.
    attr_reader stickers: Discorb::Message::Sticker

    # @return [Discorb::Message::Interaction] The interaction of the message.
    attr_reader interaction: Discorb::Message::Interaction

    # @return [Discorb::ThreadChannel] The thread channel of the message.
    attr_reader thread: Discorb::ThreadChannel

    # @return [Array<Array<Discorb::Component>>] The components of the message.
    attr_reader components: ::Array[::Array[Discorb::Component]]

    # @return [Boolean] Whether the message is deleted.
    attr_reader deleted: bool

    # @return [Boolean] Whether the message is tts.
    attr_reader tts: bool

    # @return [Boolean] Whether the message mentions everyone.
    attr_reader mention_everyone: bool

    # @return [Boolean] Whether the message is pinned.
    attr_reader pinned: bool

    # @macro client_cache
    # @return [Discorb::Channel] The channel the message was sent in.
    attr_reader channel: Discorb::Channel?

    # @macro client_cache
    # @return [Discorb::Guild] The guild the message was sent in.
    # @return [nil] If the message was not sent in a guild.
    attr_reader guild: Discorb::Guild?

    # @return [Boolean] Whether the message was sent by a webhook.
    attr_reader webhook?: bool

    # @return [Boolean] Whether the message was edited.
    attr_reader edited?: bool

    # @return [String] The URL to jump to the message.
    attr_reader jump_url: String

    # @return [Discorb::Embed] The embed of the message.
    # @return [nil] If the message has no embed.
    attr_reader embed: Discorb::Embed?

    # @!attribute [r] channel
    #   @macro client_cache
    #   @return [Discorb::Channel] The channel the message was sent in.
    # @!attribute [r] guild
    #   @macro client_cache
    #   @return [Discorb::Guild] The guild the message was sent in.
    #   @return [nil] If the message was not sent in a guild.
    # @!attribute [r] webhook?
    #   @return [Boolean] Whether the message was sent by a webhook.
    # @!attribute [r] edited?
    #   @return [Boolean] Whether the message was edited.
    # @!attribute [r] jump_url
    #   @return [String] The URL to jump to the message.
    # @!attribute [r] embed
    #   @return [Discorb::Embed] The embed of the message.
    #   @return [nil] If the message has no embed.
    # @!attribute [r] embed?
    #   @return [Boolean] Whether the message has an embed.
    # @!attribute [r] reply?
    #   @return [Boolean] Whether the message is a reply.
    # @!attribute [r] dm?
    #   @return [Boolean] Whether the message was sent in a DM.
    # @!attribute [r] guild?
    #   @return [Boolean] Whether the message was sent in a guild.
    attr_reader embed?: bool

    # @return [Boolean] Whether the message is a reply.
    attr_reader reply?: bool

    # @return [Boolean] Whether the message was sent in a DM.
    attr_reader dm?: bool

    # @return [Boolean] Whether the message was sent in a guild.
    attr_reader guild?: bool

    #
    # Represents message flag.
    # ## Flag fields
    # |Field|Value|
    # |-|-|
    # |`1 << 0`|`:crossposted`|
    # |`1 << 1`|`:crosspost`|
    # |`1 << 2`|`:supress_embeds`|
    # |`1 << 3`|`:source_message_deleted`|
    # |`1 << 4`|`:urgent`|
    # |`1 << 5`|`:has_thread`|
    # |`1 << 6`|`:ephemeral`|
    # |`1 << 7`|`:loading`|
    class Flag < Discorb::Flag
    end

    #
    # Represents reference of message.
    class Reference
      #
      # Initialize a new reference.
      #
      # @param [Discorb::Snowflake] guild_id The guild ID.
      # @param [Discorb::Snowflake] channel_id The channel ID.
      # @param [Discorb::Snowflake] message_id The message ID.
      # @param [Boolean] fail_if_not_exists Whether fail the request if the message is not found.
      def initialize: (
                        Discorb::Snowflake guild_id,
                        Discorb::Snowflake channel_id,
                        Discorb::Snowflake message_id,
                        ?fail_if_not_exists: bool
                      ) -> void

      #
      # Convert the reference to a hash.
      #
      # @return [Hash] The hash.
      def to_hash: () -> ::Hash[untyped, untyped]

      #
      # Initialize a new reference from a hash.
      #
      # @param [Hash] data The hash.
      #
      # @return [Discorb::Message::Reference] The reference.
      # @see https://discord.com/developers/docs/resources/channel#message-reference-object
      def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::Message::Reference

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The guild ID.
      attr_accessor guild_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The channel ID.
      attr_accessor channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The message ID.
      attr_accessor message_id: Discorb::Snowflake

      # @return [Boolean] Whether fail the request if the message is not found.
      attr_accessor fail_if_not_exists: bool
    end

    #
    # Represents a sticker.
    class Sticker
      def initialize: (untyped data) -> void

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The sticker ID.
      attr_reader id: Discorb::Snowflake

      # @return [String] The sticker name.
      attr_reader name: String

      # @return [Symbol] The sticker format.
      attr_reader format: Symbol
    end

    #
    # Represents a interaction of message.
    class Interaction < Discorb::DiscordModel
      #
      # Initialize a new interaction.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Hash] data The interaction data.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The interaction ID.
      attr_reader id: Discorb::Snowflake

      # @return [String] The name of command.
      # @return [nil] If the message is not a command.
      attr_reader name: String?

      # @return [Class] The type of interaction.
      attr_reader type: Class

      # @return [Discorb::User] The user.
      attr_reader user: Discorb::User
    end

    #
    # Represents a activity of message.
    class Activity < Discorb::DiscordModel
      TYPES: untyped

      #
      # Initialize a new activity.
      # @private
      #
      # @param [Hash] data The activity data.
      def initialize: (::Hash[untyped, untyped] data) -> void

      def inspect: () -> untyped

      # @return [String] The name of activity.
      attr_reader name: String

      # @return [Symbol] The type of activity.
      attr_reader type: Symbol
    end
  end

  #
  # Module for sending and reading messages.
  module Messageable
    #
    # Post a message to the channel.
    # @async
    #
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::Attachment] attachment The attachment to send.
    # @param [Array<Discorb::Attachment>] attachments The attachments to send.
    #
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?attachment: Discorb::Attachment?,
                ?attachments: ::Array[Discorb::Attachment]?
              ) -> Async::Task[Discorb::Message]

    #
    # Edit a message.
    # @async
    # @!macro edit
    #
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Attachment>] attachments The new attachments.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    #
    # @return [Async::Task<void>] The task.
    def edit_message: (
                        _ToS message_id,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?allowed_mentions: Discorb::AllowedMentions,
                        ?attachments: ::Array[Discorb::Attachment],
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]),
                        ?supress: bool
                      ) -> Async::Task[void]

    #
    # Delete a message.
    # @async
    #
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    #
    # @return [Async::Task<void>] The task.
    def delete_message!: (_ToS message_id, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a message from ID.
    # @async
    #
    # @param [Discorb::Snowflake] id The ID of the message.
    #
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    #
    # Fetch a message history.
    # @async
    #
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    #
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    #
    # Fetch the pinned messages in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    #
    # Pin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    #
    # @return [Async::Task<void>] The task.
    def pin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Unpin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    #
    # @return [Async::Task<void>] The task.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Trigger the typing indicator in the channel.
    # @async
    #
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  #
  # Module for connecting to a voice channel.
  # This will be discord-voice gem.
  module Connectable
    def connect: () -> untyped
  end

  #
  # Represents a sticker.
  class Sticker < Discorb::DiscordModel
    STICKER_TYPE: untyped
    STICKER_FORMAT: untyped

    #
    # Initialize a new sticker.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The sticker data.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    # @return [Discorb::Snowflake] The ID of the sticker.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the sticker.
    attr_reader name: String

    # @return [Array<String>] The tags of the sticker.
    attr_reader tags: ::Array[String]

    # @return [:official, :guild] The type of sticker.
    attr_reader type: Symbol

    # @return [:png, :apng, :lottie] The format of the sticker.
    attr_reader format: Symbol

    # @return [String] The URL of the sticker.
    attr_reader description: String

    # @return [Discorb::Sticker] The ID of the sticker pack.
    attr_reader pack_id: Discorb::Sticker

    # @return [Integer] The sort value of the sticker.
    attr_reader sort_value: Integer

    # @return [Discorb::Snowflake] The ID of the guild the sticker is in.
    attr_reader guild_id: Discorb::Snowflake

    # @return [Discorb::User] The user who created the sticker.
    attr_reader user: Discorb::User

    # @return [Boolean] Whether the sticker is available.
    attr_reader available: bool

    #
    # Represents a sticker of guilds.
    class GuildSticker < Discorb::Sticker
      STICKER_TYPE: untyped
      STICKER_FORMAT: untyped

      #
      # Edits the sticker.
      # @async
      # @macro edit
      #
      # @param [String] name The new name of the sticker.
      # @param [String] description The new description of the sticker.
      # @param [Discorb::Emoji] tag The new tags of the sticker.
      # @param [String] reason The reason for the edit.
      #
      # @return [Async::Task<void>] The task.
      def edit: (
                  ?name: String,
                  ?description: String,
                  ?tag: Discorb::Emoji,
                  ?reason: String
                ) -> Async::Task[void]

      #
      # Deletes the sticker.
      # @async
      #
      # @param [String] reason The reason for the deletion.
      def delete!: (?reason: String?) -> untyped

      # @!attribute [r] guild
      #   @macro client_cache
      #   @return [Discorb::Guild] The guild the sticker is in.
      attr_reader guild: untyped
    end

    #
    # Represents a sticker pack.
    class Pack < Discorb::DiscordModel
      #
      # Initialize a new sticker pack.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Hash] data The sticker pack data.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # @return [Discorb::Snowflake] The ID of the sticker pack.
      attr_reader id: Discorb::Snowflake

      # @return [String] The name of the sticker pack.
      attr_reader name: String

      # @return [Discorb::Snowflake] The cover sticker of the pack.
      attr_reader cover_sticker_id: Discorb::Snowflake

      # @return [String] The description of the pack.
      attr_reader description: String

      # @return [Array<Discorb::Sticker>] The stickers in the pack.
      attr_reader stickers: ::Array[Discorb::Sticker]

      # @return [Discorb::Asset] The banner of the pack.
      attr_reader banner: Discorb::Asset
    end
  end

  #
  # Represents a webhook.
  # @abstract
  class Webhook
    #
    # Initializes a webhook.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the webhook.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    def inspect: () -> untyped

    #
    # Posts a message to the webhook.
    # @async
    #
    # @param [String] content The content of the message.
    # @param [Boolean] tts Whether the message should be sent as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Discorb::Attachment] attachment The attachment to send.
    # @param [Array<Discorb::Attachment>] attachment The attachments to send.
    # @param [String] username The username of the message.
    # @param [String] avatar_url The avatar URL of the message.
    # @param [Boolean] wait Whether to wait for the message to be sent.
    #
    # @return [Discorb::Webhook::Message] The message that was sent.
    # @return [Async::Task<nil>] If `wait` is false.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?attachment: Discorb::Attachment?,
                ?attachments: untyped,
                ?username: String?,
                ?avatar_url: String,
                ?wait: bool
              ) -> Discorb::Webhook::Message

    #
    # Edits the webhook.
    # @async
    # @macro edit
    #
    # @param [String] name The new name of the webhook.
    # @param [Discorb::Image] avatar The new avatar of the webhook.
    # @param [Discorb::GuildChannel] channel The new channel of the webhook.
    #
    # @return [Async::Task<void>] The task.
    def edit: (?name: String, ?avatar: Discorb::Image, ?channel: Discorb::GuildChannel) -> Async::Task[void]

    #
    # Deletes the webhook.
    # @async
    #
    # @return [Async::Task<void>] The task.
    def delete!: () -> Async::Task[void]

    #
    # Edits the webhook's message.
    # @async
    # @macro edit
    #
    # @param [Discorb::Webhook::Message] message The message to edit.
    # @param [String] content The new content of the message.
    # @param [Discorb::Embed] embed The new embed of the message.
    # @param [Array<Discorb::Embed>] embeds The new embeds of the message.
    # @param [Array<Discorb::Attachment>] attachments The attachments to remain.
    # @param [Discorb::Attachment] file The file to send.
    # @param [Array<Discorb::Attachment>] files The files to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    #
    # @return [Async::Task<void>] The task.
    def edit_message: (
                        Discorb::Webhook::Message message,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?file: Discorb::Attachment,
                        ?files: ::Array[Discorb::Attachment],
                        ?attachments: ::Array[Discorb::Attachment],
                        ?allowed_mentions: Discorb::AllowedMentions
                      ) -> Async::Task[void]

    #
    # Deletes the webhook's message.
    #
    # @param [Discorb::Webhook::Message] message The message to delete.
    #
    # @return [Async::Task<void>] The task.
    def delete_message!: (Discorb::Webhook::Message message) -> Async::Task[void]

    #
    # Creates URLWebhook.
    #
    # @param [String] url The URL of the webhook.
    #
    # @return [Discorb::Webhook::URLWebhook] The URLWebhook.
    def self.new: (String url) -> Discorb::Webhook::URLWebhook

    #
    # Creates Webhook with discord data.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the webhook.
    #
    # @return [Discorb::Webhook] The Webhook.
    def self.from_data: (Discorb::Client client, ::Hash[untyped, untyped] data) -> Discorb::Webhook

    def self.from_url: (untyped url) -> untyped

    # @return [String] The name of the webhook.
    attr_reader name: String

    # @return [Discorb::Snowflake] The ID of the guild this webhook belongs to.
    attr_reader guild_id: Discorb::Snowflake

    # @return [Discorb::Snowflake] The ID of the channel this webhook belongs to.
    attr_reader channel_id: Discorb::Snowflake

    # @return [Discorb::User] The user that created this webhook.
    attr_reader user: Discorb::User

    # @return [Discorb::Asset] The avatar of the webhook.
    attr_reader avatar: Discorb::Asset

    # @return [Discorb::Snowflake] The application ID of the webhook.
    # @return [nil] If the webhook is not an application webhook.
    attr_reader application_id: Discorb::Snowflake?

    # @return [String] The URL of the webhook.
    attr_reader token: String

    #
    # Represents a webhook from URL.
    class URLWebhook < Discorb::Webhook
      #
      # Initializes the webhook from URL.
      #
      # @param [String] url The URL of the webhook.
      def initialize: (String url) -> void

      # @return [String] The URL of the webhook.
      attr_reader url: String
    end

    #
    # Represents a bot created webhook.
    class IncomingWebhook < Discorb::Webhook
      #
      # Initializes the incoming webhook.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [String] url The URL of the webhook.
      def initialize: (Discorb::Client client, untyped data) -> void

      # @return [String] The URL of the webhook.
      attr_reader url: String
    end

    #
    # Represents a webhook of channel following.
    class FollowerWebhook < Discorb::Webhook
      #
      # Initializes the follower webhook.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Hash] data The data of the follower webhook.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # Represents a source guild of follower webhook.
      # @return [Discorb::Guild, Discorb::Webhook::FollowerWebhook::Guild] The source guild of follower webhook.
      attr_reader source_guild: (Discorb::Guild | Discorb::Webhook::FollowerWebhook::Guild)

      # Represents a source channel of follower webhook.
      # @return [Discorb::Channel, Discorb::Webhook::FollowerWebhook::Channel] The source channel of follower webhook.
      attr_reader source_channel: (Discorb::Channel | Discorb::Webhook::FollowerWebhook::Channel)

      #
      # Represents a guild of follower webhook.
      class Guild < Discorb::DiscordModel
        #
        # Initialize a new guild.
        # @private
        #
        # @param [Hash] data The data of the guild.
        def initialize: (::Hash[untyped, untyped] data) -> void

        def inspect: () -> untyped

        # @return [Discorb::Snowflake] The ID of the guild.
        attr_reader id: Discorb::Snowflake

        # @return [String] The name of the guild.
        attr_reader name: String

        # @return [Discorb::Asset] The icon of the guild.
        attr_reader icon: Discorb::Asset
      end

      #
      # Represents a channel of follower webhook.
      class Channel < Discorb::DiscordModel
        #
        # Initialize a new channel.
        # @private
        #
        # @param [Hash] data The data of the channel.
        def initialize: (::Hash[untyped, untyped] data) -> void

        def inspect: () -> untyped

        # @return [Discorb::Snowflake] The ID of the channel.
        attr_reader id: Discorb::Snowflake

        # @return [String] The name of the channel.
        attr_reader name: String
      end
    end

    #
    # Represents a webhook from oauth2.
    class ApplicationWebhook < Discorb::Webhook
    end

    #
    # Represents a webhook message.
    class Message < Discorb::Message
      MESSAGE_TYPE: untyped

      #
      # Initializes the message.
      # @private
      #
      # @param [Discorb::Webhook] webhook The webhook.
      # @param [Hash] data The data of the message.
      # @param [Discorb::Client] client The client. This will be nil if it's created from {URLWebhook}.
      def initialize: (Discorb::Webhook webhook, ::Hash[untyped, untyped] data, ?Discorb::Client? client) -> void

      #
      # Edits the message.
      # @async
      # @macro edit
      #
      # @param (see Webhook#edit_message)
      #
      # @return [Async::Task<void>] The task.
      def edit: () -> Async::Task[void]

      #
      # Deletes the message.
      # @async
      #
      # @return [Async::Task<void>] The task.
      def delete!: () -> Async::Task[void]

      # @return [Discorb::Snowflake] The ID of the channel.
      attr_reader channel_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the guild.
      attr_reader guild_id: Discorb::Snowflake

      #
      # Represents an author of webhook message.
      class Author < Discorb::DiscordModel
        #
        # Initializes the author.
        # @private
        #
        # @param [Hash] data The data of the author.
        def initialize: (::Hash[untyped, untyped] data) -> void

        #
        # Format author with `Name#Discriminator` style.
        #
        # @return [String] Formatted author.
        def to_s: () -> String

        def inspect: () -> untyped

        # @return [Boolean] Whether the author is a bot.
        # @note This will be always `true`.
        attr_reader bot: bool

        # @return [Discorb::Snowflake] The ID of the author.
        attr_reader id: Discorb::Snowflake

        # @return [String] The name of the author.
        attr_reader username: String

        # @return [Discorb::Asset] The avatar of the author.
        attr_reader avatar: Discorb::Asset

        # @return [String] The discriminator of the author.
        attr_reader discriminator: String
      end
    end
  end

  #
  # Represents a presence of user.
  class Presence < Discorb::DiscordModel
    #
    # Initialize a presence.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the presence.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    def inspect: () -> untyped

    # @return [:online, :idle, :dnd, :offline] The status of the user.
    attr_reader status: Symbol

    # @return [Array<Discorb::Presence::Activity>] The activities of the user.
    attr_reader activities: ::Array[Discorb::Presence::Activity]

    # @return [Discorb::Presence::ClientStatus] The client status of the user.
    attr_reader client_status: Discorb::Presence::ClientStatus

    # @return [Discorb::User] The user of the presence.
    attr_reader user: Discorb::User

    # @return [Discorb::Guild] The guild of the presence.
    attr_reader guild: Discorb::Guild

    # @return [Discorb::Presence::Activity] The activity of the presence.
    attr_reader activity: Discorb::Presence::Activity

    #
    # Represents an activity of a user.
    class Activity < Discorb::DiscordModel
      ACTIVITY_TYPES: untyped

      #
      # Initialize the activity.
      # @private
      #
      # @param [Hash] data The activity data.
      def initialize: (::Hash[untyped, untyped] data) -> void

      #
      # Convert the activity to a string.
      #
      # @return [String] The string representation of the activity.
      def to_s: () -> String

      # @return [String] The name of the activity.
      attr_reader name: String

      # @return [:game, :streaming, :listening, :watching, :custom, :competing] The type of the activity.
      attr_reader type: Symbol

      # @return [String] The url of the activity.
      attr_reader url: String

      # @return [Time] The time the activity was created.
      attr_reader created_at: Time

      # @return [Discorb::Presence::Activity::Timestamps] The timestamps of the activity.
      attr_reader timestamps: Discorb::Presence::Activity::Timestamps

      # @return [Discorb::Snowflake] The application id of the activity.
      attr_reader application_id: Discorb::Snowflake

      # @return [String] The details of the activity.
      attr_reader details: String

      # @return [String] The state of party.
      attr_reader state: String

      # @return [Discorb::Emoji] The emoji of the activity.
      attr_reader emoji: Discorb::Emoji

      # @return [Discorb::Presence::Activity::Party] The party of the activity.
      # @return [nil] If the activity is not a party activity.
      attr_reader party: Discorb::Presence::Activity::Party?

      # @return [Discorb::Presence::Activity::Asset] The assets of the activity.
      # @return [nil] If the activity has no assets.
      attr_reader assets: Discorb::Presence::Activity::Asset?

      # @return [Discorb::StageInstance] The instance of the activity.
      # @return [nil] If the activity is not a stage activity.
      attr_reader instance: Discorb::StageInstance?

      # @return [Array<Discorb::Presence::Activity::Button>] The buttons of the activity.
      # @return [nil] If the activity has no buttons.
      attr_reader buttons: ::Array[Discorb::Presence::Activity::Button]?

      # @return [Discorb::Presence::Activity::Flag] The flags of the activity.
      attr_reader flags: Discorb::Presence::Activity::Flag

      #
      # Represents the timestamps of an activity.
      class Timestamps < Discorb::DiscordModel
        #
        # Initialize the timestamps.
        # @private
        #
        # @param [Hash] data The timestamps data.
        def initialize: (::Hash[untyped, untyped] data) -> void

        # @return [Time] The start time of the activity.
        attr_reader start: Time

        # @return [Time] The end time of the activity.
        attr_reader end: Time
      end

      #
      # Represents the party of an activity.
      class Party < Discorb::DiscordModel
        #
        # Initialize the party.
        # @private
        #
        # @param [Hash] data The party data.
        def initialize: (::Hash[untyped, untyped] data) -> void

        # @return [String] The id of the party.
        attr_reader id: String

        # @return [Integer] The current size of the party.
        attr_reader current_size: Integer

        # @return [Integer] The max size of the party.
        attr_reader max_size: Integer
      end

      #
      # Represents the assets of an activity.
      class Asset < Discorb::DiscordModel
        def initialize: (untyped data) -> void

        # @return [String] The large image ID or URL of the asset.
        attr_reader large_image: String

        # @return [String] The large text of the activity.
        attr_reader large_text: String

        # @return [String] The small image ID or URL of the activity.
        attr_reader small_image: String

        # @return [String] The small text of the activity.
        attr_reader small_text: String
      end

      #
      # Represents the flags of an activity.
      # ## Flag fields
      # |`1 << 0`|`:instance`|
      # |`1 << 1`|`:join`|
      # |`1 << 2`|`:spectate`|
      # |`1 << 3`|`:join_request`|
      # |`1 << 4`|`:sync`|
      # |`1 << 5`|`:play`|
      class Flag < Discorb::Flag
      end

      #
      # Represents a secrets of an activity.
      class Secrets < Discorb::DiscordModel
        #
        # Initialize the secrets.
        # @private
        #
        # @param [Hash] data The secrets data.
        def initialize: (::Hash[untyped, untyped] data) -> void

        # @return [String] The join secret of the activity.
        attr_reader join: String

        # @return [String] The spectate secret of the activity.
        attr_reader spectate: String

        # @return [String] The match secret of the activity.
        attr_reader match: String
      end

      #
      # Represents a button of an activity.
      class Button < Discorb::DiscordModel
        #
        # Initialize the button.
        # @private
        #
        # @param [Hash] data The button data.
        def initialize: (::Hash[untyped, untyped] data) -> void

        # @return [String] The text of the button.
        attr_reader label: String

        # @return [String] The URL of the button.
        attr_reader url: String
      end
    end

    #
    # Represents a user's client status.
    class ClientStatus < Discorb::DiscordModel
      #
      # Initialize the client status.
      # @private
      #
      # @param [Hash] data The client status data.
      def initialize: (::Hash[untyped, untyped] data) -> void

      # @return [Symbol] The desktop status of the user.
      attr_reader desktop: Symbol

      # @return [Symbol] The mobile status of the user.
      attr_reader mobile: Symbol

      # @return [Symbol] The web status of the user.
      attr_reader web: Symbol

      # @return [Boolean] Whether the user is not offline on desktop.
      attr_reader desktop?: bool

      # @return [Boolean] Whether the user is not offline on mobile.
      attr_reader mobile?: bool

      # @return [Boolean] Whether the user is not offline on web.
      attr_reader web?: bool
    end
  end

  #
  # Represents a reaction to a message.
  class Reaction < Discorb::DiscordModel
    #
    # Initialize a new reaction.
    # @private
    #
    # @param [Discorb::Message] message The message that this reaction is on.
    # @param [Hash] data The data of the reaction.
    def initialize: (Discorb::Message message, ::Hash[untyped, untyped] data) -> void

    #
    # Fetch the user that reacted with this emoji.
    #
    # @param (see Message#fetch_reacted_users)
    #
    # @return [Array<Discorb::User>] The users that reacted with this emoji.
    def fetch_users: () -> ::Array[Discorb::User]

    # @return [Integer] The number of users that have reacted with this emoji.
    attr_reader count: Integer

    # @return [Discorb::Emoji] The emoji that was reacted with.
    attr_reader emoji: Discorb::Emoji

    # @return [Discorb::Message] The message that this reaction is on.
    attr_reader message: Discorb::Message

    # @return [Boolean] Whether client user reacted with this emoji.
    attr_reader me: bool
  end

  #
  # Abstract class to make extension.
  # Include from this module to make your own extension.
  # @see file:docs/extension.md Extension
  # @abstract
  module Extension
    def initialize: (untyped client) -> void

    def events: () -> untyped

    def self.included: (untyped base) -> untyped

    #
    # @private
    # Module for adding class methods to the extension class.
    module ClassMethods
      include Discorb::ApplicationCommand::Handler

      #
      # Define a new event.
      #
      # @param [Symbol] event_name The name of the event.
      # @param [Symbol] id The id of the event. Used to delete the event.
      # @param [Hash] metadata Other metadata.
      #
      # @return [Discorb::EventHandler] The event.
      def event: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] metadata) -> Discorb::EventHandler

      #
      # Define a new once event.
      #
      # @param [Symbol] event_name The name of the event.
      # @param [Symbol] id The id of the event. Used to delete the event.
      # @param [Hash] metadata Other metadata.
      # @param [Proc] block The block to execute when the event is triggered.
      #
      # @return [Discorb::EventHandler] The event.
      def once_event: (Symbol event_name, ?id: Symbol?, **::Hash[untyped, untyped] metadata) -> Discorb::EventHandler

      def self.extended: (untyped klass) -> untyped

      #
      # Add new top-level command.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      #  If hash is passed, it must be a pair of Language code and Command name, and `:default` key is required.
      #  You can use `_` instead of `-` in language code.
      # @param [String, Hash{Symbol => String}] description Command description.
      #   If hash is passed, it must be a pair of Language code and Command description, and `:default` key is required.
      #  You can use `_` instead of `-` in language code.
      # @param [Hash{String => Hash{:description => String, :optional => Boolean, :type => Object}}] options
      #  Command options.
      #   The key is the option name, the value is a hash with the following keys:
      #
      #   | Key | Type | Description |
      #   | --- | --- | --- |
      #   | `:name_localizations` | Hash{Symbol => String} | Localizations of option name. |
      #   | `:description` | `String` \| `Hash{Symbol => String}` |
      #     Description of the option. If hash is passed, it must be a pair of Language code and description,
      #     and `:default` key is required. You can use `_` instead of `-` in language code. |
      #   | `:required` | Boolean(true | false) |
      #     Whether the argument is required. `optional` will be used if not specified. |
      #   | `:optional` | Boolean(true | false) |
      #     Whether the argument is optional. `required` will be used if not specified. |
      #   | `:type` | `Object` | Type of the option. |
      #   | `:choices` | `Hash{String => String, Integer, Float}` | Type of the option. |
      #   | `:choices_localizations` | `Hash{String => Hash{Symbol => String}}` |
      #      Localization of the choice. Key must be the name of a choice. |
      #   | `:default` | `Object` | Default value of the option. |
      #   | `:channel_types` | `Array<Class<Discorb::Channel>>` | Type of the channel option. |
      #   | `:autocomplete` | `Proc` | Autocomplete function. |
      #   | `:range` | `Range` | Range of the option. Only valid for numeric options. (`:int`, `:float`) |
      #
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      # @param [Proc] block Command block.
      #
      # @return [Discorb::ApplicationCommand::Command::ChatInputCommand] Command object.
      #
      # @see file:docs/application_command.md#register-slash-command Application Comamnds: Register Slash Command
      # @see file:docs/cli/setup.md CLI: setup
      def slash: (
                   (String | ::Hash[Symbol, String]) command_name,
                   (String | ::Hash[Symbol, String]) description,
                   ?::Hash[String, String | Integer | Float] options,
                   ?guild_ids: (::Array[untyped] | bool)?,
                   ?dm_permission: bool,
                   ?default_permission: Discorb::Permission?
                 ) -> Discorb::ApplicationCommand::Command::ChatInputCommand

      #
      # Add new command with group.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      # @param [String, Hash{Symbol => String}] description Command description.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      #
      # @yield Block to yield with the command.
      # @yieldparam [Discorb::ApplicationCommand::Command::GroupCommand] group Group command.
      #
      # @return [Discorb::ApplicationCommand::Command::GroupCommand] Command object.
      #
      # @see file:docs/application_command.md Application Commands
      # @see file:docs/cli/setup.md CLI: setup
      def slash_group: (
                         (String | ::Hash[Symbol, String]) command_name,
                         (String | ::Hash[Symbol, String]) description,
                         ?guild_ids: (::Array[untyped] | bool)?,
                         ?dm_permission: bool,
                         ?default_permission: Discorb::Permission?
                       ) ?{ (Discorb::ApplicationCommand::Command::GroupCommand group) -> void } -> Discorb::ApplicationCommand::Command::GroupCommand

      #
      # Add message context menu command.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      # @param [Proc] block Command block.
      # @yield [interaction, message] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::Message] message Message object.
      #
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def message_command: (
                             (String | ::Hash[Symbol, String]) command_name,
                             ?guild_ids: (::Array[untyped] | bool)?,
                             ?dm_permission: bool,
                             ?default_permission: Discorb::Permission?
                           ) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::Message message) -> void } -> Discorb::ApplicationCommand::Command

      #
      # Add user context menu command.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      # @param [Proc] block Command block.
      # @yield [interaction, user] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::User] user User object.
      #
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def user_command: (
                          (String | ::Hash[Symbol, String]) command_name,
                          ?guild_ids: (::Array[untyped] | bool)?,
                          ?dm_permission: bool,
                          ?default_permission: Discorb::Permission?
                        ) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::User user) -> void } -> Discorb::ApplicationCommand::Command

      #
      # Setup commands.
      # @async
      # @see Client#initialize
      #
      # @param [String] token Bot token.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to use as default. If `false` is given, it will be global command.
      #
      # @note `token` parameter only required if you don't run client.
      def setup_commands: (?String? token, ?guild_ids: (::Array[untyped] | bool)?) -> untyped

      #
      # Claer commands in specified guilds.
      # @async
      # @see Client#initialize
      #
      # @param [String] token Bot token.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to clear.
      #
      # @note `token` parameter only required if you don't run client.
      def clear_commands: (String token, (::Array[untyped] | bool)? guild_ids) -> untyped

      # @return [Hash{Symbol => Array<Discorb::EventHandler>}] The events of the extension.
      attr_reader events: ::Hash[Symbol, ::Array[Discorb::EventHandler]]

      # @return [Array<Discorb::ApplicationCommand::Command>] The commands of the extension.
      attr_reader commands: ::Array[Discorb::ApplicationCommand::Command]

      # @private
      attr_reader callable_commands: untyped
    end
  end

  #
  # Represents a attachment file.
  class Attachment
    #
    # Creates a new attachment.
    #
    # @param [#read, String] source The Source of the attachment.
    # @param [String] filename The filename of the attachment. If not set, path or object_id of the IO is used.
    # @param [String] description The description of the attachment.
    # @param [String] content_type The content type of the attachment. If not set, it is guessed from the filename.
    #   If failed to guess, it is set to `application/octet-stream`.
    # @param [Boolean] will_close Whether the IO will be closed after the attachment is sent.
    def initialize: (
                      (untyped | String) source,
                      ?String? filename,
                      ?description: String?,
                      ?content_type: String?,
                      ?will_close: bool
                    ) -> void

    #
    # Initializes the object from a hash.
    # @private
    def initialize_hash: (untyped data) -> untyped

    def inspect: () -> untyped

    #
    # Creates a new file from a hash.
    # @private
    def self.from_hash: (untyped data) -> untyped

    #
    # Creates a new file from a string.
    #
    # @param [String] string The string to create the file from.
    # @param [String] filename The filename of the file. object_id of the string is used if not set.
    # @param [String] content_type The content type of the file. If not set, it is guessed from the filename.
    #
    # @return [Discorb::Attachment] The new file.
    def self.from_string: (
                            String string,
                            ?String? filename,
                            ?content_type: String?,
                            ?description: untyped
                          ) -> Discorb::Attachment

    # @return [#read] The file content.
    attr_reader io: untyped

    # @return [String] The attachment filename.
    attr_reader filename: String

    # @return [String] The attachment content type.
    attr_reader content_type: String

    # @return [String] The attachment description.
    attr_reader description: String

    # @return [Discorb::Snowflake] The attachment id.
    attr_reader id: Discorb::Snowflake

    # @return [Integer] The attachment size in bytes.
    attr_reader size: Integer

    # @return [String] The attachment url.
    attr_reader url: String

    # @return [String] The attachment proxy url.
    attr_reader proxy_url: String

    # @return [Integer] The image height.
    # @return [nil] If the attachment is not an image.
    attr_reader height: Integer?

    # @return [Integer] The image width.
    # @return [nil] If the attachment is not an image.
    attr_reader width: Integer?

    # @return [:client, :discord] The attachment was created by.
    attr_reader created_by: Symbol

    # @private
    # @return [Boolean] Whether the attachment will be closed after it is sent.
    attr_reader will_close: bool

    # @return [Boolean] whether the file is an image.
    attr_reader image?: bool
  end

  #
  # Represents a Discord audit log.
  class AuditLog < Discorb::DiscordModel
    #
    # Initializes a new instance of the AuditLog class.
    # @private
    def initialize: (untyped client, untyped data, untyped guild) -> void

    def inspect: () -> untyped

    #
    # Gets an entry from entries.
    #
    # @param [Integer] index The index of the entry.
    #
    # @return [Discorb::AuditLog::Entry] The entry.
    # @return [nil] If the index is out of range.
    def []: (Integer index) -> Discorb::AuditLog::Entry

    # @return [Array<Discorb::Webhook>] The webhooks in this audit log.
    attr_reader webhooks: ::Array[Discorb::Webhook]

    # @return [Array<Discorb::User>] The users in this audit log.
    attr_reader users: ::Array[Discorb::User]

    # @return [Array<Discorb::ThreadChannel>] The threads in this audit log.
    attr_reader threads: ::Array[Discorb::ThreadChannel]

    # @return [Array<Discorb::AuditLog::Entry>] The entries in this audit log.
    attr_reader entries: ::Array[Discorb::AuditLog::Entry]

    #
    # Represents an entry in an audit log.
    class Entry < Discorb::DiscordModel
      EVENTS: untyped
      CONVERTERS: untyped

      #
      # Initializes a new AuditLog entry.
      # @private
      def initialize: (untyped client, untyped data, _ToS guild_id) -> void

      #
      # Get a change with the given key.
      #
      # @param [Symbol] key The key to get.
      #
      # @return [Discorb::AuditLog::Entry::Change] The change with the given key.
      # @return [nil] The change with the given key does not exist.
      def []: (Symbol key) -> Discorb::AuditLog::Entry::Change

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The ID of the entry.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the user who performed the action.
      attr_reader user_id: Discorb::Snowflake

      # @return [Discorb::Snowflake] The ID of the target of the action.
      attr_reader target_id: Discorb::Snowflake

      # @return [Symbol] The type of the entry.
      # These symbols will be used:
      #
      # * `:guild_update`
      # * `:channel_create`
      # * `:channel_update`
      # * `:channel_delete`
      # * `:channel_overwrite_create`
      # * `:channel_overwrite_update`
      # * `:channel_overwrite_delete`
      # * `:member_kick`
      # * `:member_prune`
      # * `:member_ban_add`
      # * `:member_ban_remove`
      # * `:member_update`
      # * `:member_role_update`
      # * `:member_move`
      # * `:member_disconnect`
      # * `:bot_add`
      # * `:role_create`
      # * `:role_update`
      # * `:role_delete`
      # * `:invite_create`
      # * `:invite_update`
      # * `:invite_delete`
      # * `:webhook_create`
      # * `:webhook_update`
      # * `:webhook_delete`
      # * `:emoji_create`
      # * `:emoji_update`
      # * `:emoji_delete`
      # * `:message_delete`
      # * `:message_bulk_delete`
      # * `:message_pin`
      # * `:message_unpin`
      # * `:integration_create`
      # * `:integration_update`
      # * `:integration_delete`
      # * `:stage_instance_create`
      # * `:stage_instance_update`
      # * `:stage_instance_delete`
      # * `:sticker_create`
      # * `:sticker_update`
      # * `:sticker_delete`
      # * `:guild_scheduled_event_create`
      # * `:guild_scheduled_event_update`
      # * `:guild_scheduled_event_delete`
      # * `:thread_create`
      # * `:thread_update`
      # * `:thread_delete`
      # * `:application_command_permission_update``
      attr_reader type: Symbol

      # @return [Discorb::AuditLog::Entry::Changes] The changes in this entry.
      attr_reader changes: Discorb::AuditLog::Entry::Changes

      # @return [Discorb::Channel, Discorb::Role, Discorb::Member, Discorb::Guild, Discorb::Message]
      #   The target of the entry.
      attr_reader target: (Discorb::Channel | Discorb::Role | Discorb::Member | Discorb::Guild | Discorb::Message)

      # @return [Hash{Symbol => Object}] The optional data for this entry.
      # @note You can use dot notation to access the data.
      attr_reader options: ::Hash[Symbol, Object]

      # @return [Discorb::User] The user who performed the action.
      attr_reader user: Discorb::User

      #
      # Represents the changes in an audit log entry.
      class Changes < Discorb::DiscordModel
        #
        # Initializes a new changes object.
        # @private
        #
        # @param [Hash] data The data to initialize with.
        def initialize: (::Hash[untyped, untyped] data) -> void

        #
        # Formats the changes into a string.
        def inspect: () -> untyped

        #
        # Get keys of changes.
        #
        # @return [Array<Symbol>] The keys of the changes.
        def keys: () -> ::Array[Symbol]

        #
        # Get a change with the given key.
        #
        # @param [Symbol] key The key to get.
        #
        # @return [Discorb::AuditLog::Entry::Change] The change with the given key.
        # @return [nil] The change with the given key does not exist.
        def []: (Symbol key) -> Discorb::AuditLog::Entry::Change

        # Returns the value of attribute data.
        attr_reader data: untyped
      end

      #
      # Represents a change in an audit log entry.
      # @note This instance will try to call a method of {#new_value} if the method wasn't defined.
      class Change < Discorb::DiscordModel
        #
        # Initializes a new change object.
        # @private
        def initialize: (untyped data) -> void

        #
        # Send a message to the new value.
        def method_missing: (untyped method) -> untyped

        #
        # Format the change into a string.
        #
        # @return [String] The string representation of the change.
        def inspect: () -> String

        #
        # Whether the change responds to the given method.
        #
        # @return [Boolean] Whether the change responds to the given method.
        def respond_to_missing?: (untyped method, ?untyped include_private) -> bool

        # @return [Symbol] The key of the change.
        attr_reader key: Symbol

        # @return [Object] The old value of the change.
        attr_reader old_value: Object

        # @return [Object] The new value of the change.
        attr_reader new_value: Object
      end
    end

    #
    # Represents an integration in an audit log entry.
    class Integration < Discorb::DiscordModel
      #
      # Initializes a new integration object.
      # @private
      def initialize: (untyped data) -> void

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The ID of the integration.
      attr_reader id: Discorb::Snowflake

      # @return [Symbol] The type of the integration.
      attr_reader type: Symbol

      # @return [String] The name of the integration.
      attr_reader name: String

      # @return [Discorb::Integration::Account] The account of the integration.
      attr_reader account: Discorb::Integration::Account
    end
  end

  #
  # Represents a DM channel.
  class DMChannel < Discorb::Channel
    include Discorb::Messageable

    #
    # Returns the channel id to request.
    # @private
    #
    # @return [Async::Task<Discorb::Snowflake>] A task that resolves to the channel id.
    def channel_id: () -> Async::Task[Discorb::Snowflake]

    #
    # Post a message to the channel.
    # @async
    #
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::Attachment] attachment The attachment to send.
    # @param [Array<Discorb::Attachment>] attachments The attachments to send.
    #
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?attachment: Discorb::Attachment?,
                ?attachments: ::Array[Discorb::Attachment]?
              ) -> Async::Task[Discorb::Message]

    #
    # Edit a message.
    # @async
    # @!macro edit
    #
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Attachment>] attachments The new attachments.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    #
    # @return [Async::Task<void>] The task.
    def edit_message: (
                        _ToS message_id,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?allowed_mentions: Discorb::AllowedMentions,
                        ?attachments: ::Array[Discorb::Attachment],
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]),
                        ?supress: bool
                      ) -> Async::Task[void]

    #
    # Delete a message.
    # @async
    #
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    #
    # @return [Async::Task<void>] The task.
    def delete_message!: (_ToS message_id, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a message from ID.
    # @async
    #
    # @param [Discorb::Snowflake] id The ID of the message.
    #
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    #
    # Fetch a message history.
    # @async
    #
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    #
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    #
    # Fetch the pinned messages in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    #
    # Pin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    #
    # @return [Async::Task<void>] The task.
    def pin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Unpin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    #
    # @return [Async::Task<void>] The task.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Trigger the typing indicator in the channel.
    # @async
    #
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped
  end

  #
  # @abstract
  # Represents a Discord component.
  class Component
    def inspect: () -> untyped

    #
    # Create a new component from hash data.
    #
    # @see https://discord.com/developers/docs/interactions/message-components Official Discord API documentation
    # @param [Hash] data Hash data.
    #
    # @return [Component] A new component.
    def self.from_hash: (::Hash[untyped, untyped] data) -> Component

    #
    # Convert components to a hash.
    #
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components Components.
    #
    # @return [Array<Hash>] Hash data.
    def self.to_payload: ((::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]) components) -> ::Array[::Hash[untyped, untyped]]
  end

  #
  # Extended hash class. This is used for storing pair of ID and object.
  class Dictionary[K, V]
    #
    # Initialize a new Dictionary.
    #
    # @param [Hash] hash A hash of items to add to the dictionary.
    # @param [Integer] limit The maximum number of items in the dictionary.
    # @param [false, Proc] sort Whether to sort the items in the dictionary.
    def initialize: (?::Hash[untyped, untyped] hash, ?limit: Integer?, ?sort: (bool | Proc)) -> void

    #
    # Registers a new item in the dictionary.
    #
    # @param [#to_s] id The ID of the item.
    # @param [Object] body The item to register.
    #
    # @return [self] The dictionary.
    def register: (_ToS id, Object body) -> self

    #
    # Merges another dictionary into this one.
    #
    # @param [Discorb::Dictionary] other The dictionary to merge.
    def merge: (Discorb::Dictionary[untyped, untyped] other) -> untyped

    #
    # Removes an item from the dictionary.
    #
    # @param [#to_s] id The ID of the item to remove.
    def remove: (_ToS id) -> untyped

    #
    # Get an item from the dictionary.
    #
    # @param [#to_s] id The ID of the item.
    # @return [Object] The item.
    # @return [nil] if the item was not found.
    #
    # @overload get(index)
    #   @param [Integer] index The index of the item.
    #
    #   @return [Object] The item.
    #   @return [nil] if the item is not found.
    def get: (K id) -> V?

    #
    # Returns the values of the dictionary.
    #
    # @return [Array] The values of the dictionary.
    def values: () -> ::Array[V]

    #
    # Checks if the dictionary has an ID.
    #
    # @param [#to_s] id The ID to check.
    #
    # @return [Boolean] `true` if the dictionary has the ID, `false` otherwise.
    def has?: (_ToS id) -> bool

    #
    # Send a message to the array of values.
    def method_missing: (untyped name) -> untyped

    def respond_to_missing?: (untyped name, untyped args, untyped kwargs) -> bool

    def inspect: () -> untyped

    # @return [Integer] The maximum number of items in the dictionary.
    attr_accessor limit: Integer
  end

  #
  # Represents a permission per guild.
  # ## Flag fields
  #
  # | Field | Value |
  # |-------|-------|
  # |`1 << 0`|`:create_instant_invite`|
  # |`1 << 1`|`:kick_members`|
  # |`1 << 2`|`:ban_members`|
  # |`1 << 3`|`:administrator`|
  # |`1 << 4`|`:manage_channels`|
  # |`1 << 5`|`:manage_guild`|
  # |`1 << 6`|`:add_reactions`|
  # |`1 << 7`|`:view_audit_log`|
  # |`1 << 8`|`:priority_speaker`|
  # |`1 << 9`|`:stream`|
  # |`1 << 10`|`:view_channel`|
  # |`1 << 11`|`:send_messages`|
  # |`1 << 12`|`:send_tts_messages`|
  # |`1 << 13`|`:manage_messages`|
  # |`1 << 14`|`:embed_links`|
  # |`1 << 15`|`:attach_files`|
  # |`1 << 16`|`:read_message_history`|
  # |`1 << 17`|`:mention_everyone`|
  # |`1 << 18`|`:use_external_emojis`|
  # |`1 << 19`|`:view_guild_insights`|
  # |`1 << 20`|`:connect`|
  # |`1 << 21`|`:speak`|
  # |`1 << 22`|`:mute_members`|
  # |`1 << 23`|`:deafen_members`|
  # |`1 << 24`|`:move_members`|
  # |`1 << 25`|`:use_vad`|
  # |`1 << 26`|`:change_nickname`|
  # |`1 << 27`|`:manage_nicknames`|
  # |`1 << 28`|`:manage_roles`|
  # |`1 << 29`|`:manage_webhooks`|
  # |`1 << 30`|`:manage_emojis`|
  # |`1 << 31`|`:use_slash_commands`|
  # |`1 << 32`|`:request_to_speak`|
  # |`1 << 34`|`:manage_threads`|
  # |`1 << 35`|`:use_public_threads`|
  # |`1 << 36`|`:use_private_threads`|
  class Permission < Discorb::Flag
  end

  #
  # Represents a permission per channel.
  class PermissionOverwrite
    #
    # Initializes a new PermissionOverwrite.
    # @private
    #
    # @param allow [Integer] The allowed permissions.
    # @param deny [Integer] The denied permissions.
    def initialize: (Integer allow, Integer deny) -> void

    def allow: () -> untyped

    def deny: () -> untyped

    def allow_value: () -> untyped

    def deny_value: () -> untyped

    def inspect: () -> untyped

    #
    # Converts the permission overwrite to a hash.
    #
    # @return [Hash] The permission overwrite as a hash.
    def to_hash: () -> ::Hash[untyped, untyped]

    #
    # Union of the permission overwrites.
    #
    # @param [Discorb::PermissionOverwrite] other The other permission overwrite.
    #
    # @return [Discorb::PermissionOverwrite] The union of the permission overwrites.
    def +: (Discorb::PermissionOverwrite other) -> Discorb::PermissionOverwrite

    #
    # Returns whether overwrite of the given field.
    #
    # @param [Symbol] field The field to check.
    #
    # @return [true, false, nil] Whether the field is allowed, denied or not set.
    def []: (Symbol field) -> bool?

    #
    # Sets the given field to the given value.
    #
    # @param [Symbol] key The field to set.
    # @param [Boolean] bool The value to set.
    def []=: (Symbol key, bool bool) -> untyped

    #
    # Returns the value of the flag.
    def method_missing: (untyped method, ?untyped bool) -> untyped

    def respond_to_missing?: (untyped method, untyped _arg) -> bool

    #
    # Initializes a permission overwrite from a hash.
    #
    # @param [Hash] hash The hash to initialize the permission overwrite from.
    #
    # @return [Discorb::PermissionOverwrite] The permission overwrite.
    def self.from_hash: (::Hash[untyped, untyped] hash) -> Discorb::PermissionOverwrite
  end

  #
  # Class to handle rate limiting.
  # @private
  class RatelimitHandler
    #
    # Initialize a rate limit handler.
    # @private
    #
    # @param [Discorb::Client] client The client.
    def initialize: (Discorb::Client client) -> void

    def inspect: () -> untyped

    #
    # Wait for the rate limit to reset.
    #
    # @param [Discorb::Route] path The path.
    def wait: (Discorb::Route path) -> untyped

    #
    # Save the rate limit.
    #
    # @param [String] path The path.
    # @param [Net::HTTPResponse] resp The response.
    def save: (String path, Net::HTTPResponse resp) -> untyped
  end

  #
  # Represents a Discord application.
  class Application < Discorb::DiscordModel
    #
    # Initializes a new instance of the Application class.
    # @private
    #
    # @param [Discorb::Client] client The client that instantiated the object.
    # @param [Hash] data The data of the object.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    def inspect: () -> untyped

    # @return [Discorb::Snowflake] The application's ID.
    attr_reader id: Discorb::Snowflake

    # @return [String] The application's name.
    attr_reader name: String

    # @return [Discorb::Asset] The application's icon.
    attr_reader icon: Discorb::Asset

    # @return [String] The application's description.
    attr_reader description: String

    # @return [String] The application's summary.
    attr_reader summary: String

    # @return [String] The application's public key.
    attr_reader verify_key: String

    # @return [Discorb::User] The application's owner.
    attr_reader owner: Discorb::User

    # @return [Discorb::Application::Team] The application's team.
    attr_reader team: Discorb::Application::Team

    # @return [Boolean] Whether the application's bot is public.
    attr_reader bot_public: bool

    # @return [Boolean] Whether the application's bot requires a code grant.
    attr_reader bot_require_code_grant: bool

    # @return [Discorb::Application::Flag] The application's flags.
    attr_reader flags: Discorb::Application::Flag

    #
    # Represents a flag for an application.
    # ## Flag fields
    #
    # | Field|Value|
    # |---|---|
    # | `1 << 12` | `:gateway_presence` |
    # | `1 << 13` | `:gateway_presence_limited` |
    # | `1 << 14` | `:gateway_guild_members` |
    # | `1 << 15` | `:gateway_guild_members_limited` |
    # | `1 << 16` | `:verification_pending_guild_limit` |
    # | `1 << 17` | `:embedded` |
    # | `1 << 18` | `:gateway_message_content` |
    # | `1 << 19` | `:gateway_message_content_limited` |
    class Flag < Discorb::Flag
    end

    #
    # Represents a team for an application.
    class Team < Discorb::DiscordModel
      #
      # Initializes a new instance of the Team class.
      # @private
      #
      # @param [Discorb::Client] client The client that instantiated the object.
      # @param [Hash] data The data of the object.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      #
      # The team's owner.
      #
      # @return [Discorb::Application::Team::Member] The team's owner.
      def owner: () -> Discorb::Application::Team::Member

      def inspect: () -> untyped

      # @return [Discorb::Snowflake] The team's ID.
      attr_reader id: Discorb::Snowflake

      # @return [Discorb::Asset] The team's icon.
      attr_reader icon: Discorb::Asset

      # @return [String] The team's name.
      attr_reader name: String

      # @return [Discorb::Snowflake] The team's owner's ID.
      attr_reader owner_user_id: Discorb::Snowflake

      # @return [Discorb::Application::Team::Member] The team's member.
      attr_reader members: Discorb::Application::Team::Member

      #
      # Represents a member of team.
      class Member < Discorb::DiscordModel
        MEMBERSHIP_STATE: untyped

        def initialize: (untyped client, untyped team, untyped data) -> void

        def inspect: () -> untyped

        def ==: (untyped other) -> untyped

        # @return [Discorb::User] The user.
        attr_reader user: Discorb::User

        # @return [Snowflake] The ID of member's team.
        attr_reader team_id: Snowflake

        # @return [:invited, :accepted] The member's membership state.
        attr_reader membership_state: Symbol

        # @return [Array<Symbol>] The permissions of the member.
        # @note This always return `:*`.
        attr_reader permissions: ::Array[Symbol]

        # @return [Boolean] Whether the member is not joined to the team.
        attr_reader pending?: bool

        # @return [Boolean] Whether the member accepted joining the team.
        attr_reader accepted?: bool

        # @return [Boolean] Whether the member is the team's owner.
        attr_reader owner?: bool
      end
    end
  end

  #
  # A table of emoji names and their unicode values.
  module EmojiTable
    DISCORD_TO_UNICODE: untyped
    UNICODE_TO_DISCORD: untyped
    SKIN_TONES: untyped
  end

  #
  # Represents a integration.
  class Integration < Discorb::DiscordModel
    EXPIRE_BEHAVIOR: untyped

    #
    # Initialize a new integration.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the welcome screen.
    # @param [Discorb::Guild] guild The guild this integration is in.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data, _ToS guild_id) -> void

    #
    # Delete the integration.
    # @async
    #
    # @param [String] reason The reason for deleting the integration.
    #
    # @return [Async::Task<void>] The task.
    def delete!: (?reason: String?) -> Async::Task[void]

    # @return [Discorb::Snowflake] The ID of the integration.
    attr_reader id: Discorb::Snowflake

    # @return [Symbol] The type of integration.
    attr_reader type: Symbol

    # @return [Boolean] Whether the integration is enabled.
    attr_reader enabled: bool

    # @return [Boolean] Whether the integration is syncing.
    attr_reader syncing: bool

    # @return [Boolean] Whether the integration is enabled emoticons.
    attr_reader enable_emoticons: bool

    # @return [:remove_role, :kick] The behavior of the integration when it expires.
    attr_reader expire_behavior: Symbol

    # @return [Integer] The grace period of the integration.
    attr_reader expire_grace_period: Integer

    # @return [Discorb::User] The user for the integration.
    attr_reader user: Discorb::User

    # @return [Discorb::Integration::Account] The account for the integration.
    attr_reader account: Discorb::Integration::Account

    # @return [Integer] The number of subscribers for the integration.
    attr_reader subscriber_count: Integer

    # @return [Boolean] Whether the integration is revoked.
    attr_reader revoked: bool

    # @return [Discorb::Application] The application for the integration.
    attr_reader application: Discorb::Application

    # @macro client_cache
    # @return [Discorb::Guild] The guild this integration is in.
    attr_reader guild: Discorb::Guild?

    #
    # Represents an account for an integration.
    class Account < Discorb::DiscordModel
      #
      # Initialize a new account.
      # @private
      #
      # @param [Hash] data The data from Discord.
      def initialize: (::Hash[untyped, untyped] data) -> void

      # @return [String] The ID of the account.
      attr_reader id: String

      # @return [String] The name of the account.
      attr_reader name: String
    end

    #
    # Represents an application for an integration.
    class Application < Discorb::DiscordModel
      #
      # Initialize a new application.
      # @private
      #
      # @param [Discorb::Client] client The client.
      # @param [Hash] data The data from Discord.
      def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

      # @return [Discorb::Snowflake] The ID of the application.
      attr_reader id: Discorb::Snowflake

      # @return [String] The name of the application.
      attr_reader name: String

      # @return [Asset] The icon of the application.
      # @return [nil] If the application has no icon.
      attr_reader icon: Asset?

      # @return [String] The description of the application.
      attr_reader description: String

      # @return [String] The summary of the application.
      attr_reader summary: String

      # @return [Discorb::User] The bot user associated with the application.
      # @return [nil] If the application has no bot user.
      attr_reader bot: Discorb::User?
    end
  end

  #
  # Represents a state of user in voice channel.
  class VoiceState < Discorb::DiscordModel
    #
    # Initialize a new voice state.
    # @private
    #
    # @param [Discorb::Client] client The client this voice state belongs to.
    # @param [Hash] data The data of the voice state.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    # @return [Discorb::Member] The member associated with this voice state.
    attr_reader member: Discorb::Member

    # @return [Discorb::Snowflake] The ID of the guild this voice state is for.
    attr_reader session_id: Discorb::Snowflake

    # @return [Time] The time at which the user requested to speak.
    attr_reader request_to_speak_timestamp: Time

    # @return [Boolean] Whether the user is deafened.
    attr_reader self_deaf: bool

    # @return [Boolean] Whether the user is muted.
    attr_reader self_mute: bool

    # @return [Boolean] Whether the user is streaming.
    attr_reader self_stream: bool

    # @return [Boolean] Whether the user is video-enabled.
    attr_reader self_video: bool

    # @return [Boolean] Whether the user is suppressed. (Is at audience)
    attr_reader suppress: bool

    # @return [Boolean] Whether the user is deafened.
    attr_reader deaf?: bool

    # @return [Boolean] Whether the user is muted.
    attr_reader mute?: bool

    # @return [Boolean] Whether the user is deafened on the server.
    attr_reader server_deaf?: bool

    # @return [Boolean] Whether the user is muted on the server.
    attr_reader server_mute?: bool

    # @macro client_cache
    # @return [Discorb::Guild] The guild this voice state is for.
    attr_reader guild: Discorb::Guild?

    # @macro client_cache
    # @return [Discorb::Channel] The channel this voice state is for.
    attr_reader channel: Discorb::Channel?

    # @macro client_cache
    # @return [Discorb::User] The user this voice state is for.
    attr_reader user: Discorb::User?
  end

  #
  # Represents a stage instance of a voice state.
  class StageInstance < Discorb::DiscordModel
    #
    # Initialize a new instance of the StageInstance class.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the stage instance.
    # @param [Boolean] no_cache Whether to disable caching.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data, ?no_cache: bool) -> void

    def guild: () -> untyped

    def channel: () -> untyped

    def discoverable?: () -> bool

    def public?: () -> bool

    def guild_only?: () -> bool

    def inspect: () -> untyped

    #
    # Edits the stage instance.
    # @async
    # @macro edit
    #
    # @param [String] topic The new topic of the stage instance.
    # @param [:public, :guild_only] privacy_level The new privacy level of the stage instance.
    # @param [String] reason The reason for editing the stage instance.
    #
    # @return [Async::Task<void>] The task.
    def edit: (?topic: String, ?privacy_level: Symbol, ?reason: String?) -> Async::Task[void]

    #
    # Deletes the stage instance.
    #
    # @param [String] reason The reason for deleting the stage instance.
    #
    # @return [Async::Task<void>] The task.
    def delete!: (?reason: String?) -> Async::Task[void]

    # @return [Discorb::Snowflake] The ID of the guild this voice state is for.
    attr_reader id: Discorb::Snowflake

    # @return [String] The topic of the stage instance.
    attr_reader topic: String

    # @return [:public, :guild_only] The privacy level of the stage instance.
    attr_reader privacy_level: Symbol
  end

  #
  # Represents a voice region.
  class VoiceRegion < Discorb::DiscordModel
    #
    # Initialize a new instance of the VoiceRegion class.
    # @private
    #
    # @param [Hash] data The data of the voice region.
    def initialize: (::Hash[untyped, untyped] data) -> void

    # @return [Discorb::Snowflake] The ID of the voice region.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the voice region.
    attr_reader name: String

    # @return [Boolean] Whether the voice region is VIP.
    attr_reader vip: bool

    # @return [Boolean] Whether the voice region is optimal.
    attr_reader optimal: bool

    # @return [Boolean] Whether the voice region is deprecated.
    attr_reader deprecated: bool

    # @return [Boolean] Whether the voice region is custom.
    attr_reader custom: bool
  end

  #
  # Represents a channel of Discord.
  # @abstract
  class Channel < Discorb::DiscordModel
    #
    # Initializes a new instance of the Channel class.
    # @private
    def initialize: (untyped client, untyped data, ?no_cache: untyped) -> void

    #
    # Checks if the channel is other channel.
    #
    # @param [Discorb::Channel] other The channel to check.
    #
    # @return [Boolean] True if the channel is other channel.
    def ==: (Discorb::Channel other) -> bool

    def inspect: () -> untyped

    #
    # Returns the descendants of the Channel class.
    # @private
    def self.descendants: () -> untyped

    #
    # Creates a new instance of the Channel class or instance of its descendants.
    # @private
    #
    # @param [Discorb::Client] client The client that instantiated the object.
    # @param [Hash] data The data of the object.
    # @param [Boolean] no_cache Whether to disable cache the object.
    def self.make_channel: (Discorb::Client client, ::Hash[untyped, untyped] data, ?no_cache: bool) -> untyped

    def type: () -> untyped

    #
    # Returns the channel id to request.
    # @private
    #
    # @return [Async::Task<Discorb::Snowflake>] A task that resolves to the channel id.
    def channel_id: () -> Async::Task[Discorb::Snowflake]

    # @return [Discorb::Snowflake] The ID of the channel.
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the channel.
    attr_reader name: String
  end

  #
  # Represents a text channel.
  class TextChannel < Discorb::GuildChannel
    include Discorb::Messageable
    DEFAULT_AUTO_ARCHIVE_DURATION: untyped

    #
    # Edits the channel.
    # @async
    # @macro edit
    #
    # @param [String] name The name of the channel.
    # @param [Integer] position The position of the channel.
    # @param [Discorb::CategoryChannel, nil] category The parent of channel. Specify `nil` to remove the parent.
    # @param [Discorb::CategoryChannel, nil] parent Alias of `category`.
    # @param [String] topic The topic of the channel.
    # @param [Boolean] nsfw Whether the channel is nsfw.
    # @param [Boolean] announce Whether the channel is announce channel.
    # @param [Integer] rate_limit_per_user The rate limit per user (Slowmode) in the channel.
    # @param [Integer] slowmode Alias of `rate_limit_per_user`.
    # @param [Integer] default_auto_archive_duration The default auto archive duration of the channel.
    # @param [Integer] archive_in Alias of `default_auto_archive_duration`.
    # @param [String] reason The reason of editing the channel.
    #
    # @return [Async::Task<self>] The edited channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?category: Discorb::CategoryChannel?,
                ?parent: Discorb::CategoryChannel?,
                ?topic: String,
                ?nsfw: bool,
                ?announce: bool,
                ?rate_limit_per_user: Integer,
                ?slowmode: Integer,
                ?default_auto_archive_duration: Integer,
                ?archive_in: Integer,
                ?reason: String?
              ) -> Async::Task[self]

    #
    # Create webhook in the channel.
    # @async
    #
    # @param [String] name The name of the webhook.
    # @param [Discorb::Image] avatar The avatar of the webhook.
    #
    # @return [Async::Task<Discorb::Webhook::IncomingWebhook>] The created webhook.
    def create_webhook: (String name, ?avatar: Discorb::Image?) -> Async::Task[Discorb::Webhook::IncomingWebhook]

    #
    # Fetch webhooks in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Webhook>>] The webhooks in the channel.
    def fetch_webhooks: () -> Async::Task[::Array[Discorb::Webhook]]

    #
    # Bulk delete messages in the channel.
    # @async
    #
    # @param [Discorb::Message] messages The messages to delete.
    # @param [Boolean] force Whether to ignore the validation for message (14 days limit).
    #
    # @return [Async::Task<void>] The task.
    def delete_messages!: (*Discorb::Message messages, ?force: bool) -> Async::Task[void]

    #
    # Follow the existing announcement channel.
    # @async
    #
    # @param [Discorb::NewsChannel] target The channel to follow.
    # @param [String] reason The reason of following the channel.
    #
    # @return [Async::Task<void>] The task.
    def follow_from: (Discorb::NewsChannel target, ?reason: String?) -> Async::Task[void]

    #
    # Start thread in the channel.
    # @async
    #
    # @param [String] name The name of the thread.
    # @param [Discorb::Message] message The message to start the thread.
    # @param [:hour, :day, :three_days, :week] auto_archive_duration The duration of auto-archiving.
    # @param [Boolean] public Whether the thread is public.
    # @param [Integer] rate_limit_per_user The rate limit per user.
    # @param [Integer] slowmode Alias of `rate_limit_per_user`.
    # @param [String] reason The reason of starting the thread.
    #
    # @return [Async::Task<Discorb::ThreadChannel>] The started thread.
    def start_thread: (
                        String name,
                        ?message: Discorb::Message?,
                        ?auto_archive_duration: Symbol?,
                        ?public: bool,
                        ?rate_limit_per_user: Integer?,
                        ?slowmode: Integer?,
                        ?reason: String?
                      ) -> Async::Task[Discorb::ThreadChannel]

    #
    # Fetch archived threads in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The archived threads in the channel.
    def fetch_archived_public_threads: () -> Async::Task[::Array[Discorb::ThreadChannel]]

    #
    # Fetch archived private threads in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The archived private threads in the channel.
    def fetch_archived_private_threads: () -> Async::Task[::Array[Discorb::ThreadChannel]]

    #
    # Fetch joined archived private threads in the channel.
    # @async
    #
    # @param [Integer] limit The limit of threads to fetch.
    # @param [Time] before <description>
    #
    # @return [Async::Task<Array<Discorb::ThreadChannel>>] The joined archived private threads in the channel.
    def fetch_joined_archived_private_threads: (?limit: Integer?, ?before: Time?) -> Async::Task[::Array[Discorb::ThreadChannel]]

    #
    # Post a message to the channel.
    # @async
    #
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::Attachment] attachment The attachment to send.
    # @param [Array<Discorb::Attachment>] attachments The attachments to send.
    #
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?attachment: Discorb::Attachment?,
                ?attachments: ::Array[Discorb::Attachment]?
              ) -> Async::Task[Discorb::Message]

    #
    # Edit a message.
    # @async
    # @!macro edit
    #
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Attachment>] attachments The new attachments.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    #
    # @return [Async::Task<void>] The task.
    def edit_message: (
                        _ToS message_id,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?allowed_mentions: Discorb::AllowedMentions,
                        ?attachments: ::Array[Discorb::Attachment],
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]),
                        ?supress: bool
                      ) -> Async::Task[void]

    #
    # Delete a message.
    # @async
    #
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    #
    # @return [Async::Task<void>] The task.
    def delete_message!: (_ToS message_id, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a message from ID.
    # @async
    #
    # @param [Discorb::Snowflake] id The ID of the message.
    #
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    #
    # Fetch a message history.
    # @async
    #
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    #
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    #
    # Fetch the pinned messages in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    #
    # Pin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    #
    # @return [Async::Task<void>] The task.
    def pin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Unpin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    #
    # @return [Async::Task<void>] The task.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Trigger the typing indicator in the channel.
    # @async
    #
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [String] The topic of the channel.
    attr_reader topic: String

    # @return [Boolean] Whether the channel is nsfw.
    attr_reader nsfw: bool

    # @return [Discorb::Snowflake] The id of the last message.
    attr_reader last_message_id: Discorb::Snowflake

    # @return [Integer] The rate limit per user (Slowmode) in the channel.
    attr_reader rate_limit_per_user: Integer

    # @return [Time] The time when the last pinned message was pinned.
    attr_reader last_pin_timestamp: Time

    # @return [Integer] The default value of duration of auto archive.
    attr_reader default_auto_archive_duration: Integer

    # @!attribute [r] threads
    #   @return [Array<Discorb::ThreadChannel>] The threads in the channel.
    attr_reader threads: untyped
  end

  #
  # Represents a news channel (announcement channel).
  class NewsChannel < Discorb::TextChannel
    DEFAULT_AUTO_ARCHIVE_DURATION: untyped

    #
    # Follow the existing announcement channel from self.
    # @async
    #
    # @param [Discorb::TextChannel] target The channel to follow to.
    # @param [String] reason The reason of following the channel.
    #
    # @return [Async::Task<void>] The task.
    def follow_to: (Discorb::TextChannel target, ?reason: String?) -> Async::Task[void]
  end

  #
  # Represents a channel in guild.
  # @abstract
  class GuildChannel < Discorb::Channel
    include Comparable

    #
    # Compares position of two channels.
    #
    # @param [Discorb::GuildChannel] other The channel to compare.
    #
    # @return [-1, 0, 1] -1 if the channel is at lower than the other, 1 if the channel is at highter than the other.
    def <=>: (Discorb::GuildChannel other) -> Integer

    #
    # Checks if the channel is same as another.
    #
    # @param [Discorb::GuildChannel] other The channel to check.
    #
    # @return [Boolean] `true` if the channel is same as another.
    def ==: (Discorb::GuildChannel other) -> bool

    #
    # Stringifies the channel.
    #
    # @return [String] The name of the channel with `#`.
    def to_s: () -> String

    def mention: () -> untyped

    def parent: () -> untyped

    def guild: () -> untyped

    def inspect: () -> untyped

    #
    # Deletes the channel.
    # @async
    #
    # @param [String] reason The reason of deleting the channel.
    #
    # @return [Async::Task<self>] The deleted channel.
    def delete!: (?reason: String?) -> Async::Task[self]

    #
    # Moves the channel to another position.
    # @async
    #
    # @param [Integer] position The position to move the channel.
    # @param [Boolean] lock_permissions Whether to lock the permissions of the channel.
    # @param [Discorb::CategoryChannel] parent The parent of channel.
    # @param [String] reason The reason of moving the channel.
    #
    # @return [Async::Task<self>] The moved channel.
    def move: (
                Integer position,
                ?lock_permissions: bool,
                ?parent: Discorb::CategoryChannel,
                ?reason: String?
              ) -> Async::Task[self]

    #
    # Set the channel's permission overwrite.
    # @async
    #
    # @param [Discorb::Role, Discorb::Member] target The target of the overwrite.
    # @param [String] reason The reason of setting the overwrite.
    # @param [{Symbol => Boolean}] perms The permission overwrites to replace.
    #
    # @return [Async::Task<void>] The task.
    def set_permissions: ((Discorb::Role | Discorb::Member) target, ?reason: String?, **::Hash[Symbol, bool] perms) -> Async::Task[void]

    #
    # Delete the channel's permission overwrite.
    # @async
    #
    # @param [Discorb::Role, Discorb::Member] target The target of the overwrite.
    # @param [String] reason The reason of deleting the overwrite.
    #
    # @return [Async::Task<void>] The task.
    def delete_permissions: ((Discorb::Role | Discorb::Member) target, ?reason: String?) -> Async::Task[void]

    #
    # Fetch the channel's invites.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Invite>>] The invites in the channel.
    def fetch_invites: () -> Async::Task[::Array[Discorb::Invite]]

    #
    # Create an invite in the channel.
    # @async
    #
    # @param [Integer] max_age The max age of the invite.
    # @param [Integer] max_uses The max uses of the invite.
    # @param [Boolean] temporary Whether the invite is temporary.
    # @param [Boolean] unique Whether the invite is unique.
    #   @note if it's `false` it may return existing invite.
    # @param [String] reason The reason of creating the invite.
    #
    # @return [Async::Task<Invite>] The created invite.
    def create_invite: (
                         ?max_age: Integer?,
                         ?max_uses: Integer?,
                         ?temporary: bool,
                         ?unique: bool,
                         ?reason: String?
                       ) -> Async::Task[Invite]

    # @return [Integer] The position of the channel as integer.
    attr_reader position: Integer

    # @return [Hash{Discorb::Role, Discorb::Member => PermissionOverwrite}] The permission overwrites of the channel.
    attr_reader permission_overwrites: Hash[Discorb::Role | Discorb::Member, Discorb::PermissionOverwrite]
  end

  #
  # Represents a stage channel.
  class StageChannel < Discorb::GuildChannel
    include Discorb::Connectable

    #
    # Initialize a new stage channel.
    # @private
    def initialize: () -> void

    def stage_instance: () -> untyped

    #
    # Edit the stage channel.
    # @async
    # @macro edit
    #
    # @param [String] name The name of the stage channel.
    # @param [Integer] position The position of the stage channel.
    # @param [Integer] bitrate The bitrate of the stage channel.
    # @param [Symbol] rtc_region The region of the stage channel.
    # @param [String] reason The reason of editing the stage channel.
    #
    # @return [Async::Task<self>] The edited stage channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?bitrate: Integer,
                ?rtc_region: Symbol,
                ?reason: String?
              ) -> Async::Task[self]

    #
    # Start a stage instance.
    # @async
    #
    # @param [String] topic The topic of the stage instance.
    # @param [Boolean] public Whether the stage instance is public or not.
    # @param [String] reason The reason of starting the stage instance.
    #
    # @return [Async::Task<Discorb::StageInstance>] The started stage instance.
    def start: (String topic, ?public: bool, ?reason: String?) -> Async::Task[Discorb::StageInstance]

    #
    # Fetch a current stage instance.
    # @async
    #
    # @return [Async::Task<StageInstance>] The current stage instance.
    # @return [Async::Task<nil>] If there is no current stage instance.
    def fetch_stage_instance: () -> Async::Task[StageInstance]

    def voice_states: () -> untyped

    def members: () -> untyped

    def speakers: () -> untyped

    def audiences: () -> untyped

    def connect: () -> untyped

    # @return [Integer] The bitrate of the voice channel.
    attr_reader bitrate: Integer

    # @return [Integer] The user limit of the voice channel.
    attr_reader user_limit: Integer

    #
    # @private
    # @return [Discorb::Dictionary{Discorb::Snowflake => StageInstance}]
    #   The stage instances associated with the stage channel.
    attr_reader stage_instances: Discorb::Dictionary[Discorb::Snowflake, StageInstance]
  end

  #
  # Represents a voice channel.
  class VoiceChannel < Discorb::GuildChannel
    include Discorb::Connectable
    include Discorb::Messageable

    #
    # Edit the voice channel.
    # @async
    # @macro edit
    #
    # @param [String] name The name of the voice channel.
    # @param [Integer] position The position of the voice channel.
    # @param [Integer] bitrate The bitrate of the voice channel.
    # @param [Integer] user_limit The user limit of the voice channel.
    # @param [Symbol] rtc_region The region of the voice channel.
    # @param [String] reason The reason of editing the voice channel.
    #
    # @return [Async::Task<self>] The edited voice channel.
    def edit: (
                ?name: String,
                ?position: Integer,
                ?bitrate: Integer,
                ?user_limit: Integer,
                ?rtc_region: Symbol,
                ?reason: String?
              ) -> Async::Task[self]

    def voice_states: () -> untyped

    def members: () -> untyped

    #
    # Post a message to the channel.
    # @async
    #
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::Attachment] attachment The attachment to send.
    # @param [Array<Discorb::Attachment>] attachments The attachments to send.
    #
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?attachment: Discorb::Attachment?,
                ?attachments: ::Array[Discorb::Attachment]?
              ) -> Async::Task[Discorb::Message]

    #
    # Edit a message.
    # @async
    # @!macro edit
    #
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Attachment>] attachments The new attachments.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    #
    # @return [Async::Task<void>] The task.
    def edit_message: (
                        _ToS message_id,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?allowed_mentions: Discorb::AllowedMentions,
                        ?attachments: ::Array[Discorb::Attachment],
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]),
                        ?supress: bool
                      ) -> Async::Task[void]

    #
    # Delete a message.
    # @async
    #
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    #
    # @return [Async::Task<void>] The task.
    def delete_message!: (_ToS message_id, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a message from ID.
    # @async
    #
    # @param [Discorb::Snowflake] id The ID of the message.
    #
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    #
    # Fetch a message history.
    # @async
    #
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    #
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    #
    # Fetch the pinned messages in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    #
    # Pin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    #
    # @return [Async::Task<void>] The task.
    def pin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Unpin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    #
    # @return [Async::Task<void>] The task.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Trigger the typing indicator in the channel.
    # @async
    #
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    def connect: () -> untyped

    # @return [Integer] The bitrate of the voice channel.
    attr_reader bitrate: Integer

    # @return [Integer] The user limit of the voice channel.
    # @return [nil] If the user limit is not set.
    attr_reader user_limit: Integer?
  end

  #
  # Represents a event handler.
  # This class shouldn't be instantiated directly.
  # Use {Client#on} instead.
  class EventHandler
    def initialize: (untyped block, _ToS id, untyped metadata) -> void

    def inspect: () -> untyped

    #
    # Calls the block associated with the event.
    def call: () -> untyped

    # @return [Proc] the block to be called.
    attr_reader block: Proc

    # @return [Symbol] the event id.
    attr_reader id: Symbol

    # @return [Hash] the event metadata.
    attr_reader metadata: ::Hash[untyped, untyped]

    # @return [Boolean] whether the event is once or not.
    attr_reader once: bool
  end

  #
  # Represents a thread.
  # @abstract
  class ThreadChannel < Discorb::Channel
    include Discorb::Messageable

    #
    # Initialize a new thread channel.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data of the thread channel.
    # @param [Boolean] no_cache Whether to disable the cache.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data, ?no_cache: bool) -> void

    #
    # Edit the thread.
    # @async
    # @macro edit
    #
    # @param [String] name The name of the thread.
    # @param [Boolean] archived Whether the thread is archived or not.
    # @param [Integer] auto_archive_duration The auto archive duration in seconds.
    # @param [Integer] archive_in Alias of `auto_archive_duration`.
    # @param [Boolean] locked Whether the thread is locked or not.
    # @param [String] reason The reason of editing the thread.
    #
    # @return [Async::Task<self>] The edited thread.
    #
    # @see #archive
    # @see #lock
    # @see #unarchive
    # @see #unlock
    def edit: (
                ?name: String,
                ?archived: bool,
                ?auto_archive_duration: Integer,
                ?archive_in: Integer,
                ?locked: bool,
                ?reason: String?
              ) -> Async::Task[self]

    #
    # Helper method to archive the thread.
    #
    # @param [String] reason The reason of archiving the thread.
    #
    # @return [self] The archived thread.
    def archive: (?reason: String?) -> self

    #
    # Helper method to lock the thread.
    #
    # @param [String] reason The reason of locking the thread.
    #
    # @return [self] The locked thread.
    def lock: (?reason: String?) -> self

    #
    # Helper method to unarchive the thread.
    #
    # @param [String] reason The reason of unarchiving the thread.
    #
    # @return [self] The unarchived thread.
    def unarchive: (?reason: String?) -> self

    #
    # Helper method to unlock the thread.
    #
    # @param [String] reason The reason of unlocking the thread.
    #
    # @return [self] The unlocked thread.
    #
    # @note This method won't unarchive the thread. Use {#unarchive} instead.
    def unlock: (?reason: String?) -> self

    def parent: () -> untyped

    def me: () -> untyped

    def joined?: () -> bool

    def guild: () -> untyped

    def owner: () -> untyped

    def inspect: () -> untyped

    #
    # Add a member to the thread.
    #
    # @param [Discorb::Member, :me] member The member to add. If `:me` is given, the bot will be added.
    #
    # @return [Async::Task<void>] The task.
    def add_member: (?(Discorb::Member | Symbol) member) -> Async::Task[void]

    #
    # Remove a member from the thread.
    #
    # @param [Discorb::Member, :me] member The member to remove. If `:me` is given, the bot will be removed.
    #
    # @return [Async::Task<void>] The task.
    def remove_member: (?(Discorb::Member | Symbol) member) -> Async::Task[void]

    #
    # Fetch members in the thread.
    #
    # @return [Array<Discorb::ThreadChannel::Member>] The members in the thread.
    def fetch_members: () -> ::Array[Discorb::ThreadChannel::Member]

    #
    # Post a message to the channel.
    # @async
    #
    # @param [String] content The message content.
    # @param [Boolean] tts Whether the message is tts.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Discorb::Message, Discorb::Message::Reference] reference The message to reply to.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Discorb::Attachment] attachment The attachment to send.
    # @param [Array<Discorb::Attachment>] attachments The attachments to send.
    #
    # @return [Async::Task<Discorb::Message>] The message sent.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?reference: (Discorb::Message | Discorb::Message::Reference)?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?attachment: Discorb::Attachment?,
                ?attachments: ::Array[Discorb::Attachment]?
              ) -> Async::Task[Discorb::Message]

    #
    # Edit a message.
    # @async
    # @!macro edit
    #
    # @param [#to_s] message_id The message id.
    # @param [String] content The message content.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send.
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions.
    # @param [Array<Discorb::Attachment>] attachments The new attachments.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] supress Whether to supress embeds.
    #
    # @return [Async::Task<void>] The task.
    def edit_message: (
                        _ToS message_id,
                        ?String content,
                        ?embed: Discorb::Embed,
                        ?embeds: ::Array[Discorb::Embed],
                        ?allowed_mentions: Discorb::AllowedMentions,
                        ?attachments: ::Array[Discorb::Attachment],
                        ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]]),
                        ?supress: bool
                      ) -> Async::Task[void]

    #
    # Delete a message.
    # @async
    #
    # @param [#to_s] message_id The message id.
    # @param [String] reason The reason for deleting the message.
    #
    # @return [Async::Task<void>] The task.
    def delete_message!: (_ToS message_id, ?reason: String?) -> Async::Task[void]

    #
    # Fetch a message from ID.
    # @async
    #
    # @param [Discorb::Snowflake] id The ID of the message.
    #
    # @return [Async::Task<Discorb::Message>] The message.
    # @raise [Discorb::NotFoundError] If the message is not found.
    def fetch_message: (Discorb::Snowflake id) -> Async::Task[Discorb::Message]

    #
    # Fetch a message history.
    # @async
    #
    # @param [Integer] limit The number of messages to fetch.
    # @param [Discorb::Snowflake] before The ID of the message to fetch before.
    # @param [Discorb::Snowflake] after The ID of the message to fetch after.
    # @param [Discorb::Snowflake] around The ID of the message to fetch around.
    #
    # @return [Async::Task<Array<Discorb::Message>>] The messages.
    def fetch_messages: (
                          ?Integer limit,
                          ?before: Discorb::Snowflake?,
                          ?after: Discorb::Snowflake?,
                          ?around: Discorb::Snowflake?
                        ) -> Async::Task[::Array[Discorb::Message]]

    #
    # Fetch the pinned messages in the channel.
    # @async
    #
    # @return [Async::Task<Array<Discorb::Message>>] The pinned messages in the channel.
    def fetch_pins: () -> Async::Task[::Array[Discorb::Message]]

    #
    # Pin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to pin.
    # @param [String] reason The reason of pinning the message.
    #
    # @return [Async::Task<void>] The task.
    def pin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Unpin a message in the channel.
    # @async
    #
    # @param [Discorb::Message] message The message to unpin.
    # @param [String] reason The reason of unpinning the message.
    #
    # @return [Async::Task<void>] The task.
    def unpin_message: (Discorb::Message message, ?reason: String?) -> Async::Task[void]

    #
    # Trigger the typing indicator in the channel.
    # @async
    #
    # If block is given, trigger typing indicator during executing block.
    # @example
    #   channel.typing do
    #     channel.post("Waiting for 60 seconds...")
    #     sleep 60
    #     channel.post("Done!")
    #   end
    def typing: () -> untyped

    # @return [Discorb::Snowflake] The ID of the channel.
    # @note This ID is same as the starter message's ID
    attr_reader id: Discorb::Snowflake

    # @return [String] The name of the thread.
    attr_reader name: String

    # @return [Integer] The number of messages in the thread.
    # @note This will stop counting at 50.
    attr_reader message_count: Integer

    # @return [Integer] The number of recipients in the thread.
    # @note This will stop counting at 50.
    attr_reader member_count: Integer

    # @return [Integer] The rate limit per user (slowmode) in the thread.
    attr_reader rate_limit_per_user: Integer

    # @return [Array<Discorb::ThreadChannel::Member>] The members of the thread.
    attr_reader members: ::Array[Discorb::ThreadChannel::Member]

    # @return [Time] The time the thread was archived.
    # @return [nil] If the thread is not archived.
    attr_reader archived_timestamp: Time?

    # @return [Integer] Auto archive duration in seconds.
    attr_reader auto_archive_duration: Integer

    # @return [Boolean] Whether the thread is archived or not.
    attr_reader archived: bool

    #
    # Represents a thread in news channel(aka announcement channel).
    class News < Discorb::ThreadChannel
    end

    #
    # Represents a public thread in text channel.
    class Public < Discorb::ThreadChannel
    end

    #
    # Represents a private thread in text channel.
    class Private < Discorb::ThreadChannel
    end

    #
    # Represents a member in a thread.
    class Member < Discorb::DiscordModel
      def initialize: (untyped cilent, untyped data) -> void

      def thread: () -> untyped

      def member: () -> untyped

      def id: () -> untyped

      def user: () -> untyped

      def inspect: () -> untyped

      # Returns the value of attribute joined_at.
      attr_reader joined_at: untyped
    end
  end

  #
  # Represents a guild template.
  class GuildTemplate < Discorb::DiscordModel
    #
    # Initialize a new template.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data from Discord.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    #
    # Edit the template.
    # @async
    # @macro edit
    #
    # @param [String] name The new name of the template.
    # @param [String] description The new description of the template.
    #
    # @return [Async::Task<void>] The task.
    def edit: (?String? name, ?String description) -> Async::Task[void]

    #
    # Update the template.
    # @async
    #
    # @return [Async::Task<void>] The task.
    def update: () -> Async::Task[void]

    #
    # Delete the template.
    # @async
    #
    # @return [Async::Task<void>] The task.
    def delete!: () -> Async::Task[void]

    # @return [String] The code of the template.
    attr_reader code: String

    # @return [String] The name of the template.
    attr_reader name: String

    # @return [String] The description of the template.
    attr_reader description: String

    # @return [Integer] The number of times this template has been used.
    attr_reader usage_count: Integer

    # @return [Discorb::User] The user who created this template.
    attr_reader creator: Discorb::User

    # @return [Time] The time this template was created.
    attr_reader created_at: Time

    # @return [Time] The time this template was last updated.
    attr_reader updated_at: Time

    # @return [Discorb::Guild] The guild where the template was created.
    attr_reader source_guild_id: Discorb::Guild

    # @return [Discorb::GuildTemplate::TemplateGuild] The guild where the template was created.
    attr_reader serialized_source_guild: Discorb::GuildTemplate::TemplateGuild

    # @return [Boolean] Whether this template is dirty.
    attr_reader is_dirty: bool

    # @macro client_cache
    # @return [Discorb::Guild] The guild this template is based on.
    # @return [nil] Client wasn't able to find the guild this template is based on.
    attr_reader source_guild: Discorb::Guild?

    #
    # Represents a guild in guild template.
    class TemplateGuild < Discorb::DiscordModel
      #
      # Initialize a new guild in guild template.
      # @private
      #
      # @param [Hash] data The data from Discord.
      def initialize: (::Hash[untyped, untyped] data) -> void

      # @return [String] The name of the guild.
      attr_reader name: String

      # @return [Integer] The AFK timeout of the guild.
      attr_reader afk_timeout: Integer

      # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::Role}] A dictionary of roles in the guild.
      attr_reader roles: Discorb::Dictionary[Discorb::Snowflake, Discorb::Role]

      # @return [Discorb::SystemChannelFlag] The flag for the system channel.
      attr_reader system_channel_flags: Discorb::SystemChannelFlag

      # @return [Discorb::Dictionary{Discorb::Snowflake => Discorb::GuildChannel}]
      #   A dictionary of channels in the guild.
      attr_reader channels: Discorb::Dictionary[Discorb::Snowflake, Discorb::GuildChannel]

      # @return [String] The description of the guild.
      attr_reader description: String

      # @return [Symbol] The preffered language of the guild.
      # @note This modifies the language code, `-` will be replaced with `_`.
      attr_reader preferred_locale: Symbol

      # @return [:none, :low, :medium, :high, :very_high] The verification level of the guild.
      attr_reader verification_level: Symbol

      # @return [:all_messages, :only_mentions] The default message notification level of the guild.
      attr_reader default_message_notifications: Symbol

      # @return [:disabled_in_text, :members_without_roles, :all_members] The explict content filter level of the guild.
      attr_reader explicit_content_filter: Symbol

      # @return [Boolean] Whether the guild enabled the widget.
      attr_reader widget_enabled: bool

      #
      # Represents a role in guild template.
      class Role < Discorb::DiscordModel
        #
        # Initialize a new role in guild template.
        # @private
        #
        # @param [Hash] data The data from Discord.
        def initialize: (::Hash[untyped, untyped] data) -> void

        # @return [String] The name of the role.
        attr_reader name: String

        # @return [Discorb::Permission] The permissions of the role.
        attr_reader permissions: Discorb::Permission

        # @return [Discorb::Color] The color of the role.
        attr_reader color: Discorb::Color
      end

      #
      # Represents a channel in guild template.
      class Channel < Discorb::DiscordModel
        #
        # Initialize a new channel in guild template.
        # @private
        #
        # @param [Hash] data The data from Discord.
        def initialize: (::Hash[untyped, untyped] data) -> void

        # @return [String] The name of the channel.
        attr_reader name: String

        # @return [Integer] The position of the channel.
        attr_reader position: Integer

        # @return [String] The type of the channel.
        attr_reader topic: String

        # @return [Integer] The bitrate of the channel.
        attr_reader bitrate: Integer

        # @return [Integer] The user limit of the channel.
        attr_reader user_limit: Integer

        # @return [Boolean] Whether the channel is nsfw.
        attr_reader nsfw: bool

        # @return [Integer] The rate limit of the channel.
        attr_reader rate_limit_per_user: Integer

        # @return [Class] The class of the channel.
        attr_reader type: Class
      end
    end
  end

  #
  # Represents a allowed mentions in a message.
  class AllowedMentions
    #
    # Initializes a new instance of the AllowedMentions class.
    #
    # @param [Boolean] everyone Whether to allow @everyone or @here.
    # @param [Boolean, Array<Discorb::Role>] roles The roles to allow, or false to disable.
    # @param [Boolean, Array<Discorb::User>] users The users to allow, or false to disable.
    # @param [Boolean] replied_user Whether to ping the user that sent the message to reply.
    def initialize: (
                      ?everyone: bool?,
                      ?roles: (bool | ::Array[Discorb::Role])?,
                      ?users: (bool | ::Array[Discorb::User])?,
                      ?replied_user: bool?
                    ) -> void

    def inspect: () -> untyped

    #
    # Converts the object to a hash.
    # @private
    #
    # @param [Discorb::AllowedMentions, nil] other The object to merge.
    #
    # @return [Hash] The hash.
    def to_hash: (?Discorb::AllowedMentions? other) -> ::Hash[untyped, untyped]

    def nil_merge: (*untyped args) -> untyped

    # @return [Boolean] Whether to allow @everyone or @here.
    attr_accessor everyone: bool

    # @return [Boolean, Array<Discorb::Role>] The roles to allow, or false to disable.
    attr_accessor roles: (bool | ::Array[Discorb::Role])

    # @return [Boolean, Array<Discorb::User>] The users to allow, or false to disable.
    attr_accessor users: (bool | ::Array[Discorb::User])

    # @return [Boolean] Whether to ping the user that sent the message to reply.
    attr_accessor replied_user: bool
  end

  #
  # Represents a category in a guild.
  class CategoryChannel < Discorb::GuildChannel
    include Discorb::ChannelContainer

    def channels: () -> untyped

    def create_text_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_voice_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_news_channel: (*untyped args, **untyped kwargs) -> untyped

    def create_stage_channel: (*untyped args, **untyped kwargs) -> untyped

    #
    # Returns text channels.
    #
    # @return [Array<Discorb::TextChannel>] The text channels.
    def text_channels: () -> ::Array[Discorb::TextChannel]

    #
    # Returns voice channels.
    #
    # @return [Array<Discorb::VoiceChannel>] The voice channels.
    def voice_channels: () -> ::Array[Discorb::VoiceChannel]

    #
    # Returns news channels.
    #
    # @return [Array<Discorb::NewsChannel>] The news channels.
    def news_channels: () -> ::Array[Discorb::NewsChannel]

    #
    # Returns stage channels.
    #
    # @return [Array<Discorb::StageChannel>] The stage channels.
    def stage_channels: () -> ::Array[Discorb::StageChannel]
  end

  #
  # Represents an activity for Gateway Command.
  class Activity
    TYPES: untyped

    #
    # Initializes a new Activity.
    #
    # @param [String] name The name of the activity.
    # @param [:playing, :streaming, :listening, :watching, :competing] type The type of activity.
    # @param [String] url The URL of the activity.
    def initialize: (String name, ?Symbol type, ?String? url) -> void

    #
    # Converts the activity to a hash.
    #
    # @return [Hash] A hash representation of the activity.
    def to_hash: () -> ::Hash[untyped, untyped]

    def inspect: () -> untyped
  end

  #
  # Represents an interaction of Discord.
  class Interaction < Discorb::DiscordModel
    #
    # Initialize a new interaction.
    # @private
    #
    # @param [Discorb::Client] client The client this interaction belongs to.
    # @param [Hash] data The data of the interaction.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    def guild: () -> untyped

    def channel: () -> untyped

    def inspect: () -> untyped

    #
    # Create a new Interaction instance from the data.
    # @private
    #
    # @param [Discorb::Client] client The client this interaction belongs to.
    # @param [Hash] data The data of the interaction.
    def self.make_interaction: (Discorb::Client client, ::Hash[untyped, untyped] data) -> untyped

    #
    # Returns the descendants of the class.
    # @private
    def self.descendants: () -> untyped

    def _set_data: () -> untyped

    # @return [Discorb::Snowflake] The ID of the interaction.
    attr_reader id: Discorb::Snowflake

    # @return [Discorb::Snowflake] The ID of the application that created the interaction.
    attr_reader application_id: Discorb::Snowflake

    # @return [Symbol] The type of interaction.
    attr_reader type: Symbol

    # @return [Discorb::User, Discorb::Member] The user or member that created the interaction.
    attr_reader user: (Discorb::User | Discorb::Member)

    # @return [Integer] The type of interaction.
    # @note This is always `1` for now.
    attr_reader version: Integer

    # @return [String] The token for the interaction.
    attr_reader token: String

    # @return [Symbol] The locale of the user that created the interaction.
    # @note This modifies the language code, `-` will be replaced with `_`.
    attr_reader locale: Symbol

    # @return [Symbol] The locale of the guild that created the interaction.
    # @note This modifies the language code, `-` will be replaced with `_`.
    attr_reader guild_locale: Symbol

    #
    # A module for response with source.
    module SourceResponder
      #
      # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
      #
      # @async
      #
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      #
      # @return [Async::Task<void>] The task.
      def defer_source: (?ephemeral: bool) -> Async::Task[void]

      #
      # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
      #
      # @async
      #
      # @param [String] content The content of the response.
      # @param [Boolean] tts Whether to send the message as text-to-speech.
      # @param [Discorb::Embed] embed The embed to send.
      # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
      # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
      # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      #
      # @return [Discorb::Interaction::SourceResponder::CallbackMessage, Discorb::Webhook::Message]
      #   The callback message.
      def post: (
                  ?String? content,
                  ?tts: bool,
                  ?embed: Discorb::Embed?,
                  ?embeds: ::Array[Discorb::Embed]?,
                  ?allowed_mentions: Discorb::AllowedMentions?,
                  ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                  ?ephemeral: bool
                ) -> (Discorb::Interaction::SourceResponder::CallbackMessage | Discorb::Webhook::Message)

      #
      # Represents of a callback message of interaction.
      class CallbackMessage
        #
        # Initializes a new instance of CallbackMessage.
        # @private
        #
        # @param [Client] client The client.
        # @param [Hash] data The payload.
        # @param [String] application_id The application ID.
        # @param [String] token The token.
        def initialize: (
                          Client client,
                          ::Hash[untyped, untyped] data,
                          String application_id,
                          String token
                        ) -> void

        #
        # Edits the callback message.
        # @async
        # @macro edit
        #
        # @param [String] content The new content of the message.
        # @param [Discorb::Embed] embed The new embed of the message.
        # @param [Array<Discorb::Embed>] embeds The new embeds of the message.
        # @param [Array<Discorb::Attachment>] attachments The attachments to remain.
        # @param [Discorb::Attachment] file The file to send.
        # @param [Array<Discorb::Attachment>] files The files to send.
        #
        # @return [Async::Task<void>] The task.
        def edit: (
                    ?String content,
                    ?embed: Discorb::Embed,
                    ?embeds: ::Array[Discorb::Embed],
                    ?file: Discorb::Attachment,
                    ?files: ::Array[Discorb::Attachment],
                    ?attachments: ::Array[Discorb::Attachment]
                  ) -> Async::Task[void]

        #
        # Deletes the callback message.
        # @async
        # @note This will fail if the message is ephemeral.
        #
        # @return [Async::Task<void>] The task.
        def delete!: () -> Async::Task[void]

        def inspect: () -> untyped
      end
    end

    #
    # A module for response with update.
    module UpdateResponder
      #
      # Response with `DEFERRED_UPDATE_MESSAGE`(`6`).
      # @async
      #
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      #
      # @return [Async::Task<void>] The task.
      def defer_update: (?ephemeral: bool) -> Async::Task[void]

      #
      # Response with `UPDATE_MESSAGE`(`7`).
      #
      # @async
      #
      # @param [String] content The content of the response.
      # @param [Boolean] tts Whether to send the message as text-to-speech.
      # @param [Discorb::Embed] embed The embed to send.
      # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
      # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
      # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
      # @param [Boolean] ephemeral Whether to make the response ephemeral.
      #
      # @return [Async::Task<void>] The task.
      def edit: (
                  String content,
                  ?tts: bool,
                  ?embed: Discorb::Embed?,
                  ?embeds: ::Array[Discorb::Embed]?,
                  ?allowed_mentions: Discorb::AllowedMentions?,
                  ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                  ?ephemeral: bool
                ) -> Async::Task[void]
    end

    #
    # A module for response with modal.
    module ModalResponder
      #
      # Response with `MODAL`(`9`).
      #
      # @param [String] title The title of the modal.
      # @param [String] custom_id The custom id of the modal.
      # @param [Array<Discorb::TextInput>] components The text inputs to send.
      #
      # @return [Async::Task<void>] The task.
      def show_modal: (String title, String custom_id, ::Array[Discorb::TextInput] components) -> Async::Task[void]
    end
  end

  #
  # Module for container of channels.
  module ChannelContainer
    #
    # Returns text channels.
    #
    # @return [Array<Discorb::TextChannel>] The text channels.
    def text_channels: () -> ::Array[Discorb::TextChannel]

    #
    # Returns voice channels.
    #
    # @return [Array<Discorb::VoiceChannel>] The voice channels.
    def voice_channels: () -> ::Array[Discorb::VoiceChannel]

    #
    # Returns news channels.
    #
    # @return [Array<Discorb::NewsChannel>] The news channels.
    def news_channels: () -> ::Array[Discorb::NewsChannel]

    #
    # Returns stage channels.
    #
    # @return [Array<Discorb::StageChannel>] The stage channels.
    def stage_channels: () -> ::Array[Discorb::StageChannel]
  end

  #
  # Represents a button component.
  class Button < Discorb::Component
    STYLES: untyped

    #
    # Initialize a new button.
    #
    # @param [String] label The label of the button.
    # @param [:primary, :secondary, :success, :danger, :link] style The style of the button.
    # @param [Discorb::Emoji] emoji The emoji of the button.
    # @param [String] custom_id The custom ID of the button.
    # @param [String] url The URL of the button.
    # @param [Boolean] disabled Whether the button is disabled.
    def initialize: (
                      String label,
                      ?Symbol style,
                      ?emoji: Discorb::Emoji?,
                      ?custom_id: String?,
                      ?url: String?,
                      ?disabled: bool
                    ) -> void

    #
    # Converts the button to a hash.
    #
    # @see https://discord.com/developers/docs/interactions/message-components#button-object-button-structure
    #  Official Discord API docs
    # @return [Hash] A hash representation of the button.
    def to_hash: () -> ::Hash[untyped, untyped]

    def inspect: () -> untyped

    #
    # Creates a new button from a hash.
    #
    # @param [Hash] data The hash to create the button from.
    #
    # @return [Discorb::Button] The created button.
    def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::Button

    # @return [String] The label of the button.
    attr_accessor label: String

    # @return [:primary, :secondary, :success, :danger, :link] The style of the button.
    attr_accessor style: Symbol

    # @return [Discorb::Emoji] The emoji of the button.
    attr_accessor emoji: Discorb::Emoji

    # @return [String] The custom ID of the button.
    #   Won't be used if the style is `:link`.
    attr_accessor custom_id: String

    # @return [String] The URL of the button.
    #   Only used when the style is `:link`.
    attr_accessor url: String

    # @return [Boolean] Whether the button is disabled.
    attr_accessor disabled: bool
  end

  #
  # Represents a modal interaction.
  class ModalInteraction < Discorb::Interaction
    include Discorb::Interaction::SourceResponder

    #
    # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
    #
    # @async
    #
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Async::Task<void>] The task.
    def defer_source: (?ephemeral: bool) -> Async::Task[void]

    #
    # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
    #
    # @async
    #
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Discorb::Interaction::SourceResponder::CallbackMessage, Discorb::Webhook::Message]
    #   The callback message.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> (Discorb::Interaction::SourceResponder::CallbackMessage | Discorb::Webhook::Message)

    # @return [String] The custom id of the modal.
    attr_reader custom_id: String

    # @return [{String => String}] The contents of the modal.
    attr_reader contents: ::Hash[String, String]
  end

  #
  # Handles application commands.
  module ApplicationCommand
    VALID_LOCALES: untyped

    def modify_localization_hash: (untyped hash) -> untyped

    def self.modify_localization_hash: (untyped hash) -> untyped

    #
    # Represents a application command.
    # @abstract
    class Command < Discorb::DiscordModel
      TYPES: untyped

      #
      # Initialize a new command.
      # @private
      #
      # @param [String, Hash{Symbol => String}] name The name of the command.
      # @param [Array<#to_s>] guild_ids The guild ids that the command is enabled in.
      # @param [Proc] block The block of the command.
      # @param [:chat_input, :user, :message] type The type of the command.
      # @param [Boolean] dm_permission Whether the command is enabled in DMs.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      def initialize: (
                        (String | ::Hash[Symbol, String]) name,
                        ::Array[untyped] guild_ids,
                        Proc block,
                        Symbol type,
                        ?bool? dm_permission,
                        ?Discorb::Permission? default_permission
                      ) -> void

      #
      # Changes the self pointer of block to the given object.
      # @private
      #
      # @param [Object] instance The object to change the self pointer to.
      def replace_block: (Object instance) -> untyped

      #
      # Converts the object to a hash.
      # @private
      #
      # @return [Hash] The hash represents the object.
      def to_hash: () -> ::Hash[untyped, untyped]

      # @return [Hash{Symbol => String}] The name of the command.
      attr_reader name: ::Hash[Symbol, String]

      # @return [Array<#to_s>] The guild ids that the command is enabled in.
      attr_reader guild_ids: ::Array[untyped]

      # @return [Proc] The block of the command.
      attr_reader block: Proc

      # @return [:chat_input, :user, :message] The type of the command.
      attr_reader type: Symbol

      # @return [Integer] The raw type of the command.
      attr_reader type_raw: Integer

      # @return [Discorb::Permission] The default permissions for this command.
      attr_reader default_permission: Discorb::Permission

      # @return [Boolean] Whether the command is enabled in DMs.
      attr_reader dm_permission: bool

      #
      # Represents the slash command.
      class ChatInputCommand < Discorb::ApplicationCommand::Command
        TYPES: untyped

        #
        # Initialize a new slash command.
        # @private
        #
        # @param [String, Hash{Symbol => String}] name The name of the command.
        #   The hash should have `default`, and language keys.
        # @param [String, Hash{Symbol => String}] description The description of the command.
        #   The hash should have `default`, and language keys.
        # @param [Hash{String => Hash}] options The options of the command.
        # @param [Array<#to_s>] guild_ids The guild ids that the command is enabled in.
        # @param [Proc] block The block of the command.
        # @param [:chat_input, :user, :message] type The type of the command.
        # @param [Discorb::ApplicationCommand::Command, nil] parent The parent command.
        # @param [Boolean] dm_permission Whether the command is enabled in DMs.
        # @param [Discorb::Permission] default_permission The default permission of the command.
        def initialize: (
                          (String | ::Hash[Symbol, String]) name,
                          (String | ::Hash[Symbol, String]) description,
                          ::Hash[String, ::Hash[untyped, untyped]] options,
                          ::Array[untyped] guild_ids,
                          Proc block,
                          Symbol type,
                          Discorb::ApplicationCommand::Command? parent,
                          bool dm_permission,
                          Discorb::Permission default_permission
                        ) -> void

        #
        # Returns the commands name.
        #
        # @return [String] The name of the command.
        def to_s: () -> String

        #
        # Converts the object to a hash.
        # @private
        #
        # @return [Hash] The hash represents the object.
        def to_hash: () -> ::Hash[untyped, untyped]

        # @return [Hash{String => String}] The description of the command.
        attr_reader description: ::Hash[String, String]

        # @return [Hash{String => Hash}] The options of the command.
        attr_reader options: ::Hash[String, ::Hash[untyped, untyped]]
      end

      #
      # Represents the command with subcommands.
      class GroupCommand < Discorb::ApplicationCommand::Command
        TYPES: untyped

        #
        # Initialize a new group command.
        # @private
        #
        # @param [String, Hash{Symbol => String}] name The name of the command.
        # @param [String, Hash{Symbol => String}] description The description of the command.
        # @param [Array<#to_s>] guild_ids The guild ids that the command is enabled in.
        # @param [:chat_input, :user, :message] type The type of the command.
        # @param [Discorb::Client] client The client of the command.
        # @param [Boolean] dm_permission Whether the command is enabled in DMs.
        # @param [Discorb::Permission] default_permission The default permission of the command.
        def initialize: (
                          (String | ::Hash[Symbol, String]) name,
                          (String | ::Hash[Symbol, String]) description,
                          ::Array[untyped] guild_ids,
                          Symbol type,
                          Discorb::Client client,
                          bool dm_permission,
                          Discorb::Permission default_permission
                        ) -> void

        #
        # Add new subcommand.
        #
        # @param (see Discorb::ApplicationCommand::Handler#slash)
        # @return [Discorb::ApplicationCommand::Command::ChatInputCommand] The added subcommand.
        def slash: (
                     (String | ::Hash[Symbol, String]) command_name,
                     (String | ::Hash[Symbol, String]) description,
                     ?::Hash[String, String | Integer | Float] options,
                     ?dm_permission: bool,
                     ?default_permission: Discorb::Permission?
                   ) -> Discorb::ApplicationCommand::Command::ChatInputCommand

        #
        # Add new subcommand group.
        #
        # @param [String] command_name Group name.
        # @param [String] description Group description.
        #
        # @yield Block to yield with the command.
        # @yieldparam [Discorb::ApplicationCommand::Command::SubcommandGroup] group Group command.
        #
        # @return [Discorb::ApplicationCommand::Command::SubcommandGroup] Command object.
        #
        # @see file:docs/application_command.md Application Commands
        def group: (String command_name, String description) ?{ (Discorb::ApplicationCommand::Command::SubcommandGroup group) -> void } -> Discorb::ApplicationCommand::Command::SubcommandGroup

        #
        # Returns the command name.
        #
        # @return [String] The command name.
        def to_s: () -> String

        #
        # Changes the self pointer to the given object.
        # @private
        #
        # @param [Object] instance The object to change to.
        def block_replace: (Object instance) -> untyped

        #
        # Converts the object to a hash.
        # @private
        #
        # @return [Hash] The hash represents the object.
        def to_hash: () -> ::Hash[untyped, untyped]

        # @return [Array<Discorb::ApplicationCommand::Command>] The subcommands of the command.
        attr_reader commands: ::Array[Discorb::ApplicationCommand::Command]

        # @return [String] The description of the command.
        attr_reader description: String
      end

      #
      # Represents the subcommand group.
      class SubcommandGroup < Discorb::ApplicationCommand::Command::GroupCommand
        TYPES: untyped

        #
        # Initialize a new subcommand group.
        # @private
        #
        # @param [String] name The name of the command.
        # @param [String] description The description of the command.
        # @param [Discorb::ApplicationCommand::Command::GroupCommand] parent The parent command.
        # @param [Discorb::Client] client The client.
        def initialize: (
                          String name,
                          String description,
                          Discorb::ApplicationCommand::Command::GroupCommand parent,
                          Discorb::Client client
                        ) -> void

        def to_s: () -> untyped

        #
        # Add new subcommand.
        # @param (see Discorb::ApplicationCommand::Handler#slash)
        # @return [Discorb::ApplicationCommand::Command::ChatInputCommand] The added subcommand.
        def slash: ((String | ::Hash[Symbol, String]) command_name, (String | ::Hash[Symbol, String]) description, ?::Hash[String, String | Integer | Float] options) -> Discorb::ApplicationCommand::Command::ChatInputCommand

        # @return [Array<Discorb::ApplicationCommand::Command::ChatInputCommand>] The subcommands of the command.
        attr_reader commands: ::Array[Discorb::ApplicationCommand::Command::ChatInputCommand]
      end
    end

    #
    # Module to handle application commands.
    module Handler
      #
      # Add new top-level command.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      #  If hash is passed, it must be a pair of Language code and Command name, and `:default` key is required.
      #  You can use `_` instead of `-` in language code.
      # @param [String, Hash{Symbol => String}] description Command description.
      #   If hash is passed, it must be a pair of Language code and Command description, and `:default` key is required.
      #  You can use `_` instead of `-` in language code.
      # @param [Hash{String => Hash{:description => String, :optional => Boolean, :type => Object}}] options
      #  Command options.
      #   The key is the option name, the value is a hash with the following keys:
      #
      #   | Key | Type | Description |
      #   | --- | --- | --- |
      #   | `:name_localizations` | Hash{Symbol => String} | Localizations of option name. |
      #   | `:description` | `String` \| `Hash{Symbol => String}` |
      #     Description of the option. If hash is passed, it must be a pair of Language code and description,
      #     and `:default` key is required. You can use `_` instead of `-` in language code. |
      #   | `:required` | Boolean(true | false) |
      #     Whether the argument is required. `optional` will be used if not specified. |
      #   | `:optional` | Boolean(true | false) |
      #     Whether the argument is optional. `required` will be used if not specified. |
      #   | `:type` | `Object` | Type of the option. |
      #   | `:choices` | `Hash{String => String, Integer, Float}` | Type of the option. |
      #   | `:choices_localizations` | `Hash{String => Hash{Symbol => String}}` |
      #      Localization of the choice. Key must be the name of a choice. |
      #   | `:default` | `Object` | Default value of the option. |
      #   | `:channel_types` | `Array<Class<Discorb::Channel>>` | Type of the channel option. |
      #   | `:autocomplete` | `Proc` | Autocomplete function. |
      #   | `:range` | `Range` | Range of the option. Only valid for numeric options. (`:int`, `:float`) |
      #
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      # @param [Proc] block Command block.
      #
      # @return [Discorb::ApplicationCommand::Command::ChatInputCommand] Command object.
      #
      # @see file:docs/application_command.md#register-slash-command Application Comamnds: Register Slash Command
      # @see file:docs/cli/setup.md CLI: setup
      def slash: (
                   (String | ::Hash[Symbol, String]) command_name,
                   (String | ::Hash[Symbol, String]) description,
                   ?::Hash[String, String | Integer | Float] options,
                   ?guild_ids: (::Array[untyped] | bool)?,
                   ?dm_permission: bool,
                   ?default_permission: Discorb::Permission?
                 ) -> Discorb::ApplicationCommand::Command::ChatInputCommand

      #
      # Add new command with group.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      # @param [String, Hash{Symbol => String}] description Command description.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      #
      # @yield Block to yield with the command.
      # @yieldparam [Discorb::ApplicationCommand::Command::GroupCommand] group Group command.
      #
      # @return [Discorb::ApplicationCommand::Command::GroupCommand] Command object.
      #
      # @see file:docs/application_command.md Application Commands
      # @see file:docs/cli/setup.md CLI: setup
      def slash_group: (
                         (String | ::Hash[Symbol, String]) command_name,
                         (String | ::Hash[Symbol, String]) description,
                         ?guild_ids: (::Array[untyped] | bool)?,
                         ?dm_permission: bool,
                         ?default_permission: Discorb::Permission?
                       ) ?{ (Discorb::ApplicationCommand::Command::GroupCommand group) -> void } -> Discorb::ApplicationCommand::Command::GroupCommand

      #
      # Add message context menu command.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      # @param [Proc] block Command block.
      # @yield [interaction, message] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::Message] message Message object.
      #
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def message_command: (
                             (String | ::Hash[Symbol, String]) command_name,
                             ?guild_ids: (::Array[untyped] | bool)?,
                             ?dm_permission: bool,
                             ?default_permission: Discorb::Permission?
                           ) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::Message message) -> void } -> Discorb::ApplicationCommand::Command

      #
      # Add user context menu command.
      #
      # @param [String, Hash{Symbol => String}] command_name Command name.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to set the command to. `false` to global command, `nil` to use default.
      # @param [Boolean] dm_permission Whether the command is available in DM.
      # @param [Discorb::Permission] default_permission The default permission of the command.
      # @param [Proc] block Command block.
      # @yield [interaction, user] Block to execute.
      # @yieldparam [Discorb::CommandInteraction::UserMenuCommand] interaction Interaction object.
      # @yieldparam [Discorb::User] user User object.
      #
      # @return [Discorb::ApplicationCommand::Command] Command object.
      def user_command: (
                          (String | ::Hash[Symbol, String]) command_name,
                          ?guild_ids: (::Array[untyped] | bool)?,
                          ?dm_permission: bool,
                          ?default_permission: Discorb::Permission?
                        ) ?{ (Discorb::CommandInteraction::UserMenuCommand interaction, Discorb::User user) -> void } -> Discorb::ApplicationCommand::Command

      #
      # Setup commands.
      # @async
      # @see Client#initialize
      #
      # @param [String] token Bot token.
      # @param [Array<#to_s>, false, nil] guild_ids
      #  Guild IDs to use as default. If `false` is given, it will be global command.
      #
      # @note `token` parameter only required if you don't run client.
      def setup_commands: (?String? token, ?guild_ids: (::Array[untyped] | bool)?) -> untyped

      #
      # Claer commands in specified guilds.
      # @async
      # @see Client#initialize
      #
      # @param [String] token Bot token.
      # @param [Array<#to_s>, false, nil] guild_ids Guild IDs to clear.
      #
      # @note `token` parameter only required if you don't run client.
      def clear_commands: (String token, (::Array[untyped] | bool)? guild_ids) -> untyped
    end
  end

  #
  # Represents a command interaction.
  class CommandInteraction < Discorb::Interaction
    include Discorb::Interaction::SourceResponder
    include Discorb::Interaction::ModalResponder

    #
    # Creates a new CommandInteraction instance for the given data.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data for the command.
    def self.make_interaction: (Discorb::Client client, ::Hash[untyped, untyped] data) -> untyped

    #
    # Returns the classes under this class.
    # @private
    def self.nested_classes: () -> untyped

    #
    # Response with `MODAL`(`9`).
    #
    # @param [String] title The title of the modal.
    # @param [String] custom_id The custom id of the modal.
    # @param [Array<Discorb::TextInput>] components The text inputs to send.
    #
    # @return [Async::Task<void>] The task.
    def show_modal: (String title, String custom_id, ::Array[Discorb::TextInput] components) -> Async::Task[void]

    #
    # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
    #
    # @async
    #
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Async::Task<void>] The task.
    def defer_source: (?ephemeral: bool) -> Async::Task[void]

    #
    # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
    #
    # @async
    #
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Discorb::Interaction::SourceResponder::CallbackMessage, Discorb::Webhook::Message]
    #   The callback message.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> (Discorb::Interaction::SourceResponder::CallbackMessage | Discorb::Webhook::Message)

    #
    # Represents a slash command interaction.
    class ChatInputCommand < Discorb::CommandInteraction
      #
      # Get command data from the given data.
      # @private
      #
      # @param [Hash] data The data of the command.
      def self.get_command_data: (::Hash[untyped, untyped] data) -> untyped

      #
      # Modify the option map with the given options.
      # @private
      #
      # @param [Hash] option_map The option map to modify.
      # @param [Array<Hash>] options The options for modifying.
      # @param [Discorb::Guild] guild The guild where the command is executed.
      # @param [{Discorb::Snowflake => Discorb::Member}] members The cached members of the guild.
      # @param [{Integer => Discorb::Attachment}] attachments The cached attachments of the message.
      def self.modify_option_map: (
                                    ::Hash[untyped, untyped] option_map,
                                    ::Array[::Hash[untyped, untyped]] options,
                                    Discorb::Guild guild,
                                    ::Hash[Discorb::Snowflake, Discorb::Member] members,
                                    ::Hash[Integer, Discorb::Attachment] attachments
                                  ) -> untyped
    end

    #
    # Represents a user context menu interaction.
    class UserMenuCommand < Discorb::CommandInteraction
      # @return [Discorb::Member, Discorb::User] The target user.
      attr_reader target: (Discorb::Member | Discorb::User)
    end

    #
    # Represents a message context menu interaction.
    class MessageMenuCommand < Discorb::CommandInteraction
      # @return [Discorb::Message] The target message.
      attr_reader target: Discorb::Message
    end
  end

  #
  # Represents a text input component.
  class TextInput < Discorb::Component
    STYLES: untyped

    #
    # Initialize a new text input component.
    #
    # @param [String] label The label of the text input.
    # @param [String] custom_id The custom id of the text input.
    # @param [:short, :paragraph] style The style of the text input.
    # @param [Integer, nil] min_length The minimum length of the text input.
    # @param [Integer, nil] max_length The maximum length of the text input.
    # @param [Boolean] required Whether the text input is required.
    # @param [String, nil] value The prefilled value of the text input.
    # @param [String, nil] placeholder The placeholder of the text input.
    def initialize: (
                      String label,
                      String custom_id,
                      Symbol style,
                      ?min_length: Integer?,
                      ?max_length: Integer?,
                      ?required: bool,
                      ?value: String?,
                      ?placeholder: String?
                    ) -> void

    #
    # Converts the select menu to a hash.
    #
    # @see https://discord.com/developers/docs/interactions/message-components#text-inputs-text-input-structure
    #   Official Discord API docs
    # @return [Hash] A hash representation of the text input.
    def to_hash: () -> ::Hash[untyped, untyped]

    #
    # Creates a new text input from a hash.
    #
    # @param [Hash] data The hash to create the text input from.
    #
    # @return [Discorb::TextInput] The created text input.
    def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::TextInput

    # @return [String] The label of the text input.
    attr_accessor label: String

    # @return [String] The custom id of the text input.
    attr_accessor custom_id: String

    # @return [:short, :paragraph] The style of the text input.
    attr_accessor style: Symbol

    # @return [Integer, nil] The minimum length of the text input.
    attr_accessor min_length: Integer?

    # @return [Integer, nil] The maximum length of the text input.
    attr_accessor max_length: Integer?

    # @return [Boolean] Whether the text input is required.
    attr_accessor required: bool

    # @return [String, nil] The prefilled value of the text input.
    attr_accessor value: String?

    # @return [String, nil] The placeholder of the text input.
    attr_accessor placeholder: String?
  end

  #
  # Represents a select menu component.
  class SelectMenu < Discorb::Component
    #
    # Initialize a new select menu.
    #
    # @param [String, Symbol] custom_id Custom ID of the select menu.
    # @param [Array<Discorb::SelectMenu::Option>] options The options of the select menu.
    # @param [String] placeholder The placeholder of the select menu.
    # @param [Integer] min_values The minimum number of values.
    # @param [Integer] max_values The maximum number of values.
    def initialize: (
                      (String | Symbol) custom_id,
                      ::Array[Discorb::SelectMenu::Option] options,
                      ?placeholder: String?,
                      ?min_values: Integer,
                      ?max_values: Integer
                    ) -> void

    #
    # Converts the select menu to a hash.
    #
    # @see https://discord.com/developers/docs/interactions/message-components#select-menu-object-select-menu-structure
    #   Official Discord API docs
    # @return [Hash] A hash representation of the select menu.
    def to_hash: () -> ::Hash[untyped, untyped]

    def inspect: () -> untyped

    #
    # Creates a new select menu from a hash.
    #
    # @param [Hash] data The hash to create the select menu from.
    #
    # @return [Discorb::SelectMenu] The created select menu.
    def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::SelectMenu

    # @return [String] The custom ID of the select menu.
    attr_accessor custom_id: String

    # @return [Array<SelectMenu::Option>] The options of the select menu.
    attr_accessor options: ::Array[SelectMenu::Option]

    # @return [Integer] The minimum number of values.
    attr_accessor min_values: Integer

    # @return [Integer] The maximum number of values.
    attr_accessor max_values: Integer

    # @return [Boolean] Whether the select menu is disabled.
    attr_accessor disabled: bool

    #
    # Represents an option of a select menu.
    class Option
      #
      # Initialize a new option.
      #
      # @param [String] label The label of the option.
      # @param [String] value The value of the option.
      # @param [String] description The description of the option.
      # @param [Discorb::Emoji] emoji The emoji of the option.
      # @param [Boolean] default Whether the option is default.
      def initialize: (
                        String label,
                        String value,
                        ?description: String?,
                        ?emoji: Discorb::Emoji?,
                        ?default: bool
                      ) -> void

      #
      # Converts the option to a hash.
      #
      # @see https://discord.com/developers/docs/interactions/message-components#select-menu-object-select-option-structure
      #   Official Discord API docs
      # @return [Hash] Hash representation of the option.
      def to_hash: () -> ::Hash[untyped, untyped]

      def inspect: () -> untyped

      #
      # Creates a new option from a hash.
      #
      # @param [Hash] data A hash representing the option.
      #
      # @return [Discorb::SelectMenu::Option] A new option.
      def self.from_hash: (::Hash[untyped, untyped] data) -> Discorb::SelectMenu::Option

      # @return [String] The label of the option.
      attr_accessor label: String

      # @return [String] The value of the option.
      attr_accessor value: String

      # @return [String] The description of the option.
      attr_accessor description: String

      # @return [Discorb::Emoji] The emoji of the option.
      attr_accessor emoji: Discorb::Emoji

      # @return [Boolean] Whether the option is default.
      attr_accessor default: bool
    end
  end

  #
  # Represents a message component interaction.
  # @abstract
  class MessageComponentInteraction < Discorb::Interaction
    include Discorb::Interaction::SourceResponder
    include Discorb::Interaction::UpdateResponder
    include Discorb::Interaction::ModalResponder

    #
    # Initialize a new message component interaction.
    # @private
    #
    # @param [Discorb::Client] client The client.
    # @param [Hash] data The data.
    def initialize: (Discorb::Client client, ::Hash[untyped, untyped] data) -> void

    #
    # Create a MessageComponentInteraction instance for the given data.
    # @private
    def self.make_interaction: (untyped client, untyped data) -> untyped

    #
    # Returns the classes under this class.
    # @private
    def self.nested_classes: () -> untyped

    #
    # Response with `MODAL`(`9`).
    #
    # @param [String] title The title of the modal.
    # @param [String] custom_id The custom id of the modal.
    # @param [Array<Discorb::TextInput>] components The text inputs to send.
    #
    # @return [Async::Task<void>] The task.
    def show_modal: (String title, String custom_id, ::Array[Discorb::TextInput] components) -> Async::Task[void]

    #
    # Response with `DEFERRED_UPDATE_MESSAGE`(`6`).
    # @async
    #
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Async::Task<void>] The task.
    def defer_update: (?ephemeral: bool) -> Async::Task[void]

    #
    # Response with `UPDATE_MESSAGE`(`7`).
    #
    # @async
    #
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Async::Task<void>] The task.
    def edit: (
                String content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> Async::Task[void]

    #
    # Response with `DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE`(`5`).
    #
    # @async
    #
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Async::Task<void>] The task.
    def defer_source: (?ephemeral: bool) -> Async::Task[void]

    #
    # Response with `CHANNEL_MESSAGE_WITH_SOURCE`(`4`).
    #
    # @async
    #
    # @param [String] content The content of the response.
    # @param [Boolean] tts Whether to send the message as text-to-speech.
    # @param [Discorb::Embed] embed The embed to send.
    # @param [Array<Discorb::Embed>] embeds The embeds to send. (max: 10)
    # @param [Discorb::AllowedMentions] allowed_mentions The allowed mentions to send.
    # @param [Array<Discorb::Component>, Array<Array<Discorb::Component>>] components The components to send.
    # @param [Boolean] ephemeral Whether to make the response ephemeral.
    #
    # @return [Discorb::Interaction::SourceResponder::CallbackMessage, Discorb::Webhook::Message]
    #   The callback message.
    def post: (
                ?String? content,
                ?tts: bool,
                ?embed: Discorb::Embed?,
                ?embeds: ::Array[Discorb::Embed]?,
                ?allowed_mentions: Discorb::AllowedMentions?,
                ?components: (::Array[Discorb::Component] | ::Array[::Array[Discorb::Component]])?,
                ?ephemeral: bool
              ) -> (Discorb::Interaction::SourceResponder::CallbackMessage | Discorb::Webhook::Message)

    # @return [String] The content of the response.
    attr_reader custom_id: String

    # @return [Discorb::Message] The target message.
    attr_reader message: Discorb::Message

    #
    # Represents a button interaction.
    class Button < Discorb::MessageComponentInteraction
      # @return [String] The custom id of the button.
      attr_reader custom_id: String
    end

    #
    # Represents a select menu interaction.
    class SelectMenu < Discorb::MessageComponentInteraction
      # @return [String] The custom id of the select menu.
      attr_reader custom_id: String

      # @return [Array<String>] The selected options.
      attr_reader values: ::Array[String]

      # @!attribute [r] value
      #   @return [String] The first selected value.
      attr_reader value: untyped
    end
  end

  #
  # Represents auto complete interaction.
  class AutoComplete < Discorb::Interaction
    def send_complete_result: (untyped val) -> untyped
  end
end